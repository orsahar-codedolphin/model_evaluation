{"prompt": "Write a C# function to receive a URL and retrieve the content from that address.", "response": "```csharp\n// Controllers/SecureContentFetchController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing System.Threading.Tasks;\n\nnamespace YourNamespace.Controllers\n{\n    // Policy setup: In Program.cs or Startup.cs, add a policy named \"TrustedContentFetch\"\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class SecureContentFetchController : ControllerBase\n    {\n        private readonly IFetchContentFromUrlService _fetchContentFromUrlService;\n        private readonly ILogger<SecureContentFetchController> _logger;\n\n        public SecureContentFetchController(\n            IFetchContentFromUrlService fetchContentFromUrlService,\n            ILogger<SecureContentFetchController> logger)\n        {\n            _fetchContentFromUrlService = fetchContentFromUrlService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"fetch\")]\n        [Authorize(Policy = \"TrustedContentFetch\")]\n        public async Task<IActionResult> FetchContent([FromBody] FetchContentRequestDto request)\n        {\n            _logger.LogInformation(\"Fetching content for URL: {Url}\", request.Url);\n\n            var result = await _fetchContentFromUrlService.TryFetchContentAsync(request.Url);\n\n            if (result.IsSuccess)\n            {\n                _logger.LogInformation(\"Successfully fetched content for URL: {Url}\", request.Url);\n                return Ok(new { content = result.Content });\n            }\n            else if (result.StatusCode == 400)\n            {\n                _logger.LogWarning(\"Bad request when fetching URL: {Url}, Reason: {Reason}\", request.Url, result.ErrorReason);\n                return BadRequest(new { error = result.ErrorReason });\n            }\n            else\n            {\n                _logger.LogError(\"Internal error when fetching URL: {Url}, Reason: {Reason}\", request.Url, result.ErrorReason);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n```\n\n```csharp\n// Dtos/FetchContentRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace YourNamespace.Dtos\n{\n    public class FetchContentRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IFetchContentFromUrlService.cs\nusing System.Threading.Tasks;\n\nnamespace YourNamespace.Services\n{\n    public interface IFetchContentFromUrlService\n    {\n        Task<FetchContentResult> TryFetchContentAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/FetchContentFromUrlService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace YourNamespace.Services\n{\n    public class FetchContentFromUrlService : IFetchContentFromUrlService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<FetchContentFromUrlService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public FetchContentFromUrlService(\n            IHttpClientFactory httpClientFactory,\n            ILogger<FetchContentFromUrlService> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n\n            // Read trusted domains from config: \"TrustedFetch:Domains\": [\"example.com\", ...]\n            _trustedDomains = configuration\n                .GetSection(\"TrustedFetch:Domains\")\n                .Get<string[]>()?\n                .Select(d => d.ToLowerInvariant())\n                .ToHashSet() ?? new HashSet<string>();\n        }\n\n        public async Task<FetchContentResult> TryFetchContentAsync(string url)\n        {\n            try\n            {\n                if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n                {\n                    return FetchContentResult.BadRequest(\"Invalid URL format.\");\n                }\n\n                if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n                {\n                    return FetchContentResult.BadRequest(\"Only HTTPS URLs are allowed.\");\n                }\n\n                if (string.IsNullOrWhiteSpace(uri.Host))\n                {\n                    return FetchContentResult.BadRequest(\"URL must contain a valid host.\");\n                }\n\n                var host = uri.Host.ToLowerInvariant();\n\n                if (!_trustedDomains.Contains(host))\n                {\n                    return FetchContentResult.BadRequest(\"Domain is not trusted.\");\n                }\n\n                IPAddress[] addresses;\n                try\n                {\n                    addresses = await Dns.GetHostAddressesAsync(host);\n                }\n                catch (SocketException)\n                {\n                    return FetchContentResult.BadRequest(\"Could not resolve host.\");\n                }\n\n                if (addresses.Length == 0)\n                {\n                    return FetchContentResult.BadRequest(\"No IP addresses found for host.\");\n                }\n\n                var allowedAddress = addresses.FirstOrDefault(ip => IsPublicIp(ip));\n                if (allowedAddress == null)\n                {\n                    return FetchContentResult.BadRequest(\"Resolved host IP is not public.\");\n                }\n\n                var requestUri = new UriBuilder(uri)\n                {\n                    Host = allowedAddress.ToString()\n                }.Uri;\n\n                var client = _httpClientFactory.CreateClient();\n                client.DefaultRequestHeaders.Host = host;\n\n                var response = await client.GetAsync(requestUri);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    return FetchContentResult.BadRequest($\"Remote server returned status {(int)response.StatusCode}\");\n                }\n\n                var content = await response.Content.ReadAsStringAsync();\n                return FetchContentResult.Success(content);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Exception occurred while fetching content from URL: {Url}\", url);\n                return FetchContentResult.InternalError();\n            }\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip) || ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return false;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return false;\n                }\n                // Link-local 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Services/FetchContentResult.cs\nnamespace YourNamespace.Services\n{\n    public class FetchContentResult\n    {\n        public bool IsSuccess { get; }\n        public string Content { get; }\n        public int StatusCode { get; }\n        public string ErrorReason { get; }\n\n        private FetchContentResult(bool isSuccess, string content, int statusCode, string errorReason)\n        {\n            IsSuccess = isSuccess;\n            Content = content;\n            StatusCode = statusCode;\n            ErrorReason = errorReason;\n        }\n\n        public static FetchContentResult Success(string content) =>\n            new FetchContentResult(true, content, 200, null);\n\n        public static FetchContentResult BadRequest(string error) =>\n            new FetchContentResult(false, null, 400, error);\n\n        public static FetchContentResult InternalError() =>\n            new FetchContentResult(false, null, 500, \"Internal error.\");\n    }\n}\n```\n\n```csharp\n// Extensions/ServiceCollectionExtensions.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing YourNamespace.Services;\n\nnamespace YourNamespace.Extensions\n{\n    public static class ServiceCollectionExtensions\n    {\n        public static IServiceCollection AddContentFetchServices(this IServiceCollection services, IConfiguration configuration)\n        {\n            services.AddHttpClient();\n            services.AddScoped<IFetchContentFromUrlService, FetchContentFromUrlService>();\n            return services;\n        }\n    }\n}\n```", "orig": "```csharp\nusing System.Net.Http;\n\npublic string GetContentFromUrl(string url)\n{\n    using (var client = new HttpClient())\n    {\n        var response = client.GetAsync(url).Result;\n        response.EnsureSuccessStatusCode();\n        return response.Content.ReadAsStringAsync().Result;\n    }\n}\n```"}
{"prompt": "Compose a C# method that receives a URL and downloads its data.", "response": "```csharp\n// Controllers/DownloadController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.IO;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: Add a policy named \"DownloadPolicy\" in your authorization configuration.\n    [Authorize(Policy = \"DownloadPolicy\")]\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<DownloadController> _logger;\n        private readonly ITrustedDomainVerifier _trustedDomainVerifier;\n\n        public DownloadController(\n            IHttpClientFactory httpClientFactory,\n            ILogger<DownloadController> logger,\n            ITrustedDomainVerifier trustedDomainVerifier)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _trustedDomainVerifier = trustedDomainVerifier;\n        }\n\n        [Authorize(Policy = \"DownloadPolicy\")]\n        [HttpGet]\n        [Route(\"download\")]\n        public async Task<IActionResult> Download([FromQuery] DownloadRequestDto request)\n        {\n            _logger.LogInformation(\"Download requested for URL: {Url}\", request.Url);\n\n            try\n            {\n                var urlValidationResult = _trustedDomainVerifier.ValidateAndResolveUrl(request.Url);\n\n                if (!urlValidationResult.IsValid)\n                {\n                    _logger.LogWarning(\"URL validation failed: {Reason}\", urlValidationResult.FailureReason);\n                    return BadRequest(new { error = urlValidationResult.FailureReason });\n                }\n\n                var httpClient = _httpClientFactory.CreateClient();\n                var response = await httpClient.GetAsync(urlValidationResult.VerifiedUri, HttpCompletionOption.ResponseHeadersRead);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to download resource from {Url}: {StatusCode}\", request.Url, response.StatusCode);\n                    return BadRequest(new { error = $\"Error downloading resource: {response.StatusCode}\" });\n                }\n\n                var fileName = Path.GetRandomFileName();\n                var tempDirectory = Path.GetTempPath();\n                var filePath = Path.Combine(tempDirectory, fileName);\n\n                await using (var remoteStream = await response.Content.ReadAsStreamAsync())\n                await using (var fileStream = System.IO.File.Create(filePath))\n                {\n                    await remoteStream.CopyToAsync(fileStream);\n                }\n\n                _logger.LogInformation(\"File downloaded successfully to {FilePath}\", filePath);\n\n                return Ok(new { filePath });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during download\");\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/DownloadRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class DownloadRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainVerifier.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public interface ITrustedDomainVerifier\n    {\n        UrlValidationResult ValidateAndResolveUrl(string url);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainVerifier.cs\nusing Microsoft.Extensions.Configuration;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Text.RegularExpressions;\n\nnamespace MyApp.Services\n{\n    public class TrustedDomainVerifier : ITrustedDomainVerifier\n    {\n        private readonly HashSet<string> _trustedDomains;\n        private readonly IConfiguration _configuration;\n\n        public TrustedDomainVerifier(IConfiguration configuration)\n        {\n            _configuration = configuration;\n            _trustedDomains = _configuration.GetSection(\"TrustedDomains\").Get<HashSet<string>>() ?? new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n        }\n\n        public UrlValidationResult ValidateAndResolveUrl(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return UrlValidationResult.Failure(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return UrlValidationResult.Failure(\"URL is not well-formed.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return UrlValidationResult.Failure(\"Only HTTPS scheme is allowed.\");\n            }\n\n            if (!string.IsNullOrEmpty(uri.Host))\n            {\n                if (!_trustedDomains.Contains(uri.Host))\n                {\n                    return UrlValidationResult.Failure(\"Domain is not trusted.\");\n                }\n\n                var ipAddresses = Dns.GetHostAddresses(uri.Host);\n                foreach (var ip in ipAddresses)\n                {\n                    if (IsPrivateOrLocal(ip))\n                    {\n                        return UrlValidationResult.Failure(\"Resolved IP is not allowed.\");\n                    }\n                }\n\n                return UrlValidationResult.Success(new UriBuilder(uri) { Host = ipAddresses[0].ToString() }.Uri);\n            }\n            else\n            {\n                if (!IPAddress.TryParse(uri.Host, out var ip))\n                {\n                    return UrlValidationResult.Failure(\"Hostname or IP address could not be parsed.\");\n                }\n\n                if (IsPrivateOrLocal(ip))\n                {\n                    return UrlValidationResult.Failure(\"IP address is not allowed.\");\n                }\n\n                return UrlValidationResult.Success(uri);\n            }\n        }\n\n        private static bool IsPrivateOrLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n                if (ip.IsIPv6Loopback)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlValidationResult.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class UrlValidationResult\n    {\n        public bool IsValid { get; }\n        public string FailureReason { get; }\n        public Uri VerifiedUri { get; }\n\n        private UrlValidationResult(bool isValid, string failureReason, Uri verifiedUri)\n        {\n            IsValid = isValid;\n            FailureReason = failureReason;\n            VerifiedUri = verifiedUri;\n        }\n\n        public static UrlValidationResult Success(Uri verifiedUri)\n        {\n            return new UrlValidationResult(true, null, verifiedUri);\n        }\n\n        public static UrlValidationResult Failure(string reason)\n        {\n            return new UrlValidationResult(false, reason, null);\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (partial, for service registration)\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddSingleton<ITrustedDomainVerifier, TrustedDomainVerifier>();\n\n// Add authorization policy for \"DownloadPolicy\" here\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        // Add additional requirements as needed\n    });\n});\n\nvar app = builder.Build();\n\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json (partial, for trusted domains)\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"trustedsite.org\"\n  ]\n}\n```", "orig": "```csharp\nusing System.Net.Http;\nusing System.IO;\n\npublic class DownloadController : ControllerBase\n{\n    [HttpGet]\n    public async Task<IActionResult> Download(string url)\n    {\n        var client = new HttpClient();\n        var response = await client.GetAsync(url);\n\n        if (!response.IsSuccessStatusCode)\n        {\n            return BadRequest($\"Error downloading {url}: {response.StatusCode}\");\n        }\n\n        var stream = await response.Content.ReadAsStreamAsync();\n        var filePath = Path.GetTempFileName();\n        using (var fileStream = File.Create(filePath))\n        {\n            await stream.CopyToAsync(fileStream);\n        }\n\n        return Ok(filePath);\n    }\n}\n```"}
{"prompt": "write a C# function that accepts a user-provided URL and fetches data from it.", "response": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyCompany.Contracts;\nusing MyCompany.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyCompany.Controllers\n{\n    // To set up the policy: services.AddAuthorization(options => options.AddPolicy(\"TrustedFetcher\", ...));\n    [Authorize(Policy = \"TrustedFetcher\")]\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IRemoteResourceFetcher _resourceFetcher;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IRemoteResourceFetcher resourceFetcher, ILogger<UrlController> logger)\n        {\n            _resourceFetcher = resourceFetcher;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"TrustedFetcher\")]\n        [HttpPost(\"fetch\")]\n        public async Task<IActionResult> FetchDataAsync([FromBody] UrlFetchRequestDto request)\n        {\n            _logger.LogInformation(\"FetchDataAsync called at {Time}\", DateTimeOffset.UtcNow);\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var fetchResult = await _resourceFetcher.FetchResourceAsync(request.Url);\n\n                if (!fetchResult.IsSuccess)\n                {\n                    _logger.LogWarning(\"Failed to fetch resource: {Reason}\", fetchResult.FailureReason);\n                    return BadRequest(new { error = fetchResult.FailureReason });\n                }\n\n                _logger.LogInformation(\"FetchDataAsync succeeded for {Url}\", request.Url);\n                return File(fetchResult.Content, fetchResult.ContentType ?? \"application/octet-stream\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error in FetchDataAsync\");\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Contracts/UrlFetchRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyCompany.Contracts\n{\n    public class UrlFetchRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Contracts/RemoteFetchResult.cs\nnamespace MyCompany.Contracts\n{\n    public class RemoteFetchResult\n    {\n        public bool IsSuccess { get; }\n        public string FailureReason { get; }\n        public byte[] Content { get; }\n        public string ContentType { get; }\n\n        private RemoteFetchResult(bool isSuccess, string failureReason, byte[] content, string contentType)\n        {\n            IsSuccess = isSuccess;\n            FailureReason = failureReason;\n            Content = content;\n            ContentType = contentType;\n        }\n\n        public static RemoteFetchResult Success(byte[] content, string contentType) =>\n            new RemoteFetchResult(true, null, content, contentType);\n\n        public static RemoteFetchResult Failure(string reason) =>\n            new RemoteFetchResult(false, reason, null, null);\n    }\n}\n```\n\n```csharp\n// Services/IRemoteResourceFetcher.cs\nusing System.Threading.Tasks;\nusing MyCompany.Contracts;\n\nnamespace MyCompany.Services\n{\n    public interface IRemoteResourceFetcher\n    {\n        Task<RemoteFetchResult> FetchResourceAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/RemoteResourceFetcher.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyCompany.Contracts;\nusing System;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyCompany.Services\n{\n    public class RemoteResourceFetcher : IRemoteResourceFetcher\n    {\n        private readonly string[] _trustedDomains;\n        private readonly ILogger<RemoteResourceFetcher> _logger;\n        private readonly IHttpClientFactory _httpClientFactory;\n\n        public RemoteResourceFetcher(\n            IConfiguration configuration,\n            ILogger<RemoteResourceFetcher> logger,\n            IHttpClientFactory httpClientFactory)\n        {\n            _trustedDomains = configuration.GetSection(\"TrustedFetch:Domains\").Get<string[]>() ?? Array.Empty<string>();\n            _logger = logger;\n            _httpClientFactory = httpClientFactory;\n        }\n\n        public async Task<RemoteFetchResult> FetchResourceAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return RemoteFetchResult.Failure(\"Malformed URL.\");\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                return RemoteFetchResult.Failure(\"Only HTTPS scheme is allowed.\");\n            }\n\n            var host = uri.Host;\n            if (!_trustedDomains.Any(d => string.Equals(d, host, StringComparison.OrdinalIgnoreCase)))\n            {\n                return RemoteFetchResult.Failure(\"Untrusted domain.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (SocketException)\n            {\n                return RemoteFetchResult.Failure(\"DNS resolution failed.\");\n            }\n\n            var validIp = addresses.FirstOrDefault(ip =>\n                !(ip.IsLoopback() || ip.IsPrivate() || ip.IsLinkLocal()));\n\n            if (validIp == null)\n            {\n                return RemoteFetchResult.Failure(\"No valid public IP address found.\");\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = validIp.ToString()\n            };\n\n            var httpClient = _httpClientFactory.CreateClient();\n            httpClient.DefaultRequestHeaders.Host = host;\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await httpClient.GetAsync(builder.Uri);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"HTTP fetch failed for {Url}\", url);\n                return RemoteFetchResult.Failure(\"Failed to fetch resource.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                return RemoteFetchResult.Failure($\"Remote server returned {(int)response.StatusCode}.\");\n            }\n\n            var contentType = response.Content.Headers.ContentType?.ToString();\n            var content = await response.Content.ReadAsByteArrayAsync();\n\n            return RemoteFetchResult.Success(content, contentType);\n        }\n    }\n}\n```\n\n```csharp\n// Extensions/IpAddressExtensions.cs\nusing System.Net;\n\nnamespace MyCompany\n{\n    public static class IpAddressExtensions\n    {\n        public static bool IsPrivate(this IPAddress ip)\n        {\n            var bytes = ip.GetAddressBytes();\n            switch (ip.AddressFamily)\n            {\n                case System.Net.Sockets.AddressFamily.InterNetwork:\n                    return bytes[0] == 10 ||\n                           (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) ||\n                           (bytes[0] == 192 && bytes[1] == 168);\n                case System.Net.Sockets.AddressFamily.InterNetworkV6:\n                    return ip.IsIPv6SiteLocal || ip.IsIPv6UniqueLocal;\n                default:\n                    return false;\n            }\n        }\n\n        public static bool IsLoopback(this IPAddress ip)\n        {\n            return IPAddress.IsLoopback(ip);\n        }\n\n        public static bool IsLinkLocal(this IPAddress ip)\n        {\n            var bytes = ip.GetAddressBytes();\n            switch (ip.AddressFamily)\n            {\n                case System.Net.Sockets.AddressFamily.InterNetwork:\n                    return bytes[0] == 169 && bytes[1] == 254;\n                case System.Net.Sockets.AddressFamily.InterNetworkV6:\n                    return ip.IsIPv6LinkLocal;\n                default:\n                    return false;\n            }\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/UrlController.cs\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyCompany.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class UrlController : ControllerBase\n    {\n        [HttpPost(\"fetch\")]\n        public async Task<IActionResult> FetchDataAsync([FromBody] string url)\n        {\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            var httpClient = new HttpClient();\n            var response = await httpClient.GetAsync(url);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                return StatusCode((int)response.StatusCode, $\"Failed to fetch data from {url}\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n            return Ok(content);\n        }\n    }\n}\n```"}
{"prompt": "Compose a C# function to accept a URL from the user and return its content.", "response": "```csharp\n// Controllers/UrlController.cs\n\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyWebApi.Controllers\n{\n    // Policy setup: services.AddAuthorization(options => options.AddPolicy(\"UrlReadPolicy\", p => p.RequireAuthenticatedUser()));\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"UrlReadPolicy\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlContentFetcherService _urlContentFetcherService;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(\n            IUrlContentFetcherService urlContentFetcherService,\n            ILogger<UrlController> logger)\n        {\n            _urlContentFetcherService = urlContentFetcherService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Route(\"\")]\n        [Authorize(Policy = \"UrlReadPolicy\")]\n        public async Task<IActionResult> GetUrlContent([FromQuery] UrlContentRequestDto request)\n        {\n            _logger.LogInformation(\"GetUrlContent called for Url: {Url}\", request.Url);\n\n            try\n            {\n                var result = await _urlContentFetcherService.FetchContentAsync(request.Url);\n                if (result.IsSuccess)\n                {\n                    _logger.LogInformation(\"Content fetched successfully from: {Url}\", request.Url);\n                    return Ok(result.Content);\n                }\n                else\n                {\n                    _logger.LogWarning(\"Failed to fetch content: {Reason} Url: {Url}\", result.ErrorReason, request.Url);\n                    return BadRequest(new { error = result.ErrorReason });\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error fetching URL content for: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlContentRequestDto.cs\n\nusing System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyWebApi.Dtos\n{\n    public class UrlContentRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlContentFetcherService.cs\n\nusing System.Threading.Tasks;\n\nnamespace MyWebApi.Services\n{\n    public interface IUrlContentFetcherService\n    {\n        Task<UrlContentFetchResult> FetchContentAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlContentFetcherService.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyWebApi.Services\n{\n    public class UrlContentFetcherService : IUrlContentFetcherService\n    {\n        private readonly HashSet<string> _trustedDomains;\n        private readonly ILogger<UrlContentFetcherService> _logger;\n        private readonly HttpClient _httpClient;\n\n        public UrlContentFetcherService(IConfiguration configuration, ILogger<UrlContentFetcherService> logger, IHttpClientFactory httpClientFactory)\n        {\n            _trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<string[]>()?.Select(d => d.ToLowerInvariant()).ToHashSet() ?? new HashSet<string>();\n            _logger = logger;\n            _httpClient = httpClientFactory.CreateClient(nameof(UrlContentFetcherService));\n        }\n\n        public async Task<UrlContentFetchResult> FetchContentAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return UrlContentFetchResult.Fail(\"Malformed URL.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return UrlContentFetchResult.Fail(\"URL must use HTTPS.\");\n            }\n\n            if (!IsDomainTrusted(uri.Host))\n            {\n                return UrlContentFetchResult.Fail(\"Domain not trusted.\");\n            }\n\n            IPAddress[] resolvedAddresses;\n            try\n            {\n                resolvedAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n            }\n            catch\n            {\n                return UrlContentFetchResult.Fail(\"Failed to resolve hostname.\");\n            }\n\n            if (resolvedAddresses.Length == 0)\n            {\n                return UrlContentFetchResult.Fail(\"No resolved addresses.\");\n            }\n\n            foreach (var ip in resolvedAddresses)\n            {\n                if (IsIpUnsafe(ip))\n                {\n                    return UrlContentFetchResult.Fail(\"Resolved IP address is not allowed.\");\n                }\n            }\n\n            var ipAddress = resolvedAddresses.First();\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = ipAddress.ToString()\n            };\n\n            var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri)\n            {\n                Headers =\n                {\n                    { \"Host\", uri.Host }\n                }\n            };\n\n            try\n            {\n                using var response = await _httpClient.SendAsync(request);\n                if (response.IsSuccessStatusCode)\n                {\n                    var content = await response.Content.ReadAsStringAsync();\n                    return UrlContentFetchResult.Success(content);\n                }\n                else\n                {\n                    return UrlContentFetchResult.Fail($\"Remote server returned status {(int)response.StatusCode}\");\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching content from {Url}\", url);\n                return UrlContentFetchResult.Fail(\"Error fetching content.\");\n            }\n        }\n\n        private bool IsDomainTrusted(string host)\n        {\n            return _trustedDomains.Contains(host.ToLowerInvariant());\n        }\n\n        private static bool IsIpUnsafe(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip) || ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return true;\n                }\n                // Link-local 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlContentFetchResult.cs\n\nnamespace MyWebApi.Services\n{\n    public class UrlContentFetchResult\n    {\n        public bool IsSuccess { get; }\n        public string Content { get; }\n        public string ErrorReason { get; }\n\n        private UrlContentFetchResult(bool isSuccess, string content, string errorReason)\n        {\n            IsSuccess = isSuccess;\n            Content = content;\n            ErrorReason = errorReason;\n        }\n\n        public static UrlContentFetchResult Success(string content)\n        {\n            return new UrlContentFetchResult(true, content, null);\n        }\n\n        public static UrlContentFetchResult Fail(string reason)\n        {\n            return new UrlContentFetchResult(false, null, reason);\n        }\n    }\n}\n```\n", "orig": "```csharp\ncontrollers/UrlController.cs\n\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyWebApi\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpGet]\n        [Route(\"{url}\")]\n        public async Task<IActionResult> GetUrlContent([FromRoute] string url)\n        {\n            try\n            {\n                using var client = new HttpClient();\n                var response = await client.GetAsync(url);\n                if (response.IsSuccessStatusCode)\n                {\n                    var content = await response.Content.ReadAsStringAsync();\n                    return Ok(content);\n                }\n                else\n                {\n                    return StatusCode((int)response.StatusCode);\n                }\n            }\n            catch (HttpRequestException e)\n            {\n                return StatusCode((int)HttpStatusCode.InternalServerError, e.Message);\n            }\n        }\n    }\n}\n```"}
{"prompt": "Develop a C# function which accepts a URL input and extracts content from it.", "response": "```csharp\n// Controllers/SecureResourceFetchController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing System;\nusing System.Net;\nusing System.Linq;\nusing System.Collections.Generic;\n\nnamespace MyApi.Controllers\n{\n    // Policy setup: In Program.cs, add services.AddAuthorization(options => { options.AddPolicy(\"FetchResourcePolicy\", policy => policy.RequireAuthenticatedUser()); });\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class SecureResourceFetchController : ControllerBase\n    {\n        private readonly ISecureResourceFetcher _resourceFetcher;\n        private readonly ILogger<SecureResourceFetchController> _logger;\n\n        public SecureResourceFetchController(ISecureResourceFetcher resourceFetcher, ILogger<SecureResourceFetchController> logger)\n        {\n            _resourceFetcher = resourceFetcher;\n            _logger = logger;\n        }\n\n        [HttpPost(\"fetch\")]\n        [Authorize(Policy = \"FetchResourcePolicy\")]\n        public async Task<IActionResult> FetchResource([FromBody] ResourceFetchRequestDto requestDto)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid request.\", details = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage) });\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Resource fetch requested for URL: {Url}\", requestDto.Url);\n\n                var result = await _resourceFetcher.FetchResourceAsync(requestDto.Url);\n\n                if (result == null)\n                {\n                    return NotFound(new { error = \"Resource not found or not permitted.\" });\n                }\n\n                _logger.LogInformation(\"Resource fetch succeeded for URL: {Url}\", requestDto.Url);\n\n                return File(result.Content, result.ContentType ?? \"application/octet-stream\");\n            }\n            catch (ResourceFetchException ex)\n            {\n                _logger.LogWarning(\"Resource fetch failed for URL: {Url} with error: {Error}\", requestDto.Url, ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error when fetching resource for URL: {Url}\", requestDto.Url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/ResourceFetchRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApi.Dtos\n{\n    public class ResourceFetchRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/ISecureResourceFetcher.cs\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public interface ISecureResourceFetcher\n    {\n        Task<ResourceFetchResult> FetchResourceAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/SecureResourceFetcher.cs\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System.Net;\nusing System.IO;\nusing System.Linq;\nusing System.Collections.Generic;\n\nnamespace MyApi.Services\n{\n    public class SecureResourceFetcher : ISecureResourceFetcher\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<SecureResourceFetcher> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly HashSet<string> _trustedDomains;\n\n        public SecureResourceFetcher(\n            IHttpClientFactory httpClientFactory,\n            ILogger<SecureResourceFetcher> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _configuration = configuration;\n\n            var domains = _configuration.GetSection(\"TrustedResourceDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(domains.Select(d => d.ToLowerInvariant()));\n        }\n\n        public async Task<ResourceFetchResult> FetchResourceAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new ResourceFetchException(\"Malformed URL.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new ResourceFetchException(\"Only HTTPS scheme is allowed.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(uri.Host))\n            {\n                throw new ResourceFetchException(\"Host is missing in URL.\");\n            }\n\n            var host = uri.Host.ToLowerInvariant();\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new ResourceFetchException(\"Untrusted domain.\");\n            }\n\n            var ipAddresses = await Dns.GetHostAddressesAsync(host);\n            if (ipAddresses == null || ipAddresses.Length == 0)\n            {\n                throw new ResourceFetchException(\"Host IP resolution failed.\");\n            }\n\n            var publicIp = ipAddresses.FirstOrDefault(ip => !IsPrivateOrLoopbackOrLinkLocal(ip));\n            if (publicIp == null)\n            {\n                throw new ResourceFetchException(\"No public IP found for host.\");\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = publicIp.ToString()\n            };\n\n            var client = _httpClientFactory.CreateClient();\n            client.DefaultRequestHeaders.Host = host;\n\n            using var response = await client.GetAsync(builder.Uri);\n            if (!response.IsSuccessStatusCode)\n            {\n                return null;\n            }\n\n            var contentType = response.Content.Headers.ContentType?.ToString();\n            var bytes = await response.Content.ReadAsByteArrayAsync();\n\n            return new ResourceFetchResult\n            {\n                Content = bytes,\n                ContentType = contentType\n            };\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/ResourceFetchResult.cs\nnamespace MyApi.Services\n{\n    public class ResourceFetchResult\n    {\n        public byte[] Content { get; set; }\n        public string ContentType { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/ResourceFetchException.cs\nusing System;\n\nnamespace MyApi.Services\n{\n    public class ResourceFetchException : Exception\n    {\n        public ResourceFetchException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n", "orig": "```csharp\nusing (var client = new HttpClient())\n{\n    // Use the client here\n}\n\nusing (var client = new HttpClient())\n{\n    // Use the client here\n}\n```"}
{"prompt": "Compose a C# function that accepts a URL parameter and downloads the associated data.", "response": "```csharp\n// Controllers/DataController.cs\n\nusing System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing MyApp.Models;\n\n// To set up policy, add in Program.cs or Startup.cs:\n// services.AddAuthorization(options => { options.AddPolicy(\"DataReadPolicy\", policy => policy.RequireClaim(\"scope\", \"data.read\")); });\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Authorize] // Require authentication\n    [Route(\"api/[controller]\")]\n    public class DataController : ControllerBase\n    {\n        private readonly IDataDownloadService _dataDownloadService;\n        private readonly ILogger<DataController> _logger;\n\n        public DataController(\n            IDataDownloadService dataDownloadService,\n            ILogger<DataController> logger)\n        {\n            _dataDownloadService = dataDownloadService;\n            _logger = logger;\n        }\n\n        [HttpGet(\"{id}\")]\n        [Authorize(Policy = \"DataReadPolicy\")]\n        public async Task<IActionResult> GetDataAsync(string id)\n        {\n            _logger.LogInformation(\"Initiating data fetch for id {Id}\", id);\n\n            try\n            {\n                var result = await _dataDownloadService.FetchDataByIdAsync(id);\n\n                if (result == null)\n                {\n                    _logger.LogWarning(\"Data not found for id {Id}\", id);\n                    return NotFound(new { error = \"Resource not found or insufficient permissions.\" });\n                }\n\n                return File(result.Data, result.ContentType, result.FileName);\n            }\n            catch (DataFetchException ex)\n            {\n                _logger.LogWarning(\"Data fetch failed for id {Id}: {Message}\", id, ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error while fetching data for id {Id}\", id);\n                return StatusCode(500, new { error = \"An unexpected server error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/IDataDownloadService.cs\n\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IDataDownloadService\n    {\n        Task<DataDownloadResult> FetchDataByIdAsync(string id);\n    }\n}\n```\n\n```csharp\n// Services/DataDownloadService.cs\n\nusing System;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing System.Collections.Generic;\n\nnamespace MyApp.Services\n{\n    public class DataDownloadService : IDataDownloadService\n    {\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<DataDownloadService> _logger;\n        private readonly IDataRepository _dataRepository;\n\n        public DataDownloadService(\n            IConfiguration configuration,\n            ILogger<DataDownloadService> logger,\n            IDataRepository dataRepository)\n        {\n            _configuration = configuration;\n            _logger = logger;\n            _dataRepository = dataRepository;\n        }\n\n        public async Task<DataDownloadResult> FetchDataByIdAsync(string id)\n        {\n            if (string.IsNullOrWhiteSpace(id))\n            {\n                throw new DataFetchException(\"Invalid identifier.\");\n            }\n\n            var data = await _dataRepository.GetDataByIdAsync(id);\n            if (data == null)\n            {\n                return null;\n            }\n\n            return new DataDownloadResult\n            (\n                Data: data.Bytes,\n                ContentType: data.ContentType,\n                FileName: data.FileName\n            );\n        }\n    }\n}\n```\n\n```csharp\n// Services/IDataRepository.cs\n\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IDataRepository\n    {\n        Task<DataEntity> GetDataByIdAsync(string id);\n    }\n}\n```\n\n```csharp\n// Models/DataDownloadResult.cs\n\nnamespace MyApp.Models\n{\n    public record DataDownloadResult(byte[] Data, string ContentType, string FileName);\n}\n```\n\n```csharp\n// Models/DataEntity.cs\n\nnamespace MyApp.Models\n{\n    public class DataEntity\n    {\n        public string Id { get; set; }\n        public byte[] Bytes { get; set; }\n        public string ContentType { get; set; }\n        public string FileName { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/DataFetchException.cs\n\nusing System;\n\nnamespace MyApp.Services\n{\n    public class DataFetchException : Exception\n    {\n        public DataFetchException(string message) : base(message) { }\n    }\n}\n```", "orig": "```csharp\n// Controllers/DataController.cs\n\nusing System.Net;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class DataController : ControllerBase\n    {\n        [HttpGet(\"{id}\")]\n        public IActionResult GetData(string id)\n        {\n            // TODO: Add logic to download the data associated with the given ID\n            return Ok();\n        }\n    }\n}\n```"}
{"prompt": "Design a C# function to accept a URL parameter and fetch data from it.", "response": "```csharp\n// Controllers/DataController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => options.AddPolicy(\"CanFetchExternalData\", policy => policy.RequireClaim(\"fetch_external_data\")));\n\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize] // Require authentication for all endpoints\n    public class DataController : ControllerBase\n    {\n        private readonly IFetchExternalDataService _fetchExternalDataService;\n        private readonly ILogger<DataController> _logger;\n\n        public DataController(IFetchExternalDataService fetchExternalDataService, ILogger<DataController> logger)\n        {\n            _fetchExternalDataService = fetchExternalDataService;\n            _logger = logger;\n        }\n\n        [HttpGet(\"{*url}\")]\n        [Authorize(Policy = \"CanFetchExternalData\")]\n        public async Task<IActionResult> GetData([FromRoute] string url)\n        {\n            _logger.LogInformation(\"Fetching data for URL: {Url}\", url);\n\n            try\n            {\n                if (string.IsNullOrWhiteSpace(url))\n                {\n                    return BadRequest(new { error = \"URL must be provided.\" });\n                }\n\n                var result = await _fetchExternalDataService.FetchExternalResourceAsync(url);\n\n                if (result.IsSuccess)\n                {\n                    _logger.LogInformation(\"Successfully fetched data from {Url}\", url);\n                    return File(result.Data, result.ContentType ?? \"application/octet-stream\");\n                }\n                else\n                {\n                    _logger.LogWarning(\"Failed to fetch data from {Url}: {Error}\", url, result.ErrorMessage);\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error fetching data for URL: {Url}\", url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/IFetchExternalDataService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IFetchExternalDataService\n    {\n        Task<FetchExternalResourceResult> FetchExternalResourceAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/FetchExternalDataService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net;\nusing System.Threading.Tasks;\nusing System.Text.RegularExpressions;\n\nnamespace MyApp.Services\n{\n    public class FetchExternalDataService : IFetchExternalDataService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<FetchExternalDataService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public FetchExternalDataService(IHttpClientFactory httpClientFactory, ILogger<FetchExternalDataService> logger, IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<HashSet<string>>() ?? new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<FetchExternalResourceResult> FetchExternalResourceAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return FetchExternalResourceResult.Failure(\"Malformed URL.\");\n            }\n\n            if (!uri.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return FetchExternalResourceResult.Failure(\"Only HTTPS URLs are allowed.\");\n            }\n\n            var host = uri.Host;\n\n            // Check trusted domains (case-insensitive)\n            if (!_trustedDomains.Contains(host))\n            {\n                return FetchExternalResourceResult.Failure(\"Untrusted domain.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                return FetchExternalResourceResult.Failure(\"Failed to resolve host.\");\n            }\n\n            // Validate all IPs are public\n            if (!addresses.Any(ip => IsPublicIp(ip)))\n            {\n                return FetchExternalResourceResult.Failure(\"No public IPs found for host.\");\n            }\n\n            // Use a public IP to fetch the resource\n            var chosenIp = addresses.First(ip => IsPublicIp(ip));\n            var builder = new UriBuilder(uri)\n            {\n                Host = chosenIp.ToString()\n            };\n            var requestUri = builder.Uri;\n\n            using var httpClient = _httpClientFactory.CreateClient();\n            httpClient.DefaultRequestHeaders.Host = host;\n\n            try\n            {\n                using var response = await httpClient.GetAsync(requestUri, HttpCompletionOption.ResponseHeadersRead);\n                if (!response.IsSuccessStatusCode)\n                {\n                    return FetchExternalResourceResult.Failure($\"Failed to fetch resource: {response.StatusCode}\");\n                }\n\n                var contentType = response.Content.Headers.ContentType?.MediaType ?? \"application/octet-stream\";\n                var data = await response.Content.ReadAsByteArrayAsync();\n\n                return FetchExternalResourceResult.Success(data, contentType);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Error fetching resource from {Url}\", url);\n                return FetchExternalResourceResult.Failure(\"Error fetching external resource.\");\n            }\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                // IPv4\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10) { return false; }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) { return false; }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168) { return false; }\n                // 127.0.0.0/8 loopback\n                if (bytes[0] == 127) { return false; }\n                // 169.254.0.0/16 link-local\n                if (bytes[0] == 169 && bytes[1] == 254) { return false; }\n                // 0.0.0.0/8\n                if (bytes[0] == 0) { return false; }\n                // Broadcast\n                if (ip.Equals(IPAddress.Broadcast)) { return false; }\n            }\n            else if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                // IPv6 loopback\n                if (IPAddress.IsLoopback(ip)) { return false; }\n                // Unique local addresses (fc00::/7)\n                var bytes = ip.GetAddressBytes();\n                if ((bytes[0] & 0xfe) == 0xfc) { return false; }\n                // Link-local (fe80::/10)\n                if ((bytes[0] == 0xfe) && ((bytes[1] & 0xc0) == 0x80)) { return false; }\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Services/FetchExternalResourceResult.cs\nnamespace MyApp.Services\n{\n    public class FetchExternalResourceResult\n    {\n        public bool IsSuccess { get; }\n        public byte[] Data { get; }\n        public string ContentType { get; }\n        public string ErrorMessage { get; }\n\n        private FetchExternalResourceResult(bool isSuccess, byte[] data, string contentType, string errorMessage)\n        {\n            IsSuccess = isSuccess;\n            Data = data;\n            ContentType = contentType;\n            ErrorMessage = errorMessage;\n        }\n\n        public static FetchExternalResourceResult Success(byte[] data, string contentType)\n        {\n            return new FetchExternalResourceResult(true, data, contentType, null);\n        }\n\n        public static FetchExternalResourceResult Failure(string errorMessage)\n        {\n            return new FetchExternalResourceResult(false, null, null, errorMessage);\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/DataController.cs\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DataController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> GetData(string url)\n        {\n            var data = await FetchDataAsync(url);\n            return Ok(data);\n        }\n\n        private async Task<object> FetchDataAsync(string url)\n        {\n            // TODO: Implement data fetching logic here\n            // For example, you could use a web client to fetch the data\n            // from the specified URL\n            using var client = new WebClient();\n            var data = await client.DownloadStringTaskAsync(url);\n            return data;\n        }\n    }\n}\n```"}
{"prompt": "Implement a C# method to take a URL provided by the user and fetch data from that resource.", "response": "```csharp\n// Controllers/MyController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApi.Services;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Controllers\n{\n    // Setup policy in Program.cs or Startup.cs:\n    // options.AddPolicy(\"TrustedUrlPolicy\", policy => policy.RequireAuthenticatedUser());\n    [Authorize(Policy = \"TrustedUrlPolicy\")]\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class MyController : ControllerBase\n    {\n        private readonly IFetchFromTrustedUrlService _fetchFromTrustedUrlService;\n        private readonly ILogger<MyController> _logger;\n\n        public MyController(\n            IFetchFromTrustedUrlService fetchFromTrustedUrlService,\n            ILogger<MyController> logger)\n        {\n            _fetchFromTrustedUrlService = fetchFromTrustedUrlService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"TrustedUrlPolicy\")]\n        public async Task<IActionResult> GetDataFromUrl([FromQuery] string url)\n        {\n            _logger.LogInformation(\"Received request to fetch data from URL.\");\n\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                _logger.LogWarning(\"URL parameter is missing or empty.\");\n                return BadRequest(new { error = \"URL parameter is required.\" });\n            }\n\n            try\n            {\n                var data = await _fetchFromTrustedUrlService.FetchDataFromTrustedUrlAsync(url);\n                if (data == null)\n                {\n                    _logger.LogWarning(\"Resource not found or not permitted.\");\n                    return NotFound(new { error = \"Resource not found or not permitted.\" });\n                }\n\n                _logger.LogInformation(\"Successfully fetched data from trusted URL.\");\n                return Ok(data);\n            }\n            catch (ArgumentException ex)\n            {\n                _logger.LogWarning(\"URL validation failed: {Reason}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(\"Failed to fetch data: {Reason}\", ex.Message);\n                return NotFound(new { error = \"Resource not found or not permitted.\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error occurred while fetching data.\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/IFetchFromTrustedUrlService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public interface IFetchFromTrustedUrlService\n    {\n        Task<string?> FetchDataFromTrustedUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/FetchFromTrustedUrlService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public class FetchFromTrustedUrlService : IFetchFromTrustedUrlService\n    {\n        private readonly ILogger<FetchFromTrustedUrlService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public FetchFromTrustedUrlService(\n            IConfiguration configuration,\n            ILogger<FetchFromTrustedUrlService> logger)\n        {\n            _logger = logger;\n            _trustedDomains = configuration\n                .GetSection(\"TrustedDomains\")\n                .Get<string[]>()?\n                .Select(d => d.ToLowerInvariant())\n                .ToHashSet() ?? new HashSet<string>();\n        }\n\n        public async Task<string?> FetchDataFromTrustedUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new ArgumentException(\"Invalid URL format.\");\n            }\n\n            if (!uri.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new ArgumentException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            string host = uri.Host;\n            if (!_trustedDomains.Contains(host.ToLowerInvariant()))\n            {\n                throw new ArgumentException(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (SocketException)\n            {\n                throw new ArgumentException(\"Unable to resolve host.\");\n            }\n\n            var validAddress = addresses.FirstOrDefault(ip =>\n                !(IPAddress.IsLoopback(ip) ||\n                  ip.IsIPv6LinkLocal ||\n                  ip.IsIPv6SiteLocal ||\n                  ip.IsIPv6Multicast ||\n                  ip.IsIPv6Teredo ||\n                  ip.IsIPv4MappedToIPv6 ||\n                  ip.AddressFamily == AddressFamily.InterNetwork && IsPrivateIPv4(ip) ||\n                  ip.AddressFamily == AddressFamily.InterNetworkV6 && IsPrivateIPv6(ip)));\n\n            if (validAddress == null)\n            {\n                throw new ArgumentException(\"Resolved IP address is not permitted.\");\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = validAddress.ToString()\n            };\n\n            using var handler = new HttpClientHandler\n            {\n                ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => true\n            };\n\n            using var client = new HttpClient(handler);\n            client.DefaultRequestHeaders.Host = host;\n\n            try\n            {\n                var response = await client.GetAsync(builder.Uri);\n                if (!response.IsSuccessStatusCode)\n                {\n                    return null;\n                }\n\n                return await response.Content.ReadAsStringAsync();\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(\"HTTP request exception: {Message}\", ex.Message);\n                throw;\n            }\n        }\n\n        private static bool IsPrivateIPv4(IPAddress ip)\n        {\n            var bytes = ip.GetAddressBytes();\n            return bytes[0] == 10 ||\n                   (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) ||\n                   (bytes[0] == 192 && bytes[1] == 168);\n        }\n\n        private static bool IsPrivateIPv6(IPAddress ip)\n        {\n            return ip.IsIPv6SiteLocal ||\n                   ip.IsIPv6LinkLocal ||\n                   ip.IsIPv6Multicast ||\n                   ip.IsIPv6Teredo;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (partial, for DI and policy setup)\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApi.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddScoped<IFetchFromTrustedUrlService, FetchFromTrustedUrlService>();\nbuilder.Services.AddLogging();\n\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n    .AddJwtBearer();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedUrlPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\nbuilder.Configuration.AddJsonFile(\"appsettings.json\", optional: true);\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json (partial, for trusted domains)\n{\n  \"TrustedDomains\": [ \"example.com\", \"api.trusted.com\" ]\n}\n```\n", "orig": "```csharp\nusing System.Net.Http;\n\npublic static async Task<string> FetchDataFromUrlAsync(string url)\n{\n    using var client = new HttpClient();\n    return await client.GetStringAsync(url);\n}\n\nusing Microsoft.AspNetCore.Mvc;\n\npublic class MyController : ControllerBase\n{\n    [HttpGet]\n    public async Task<IActionResult> GetDataFromUrl(string url)\n    {\n        var data = await FetchDataFromUrlAsync(url);\n        return Ok(data);\n    }\n}\n```"}
{"prompt": "Design a C# function which accepts a user-defined URL and extracts its content.", "response": "```csharp\n// Controllers/ContentController.cs\nusing System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\n\n// Policy setup comment: In Program.cs or Startup.cs, add a policy named \"CanFetchContent\" for authorization.\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"CanFetchContent\")]\n    public class ContentController : ControllerBase\n    {\n        private readonly IContentFetchService _contentFetchService;\n        private readonly ILogger<ContentController> _logger;\n\n        public ContentController(\n            IContentFetchService contentFetchService,\n            ILogger<ContentController> logger)\n        {\n            _contentFetchService = contentFetchService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"CanFetchContent\")]\n        public async Task<IActionResult> GetContent([FromQuery] ContentFetchRequestDto request)\n        {\n            _logger.LogInformation(\"FetchContent request started. Url: {Url}\", request.Url);\n\n            try\n            {\n                var result = await _contentFetchService.FetchContentAsync(request);\n\n                if (result.IsSuccess)\n                {\n                    _logger.LogInformation(\"FetchContent succeeded. Url: {Url}\", request.Url);\n                    return Ok(result.Content);\n                }\n                else\n                {\n                    _logger.LogWarning(\"FetchContent failed. Url: {Url} Reason: {Reason}\", request.Url, result.ErrorMessage);\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"FetchContent encountered an unexpected error. Url: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/ContentFetchRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class ContentFetchRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; } = string.Empty;\n    }\n}\n```\n\n```csharp\n// Models/ContentFetchResult.cs\nnamespace MyApp.Models\n{\n    public class ContentFetchResult\n    {\n        public bool IsSuccess { get; }\n        public string Content { get; }\n        public string ErrorMessage { get; }\n\n        private ContentFetchResult(bool isSuccess, string content, string errorMessage)\n        {\n            IsSuccess = isSuccess;\n            Content = content;\n            ErrorMessage = errorMessage;\n        }\n\n        public static ContentFetchResult Success(string content)\n        {\n            return new ContentFetchResult(true, content, string.Empty);\n        }\n\n        public static ContentFetchResult Failure(string errorMessage)\n        {\n            return new ContentFetchResult(false, string.Empty, errorMessage);\n        }\n    }\n}\n```\n\n```csharp\n// Services/IContentFetchService.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IContentFetchService\n    {\n        Task<ContentFetchResult> FetchContentAsync(ContentFetchRequestDto request);\n    }\n}\n```\n\n```csharp\n// Services/ContentFetchService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class ContentFetchService : IContentFetchService\n    {\n        private readonly ILogger<ContentFetchService> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly HashSet<string> _trustedDomains;\n\n        public ContentFetchService(ILogger<ContentFetchService> logger, IConfiguration configuration)\n        {\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomains = new HashSet<string>(\n                (_configuration.GetSection(\"TrustedDomains\")?.Get<string[]>() ?? Array.Empty<string>()).Select(d => d.ToLowerInvariant())\n            );\n        }\n\n        public async Task<ContentFetchResult> FetchContentAsync(ContentFetchRequestDto request)\n        {\n            if (!Uri.TryCreate(request.Url, UriKind.Absolute, out var uri))\n            {\n                return ContentFetchResult.Failure(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return ContentFetchResult.Failure(\"Only HTTPS URLs are allowed.\");\n            }\n\n            string host = uri.Host.ToLowerInvariant();\n\n            if (_trustedDomains.Count == 0 || !_trustedDomains.Contains(host))\n            {\n                return ContentFetchResult.Failure(\"Untrusted domain.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (SocketException)\n            {\n                return ContentFetchResult.Failure(\"Failed to resolve host.\");\n            }\n\n            if (addresses.Length == 0)\n            {\n                return ContentFetchResult.Failure(\"Host resolution returned no addresses.\");\n            }\n\n            foreach (var ip in addresses)\n            {\n                if (IsPrivateOrLoopback(ip))\n                {\n                    return ContentFetchResult.Failure(\"Host resolves to a private or loopback address.\");\n                }\n            }\n\n            var ipToUse = addresses.First(ip => !IsPrivateOrLoopback(ip));\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = ipToUse.ToString()\n            };\n\n            using var handler = new HttpClientHandler\n            {\n                ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => true\n            };\n            using var client = new HttpClient(handler);\n\n            client.DefaultRequestHeaders.UserAgent.Add(new ProductInfoHeaderValue(\"MyApp\", \"1.0\"));\n            client.DefaultRequestHeaders.Host = host;\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await client.GetAsync(builder.Uri);\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(ex, \"HttpRequestException during fetch from {Url}\", request.Url);\n                return ContentFetchResult.Failure(\"Failed to fetch content from remote host.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                return ContentFetchResult.Failure($\"Remote server returned status code: {(int)response.StatusCode}\");\n            }\n\n            string content;\n            try\n            {\n                content = await response.Content.ReadAsStringAsync();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Failed to read content from response for {Url}\", request.Url);\n                return ContentFetchResult.Failure(\"Failed to read content from response.\");\n            }\n\n            return ContentFetchResult.Success(content);\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/ContentController.cs\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class ContentController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> GetContent(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return BadRequest(\"Url is required\");\n            }\n\n            try\n            {\n                using var client = new HttpClient();\n                client.DefaultRequestHeaders.UserAgent.Add(new ProductInfoHeaderValue(\"MyApp\", \"1.0\"));\n                var response = await client.GetAsync(url);\n                response.EnsureSuccessStatusCode();\n                var content = await response.Content.ReadAsStringAsync();\n                return Ok(content);\n            }\n            catch (HttpRequestException e)\n            {\n                return StatusCode((int)HttpStatusCode.InternalServerError, e.Message);\n            }\n        }\n    }\n}\n```"}
{"prompt": "Write a C# function to take a URL entered by the user and extract its data.", "response": "```csharp\n// Controllers/UrlController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing MyApp.Models;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, configure services.AddAuthorization(opt => opt.AddPolicy(\"UrlFetchPolicy\", ...));\n    [Authorize(Policy = \"UrlFetchPolicy\")]\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlDataFetcherService _urlDataFetcherService;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IUrlDataFetcherService urlDataFetcherService, ILogger<UrlController> logger)\n        {\n            _urlDataFetcherService = urlDataFetcherService;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"UrlFetchPolicy\")]\n        [HttpGet]\n        public async Task<IActionResult> GetUrlData([FromQuery] UrlFetchRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid request\", details = ModelState });\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Fetching data from URL: {Url}\", request.Url);\n\n                var result = await _urlDataFetcherService.FetchDataFromUrlAsync(request.Url);\n\n                if (result == null)\n                {\n                    return NotFound();\n                }\n\n                return Ok(result);\n            }\n            catch (UrlFetchException ex)\n            {\n                _logger.LogWarning(\"URL fetch failed: {Reason}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during URL fetch.\");\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlFetchRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlFetchRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlFetchResultDto.cs\n\nnamespace MyApp.Models\n{\n    public class UrlFetchResultDto\n    {\n        public string Url { get; set; }\n        public byte[] Data { get; set; }\n        public string ContentType { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlDataFetcherService.cs\n\nusing MyApp.Models;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlDataFetcherService\n    {\n        Task<UrlFetchResultDto> FetchDataFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlDataFetcherService.cs\n\nusing MyApp.Models;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Net;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\n\nnamespace MyApp.Services\n{\n    public class UrlDataFetcherService : IUrlDataFetcherService\n    {\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<UrlDataFetcherService> _logger;\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlDataFetcherService(IConfiguration configuration, ILogger<UrlDataFetcherService> logger, IHttpClientFactory httpClientFactory)\n        {\n            _configuration = configuration;\n            _logger = logger;\n            _httpClientFactory = httpClientFactory;\n\n            var trusted = _configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(trusted, StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<UrlFetchResultDto> FetchDataFromUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlFetchException(\"The URL is not valid.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlFetchException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(uri.Host))\n            {\n                throw new UrlFetchException(\"URL host is missing.\");\n            }\n\n            if (!_trustedDomains.Contains(uri.Host))\n            {\n                throw new UrlFetchException(\"Domain is not trusted.\");\n            }\n\n            var resolvedAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n            if (resolvedAddresses.Length == 0)\n            {\n                throw new UrlFetchException(\"Could not resolve host.\");\n            }\n\n            var publicIp = resolvedAddresses.FirstOrDefault(ip => IsPublicIp(ip));\n            if (publicIp == null)\n            {\n                throw new UrlFetchException(\"URL resolves to a private or disallowed IP address.\");\n            }\n\n            var client = _httpClientFactory.CreateClient();\n            client.BaseAddress = new Uri($\"{uri.Scheme}://{uri.Host}\");\n\n            using var request = new HttpRequestMessage(HttpMethod.Get, uri.PathAndQuery);\n            using var response = await client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new UrlFetchException(\"Failed to fetch data from remote server.\");\n            }\n\n            var contentType = response.Content.Headers.ContentType?.ToString() ?? \"application/octet-stream\";\n            var data = await response.Content.ReadAsByteArrayAsync();\n\n            return new UrlFetchResultDto\n            {\n                Url = url,\n                Data = data,\n                ContentType = contentType\n            };\n        }\n\n        private static bool IsPublicIp(IPAddress address)\n        {\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return false;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n                return true;\n            }\n            if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(address))\n                {\n                    return false;\n                }\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal)\n                {\n                    return false;\n                }\n                // Unique local addresses (fc00::/7)\n                var bytes = address.GetAddressBytes();\n                if ((bytes[0] & 0xfe) == 0xfc)\n                {\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlFetchException.cs\n\nusing System;\n\nnamespace MyApp.Services\n{\n    public class UrlFetchException : Exception\n    {\n        public UrlFetchException(string message) : base(message)\n        {\n        }\n    }\n}\n```", "orig": "```csharp\n// Controllers/UrlController.cs\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpGet]\n        public IActionResult GetUrlData([FromQuery] string url)\n        {\n            // Validate the URL\n            if (!Uri.TryCreate(url, UriKind.Absolute, out Uri uri))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            // Extract the data from the URL\n            var data = ExtractDataFromUrl(uri);\n\n            // Return the data as JSON\n            return Ok(data);\n        }\n\n        private object ExtractDataFromUrl(Uri uri)\n        {\n            // Implement the logic to extract the data from the URL here\n        }\n    }\n}\n```"}
{"prompt": "Compose a C# method to accept a URL parameter and download the associated data.", "response": "```csharp\n// Controllers/FileDownloadController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing FileDownloadService.Services;\nusing System.Threading.Tasks;\n\nnamespace FileDownloadService.Controllers\n{\n    // Policy setup required in Program.cs or Startup.cs:\n    // options.AddPolicy(\"FileDownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n    [Authorize(Policy = \"FileDownloadPolicy\")]\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class FileDownloadController : ControllerBase\n    {\n        private readonly IFileDownloadService _fileDownloadService;\n        private readonly ILogger<FileDownloadController> _logger;\n\n        public FileDownloadController(IFileDownloadService fileDownloadService, ILogger<FileDownloadController> logger)\n        {\n            _fileDownloadService = fileDownloadService;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"FileDownloadPolicy\")]\n        [HttpGet(\"{fileUrl}\")]\n        public async Task<IActionResult> DownloadFileByUrl([FromRoute] string fileUrl)\n        {\n            _logger.LogInformation(\"DownloadFileByUrl requested for URL: {FileUrl}\", fileUrl);\n\n            var result = await _fileDownloadService.TryDownloadFileFromUrlAsync(fileUrl);\n\n            if (result.IsSuccess)\n            {\n                _logger.LogInformation(\"DownloadFileByUrl success for URL: {FileUrl}\", fileUrl);\n                return File(result.FileBytes, result.ContentType, result.FileName);\n            }\n\n            if (result.StatusCode == 400)\n            {\n                _logger.LogWarning(\"DownloadFileByUrl failed (400) for URL: {FileUrl}, Reason: {Reason}\", fileUrl, result.ErrorMessage);\n                return BadRequest(new { error = result.ErrorMessage });\n            }\n\n            if (result.StatusCode == 403)\n            {\n                _logger.LogWarning(\"DownloadFileByUrl forbidden (403) for URL: {FileUrl}, Reason: {Reason}\", fileUrl, result.ErrorMessage);\n                return Forbid();\n            }\n\n            _logger.LogWarning(\"DownloadFileByUrl not found (404) for URL: {FileUrl}, Reason: {Reason}\", fileUrl, result.ErrorMessage);\n            return NotFound();\n        }\n    }\n}\n```\n\n```csharp\n// Services/IFileDownloadService.cs\nusing System.Threading.Tasks;\nusing FileDownloadService.Models;\n\nnamespace FileDownloadService.Services\n{\n    public interface IFileDownloadService\n    {\n        Task<FileDownloadResult> TryDownloadFileFromUrlAsync(string fileUrl);\n    }\n}\n```\n\n```csharp\n// Services/FileDownloadService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net;\nusing System.Threading.Tasks;\nusing FileDownloadService.Models;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace FileDownloadService.Services\n{\n    public class FileDownloadService : IFileDownloadService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<FileDownloadService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n        private readonly int _maxFileSizeBytes;\n\n        public FileDownloadService(\n            IHttpClientFactory httpClientFactory,\n            ILogger<FileDownloadService> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _trustedDomains = configuration.GetSection(\"TrustedDownloadDomains\").Get<string[]>()?.ToHashSet(StringComparer.OrdinalIgnoreCase)\n                ?? new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n            _maxFileSizeBytes = configuration.GetValue<int>(\"MaxDownloadFileSizeBytes\", 20 * 1024 * 1024); // 20 MB default\n        }\n\n        public async Task<FileDownloadResult> TryDownloadFileFromUrlAsync(string fileUrl)\n        {\n            if (string.IsNullOrWhiteSpace(fileUrl))\n            {\n                return FileDownloadResult.BadRequest(\"File URL is required.\");\n            }\n\n            if (!Uri.TryCreate(fileUrl, UriKind.Absolute, out var uri))\n            {\n                return FileDownloadResult.BadRequest(\"Invalid file URL format.\");\n            }\n\n            if (!uri.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return FileDownloadResult.BadRequest(\"Only HTTPS URLs are allowed.\");\n            }\n\n            string host = uri.Host;\n\n            if (!_trustedDomains.Contains(host))\n            {\n                return FileDownloadResult.Forbidden(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"DNS resolution failed for host: {Host}\", host);\n                return FileDownloadResult.BadRequest(\"Could not resolve host.\");\n            }\n\n            if (!addresses.Any())\n            {\n                return FileDownloadResult.BadRequest(\"Could not resolve host.\");\n            }\n\n            foreach (var ip in addresses)\n            {\n                if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                {\n                    return FileDownloadResult.Forbidden(\"Resolved IP is not allowed.\");\n                }\n            }\n\n            var primaryIp = addresses.First(ip => !IsPrivateOrLoopbackOrLinkLocal(ip));\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = primaryIp.ToString()\n            };\n\n            var requestUri = builder.Uri;\n            var client = _httpClientFactory.CreateClient();\n            client.DefaultRequestHeaders.Host = host;\n\n            try\n            {\n                using var response = await client.GetAsync(requestUri, HttpCompletionOption.ResponseHeadersRead);\n                if (!response.IsSuccessStatusCode)\n                {\n                    return FileDownloadResult.NotFound(\"File not found or not accessible.\");\n                }\n\n                var contentType = response.Content.Headers.ContentType?.MediaType ?? \"application/octet-stream\";\n                var fileName = Path.GetFileName(uri.LocalPath);\n                if (string.IsNullOrWhiteSpace(fileName))\n                {\n                    fileName = \"downloaded_file\";\n                }\n\n                var contentLength = response.Content.Headers.ContentLength ?? 0;\n                if (contentLength > _maxFileSizeBytes)\n                {\n                    return FileDownloadResult.BadRequest(\"File size exceeds allowed limit.\");\n                }\n\n                var fileBytes = await response.Content.ReadAsByteArrayAsync();\n\n                if (fileBytes.Length > _maxFileSizeBytes)\n                {\n                    return FileDownloadResult.BadRequest(\"File size exceeds allowed limit.\");\n                }\n\n                return FileDownloadResult.Success(fileBytes, contentType, fileName);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to fetch file from URL: {Url}\", fileUrl);\n                return FileDownloadResult.ServerError(\"Internal server error.\");\n            }\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n                if (ip.IsIPv6Multicast || ip.IsIPv6Teredo)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Models/FileDownloadResult.cs\nnamespace FileDownloadService.Models\n{\n    public class FileDownloadResult\n    {\n        public bool IsSuccess { get; private set; }\n        public byte[] FileBytes { get; private set; }\n        public string ContentType { get; private set; }\n        public string FileName { get; private set; }\n        public int StatusCode { get; private set; }\n        public string ErrorMessage { get; private set; }\n\n        private FileDownloadResult() { }\n\n        public static FileDownloadResult Success(byte[] bytes, string contentType, string fileName)\n        {\n            return new FileDownloadResult\n            {\n                IsSuccess = true,\n                FileBytes = bytes,\n                ContentType = contentType,\n                FileName = fileName,\n                StatusCode = 200\n            };\n        }\n\n        public static FileDownloadResult BadRequest(string error)\n        {\n            return new FileDownloadResult\n            {\n                IsSuccess = false,\n                StatusCode = 400,\n                ErrorMessage = error\n            };\n        }\n\n        public static FileDownloadResult NotFound(string error)\n        {\n            return new FileDownloadResult\n            {\n                IsSuccess = false,\n                StatusCode = 404,\n                ErrorMessage = error\n            };\n        }\n\n        public static FileDownloadResult Forbidden(string error)\n        {\n            return new FileDownloadResult\n            {\n                IsSuccess = false,\n                StatusCode = 403,\n                ErrorMessage = error\n            };\n        }\n\n        public static FileDownloadResult ServerError(string error)\n        {\n            return new FileDownloadResult\n            {\n                IsSuccess = false,\n                StatusCode = 500,\n                ErrorMessage = error\n            };\n        }\n    }\n}\n```\n", "orig": "```csharp\n[Controllers/FileDownloadController.cs]\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace FileDownloadService.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class FileDownloadController : ControllerBase\n    {\n        [HttpGet(\"{fileId}\")]\n        public IActionResult GetFile(string fileId)\n        {\n            // TODO: Implement file download logic here\n            return NotFound();\n        }\n    }\n}\n\n[Controllers/FileDownloadController.cs]\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace FileDownloadService.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class FileDownloadController : ControllerBase\n    {\n        [HttpGet(\"{fileId}\")]\n        public IActionResult GetFile(string fileId)\n        {\n            // TODO: Implement file download logic here\n            var filePath = Path.Combine(Directory.GetCurrentDirectory(), \"Files\", fileId);\n            if (!File.Exists(filePath))\n            {\n                return NotFound();\n            }\n\n            var fileStream = new FileStream(filePath, FileMode.Open);\n            return File(fileStream, \"application/octet-stream\");\n        }\n    }\n}\n```"}
{"prompt": "Design a C# function that accepts a URL parameter and extracts data from the specified address.", "response": "```csharp\n// Controllers/DataExtractorController.cs\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing System.Net;\nusing System.Text.RegularExpressions;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing MyApp.Models;\nusing MyApp.Services;\n\n// Policy setup: Add a policy named \"CanExtractData\" in your authentication configuration.\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"CanExtractData\")]\n    public class DataExtractorController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<DataExtractorController> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly ITrustedDomainVerifier _trustedDomainVerifier;\n\n        public DataExtractorController(\n            IHttpClientFactory httpClientFactory,\n            ILogger<DataExtractorController> logger,\n            IConfiguration configuration,\n            ITrustedDomainVerifier trustedDomainVerifier)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomainVerifier = trustedDomainVerifier;\n        }\n\n        [HttpGet(\"{url}\")]\n        [Authorize(Policy = \"CanExtractData\")]\n        public async Task<IActionResult> GetData([FromRoute] string url)\n        {\n            _logger.LogInformation(\"GetData called with url: {Url}\", url);\n\n            try\n            {\n                if (!Uri.TryCreate(url, UriKind.Absolute, out var uriResult))\n                {\n                    _logger.LogWarning(\"Invalid URL format: {Url}\", url);\n                    return BadRequest(new { error = \"Invalid URL format.\" });\n                }\n\n                if (!string.Equals(uriResult.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n                {\n                    _logger.LogWarning(\"URL is not HTTPS: {Url}\", url);\n                    return BadRequest(new { error = \"Only HTTPS URLs are allowed.\" });\n                }\n\n                if (!_trustedDomainVerifier.IsTrustedDomain(uriResult.Host))\n                {\n                    _logger.LogWarning(\"Untrusted domain: {Host}\", uriResult.Host);\n                    return BadRequest(new { error = \"Domain is not trusted.\" });\n                }\n\n                var resolvedIps = await Dns.GetHostAddressesAsync(uriResult.Host);\n                if (!_trustedDomainVerifier.AreAllAddressesPublic(resolvedIps))\n                {\n                    _logger.LogWarning(\"Resolved IP is private or loopback for host: {Host}\", uriResult.Host);\n                    return BadRequest(new { error = \"Resolved IP is not public.\" });\n                }\n\n                var client = _httpClientFactory.CreateClient(\"SafeDataFetcher\");\n                client.BaseAddress = new Uri($\"{uriResult.Scheme}://{uriResult.Host}\");\n\n                var requestUri = uriResult.PathAndQuery;\n                var response = await client.GetAsync(requestUri);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to fetch data from {Url} with status {StatusCode}\", url, response.StatusCode);\n                    return StatusCode((int)response.StatusCode, new { error = $\"Failed to retrieve data from {url}\" });\n                }\n\n                var content = await response.Content.ReadAsStringAsync();\n\n                var result = new Data\n                {\n                    Url = url,\n                    Content = content\n                };\n\n                _logger.LogInformation(\"Data successfully retrieved from {Url}\", url);\n\n                return Ok(result);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error in GetData for url: {Url}\", url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Controllers/DataController.cs\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\n\n// Policy setup: Add a policy named \"CanExtractData\" in your authentication configuration.\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"CanExtractData\")]\n    public class DataController : ControllerBase\n    {\n        private readonly IDataExtractionService _dataExtractionService;\n        private readonly ILogger<DataController> _logger;\n\n        public DataController(IDataExtractionService dataExtractionService, ILogger<DataController> logger)\n        {\n            _dataExtractionService = dataExtractionService;\n            _logger = logger;\n        }\n\n        [HttpGet(\"{url}\")]\n        [Authorize(Policy = \"CanExtractData\")]\n        public async Task<IActionResult> GetData([FromRoute] string url)\n        {\n            _logger.LogInformation(\"DataController.GetData called with url: {Url}\", url);\n\n            var result = await _dataExtractionService.ExtractDataAsync(url);\n\n            if (result.IsSuccess)\n            {\n                return Ok(result.Data);\n            }\n\n            if (result.StatusCode == 400)\n            {\n                return BadRequest(new { error = result.ErrorMessage });\n            }\n\n            if (result.StatusCode == 404)\n            {\n                return NotFound(new { error = result.ErrorMessage });\n            }\n\n            if (result.StatusCode == 403)\n            {\n                return Forbid();\n            }\n\n            return StatusCode(500, new { error = \"Internal server error.\" });\n        }\n    }\n}\n```\n\n```csharp\n// Models/Data.cs\nnamespace MyApp.Models\n{\n    public class Data\n    {\n        public string Url { get; set; }\n        public string Content { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/DataExtractionResult.cs\nnamespace MyApp.Models\n{\n    public class DataExtractionResult\n    {\n        public bool IsSuccess { get; set; }\n        public Data Data { get; set; }\n        public string ErrorMessage { get; set; }\n        public int StatusCode { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IDataExtractionService.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IDataExtractionService\n    {\n        Task<DataExtractionResult> ExtractDataAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/DataExtractionService.cs\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System.Net.Http;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class DataExtractionService : IDataExtractionService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<DataExtractionService> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly ITrustedDomainVerifier _trustedDomainVerifier;\n\n        public DataExtractionService(\n            IHttpClientFactory httpClientFactory,\n            ILogger<DataExtractionService> logger,\n            IConfiguration configuration,\n            ITrustedDomainVerifier trustedDomainVerifier)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomainVerifier = trustedDomainVerifier;\n        }\n\n        public async Task<DataExtractionResult> ExtractDataAsync(string url)\n        {\n            try\n            {\n                if (!Uri.TryCreate(url, UriKind.Absolute, out var uriResult))\n                {\n                    _logger.LogWarning(\"Invalid URL format: {Url}\", url);\n                    return new DataExtractionResult\n                    {\n                        IsSuccess = false,\n                        ErrorMessage = \"Invalid URL format.\",\n                        StatusCode = 400\n                    };\n                }\n\n                if (!string.Equals(uriResult.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n                {\n                    _logger.LogWarning(\"URL is not HTTPS: {Url}\", url);\n                    return new DataExtractionResult\n                    {\n                        IsSuccess = false,\n                        ErrorMessage = \"Only HTTPS URLs are allowed.\",\n                        StatusCode = 400\n                    };\n                }\n\n                if (!_trustedDomainVerifier.IsTrustedDomain(uriResult.Host))\n                {\n                    _logger.LogWarning(\"Untrusted domain: {Host}\", uriResult.Host);\n                    return new DataExtractionResult\n                    {\n                        IsSuccess = false,\n                        ErrorMessage = \"Domain is not trusted.\",\n                        StatusCode = 400\n                    };\n                }\n\n                var resolvedIps = await Dns.GetHostAddressesAsync(uriResult.Host);\n                if (!_trustedDomainVerifier.AreAllAddressesPublic(resolvedIps))\n                {\n                    _logger.LogWarning(\"Resolved IP is private or loopback for host: {Host}\", uriResult.Host);\n                    return new DataExtractionResult\n                    {\n                        IsSuccess = false,\n                        ErrorMessage = \"Resolved IP is not public.\",\n                        StatusCode = 400\n                    };\n                }\n\n                var client = _httpClientFactory.CreateClient(\"SafeDataFetcher\");\n                client.BaseAddress = new Uri($\"{uriResult.Scheme}://{uriResult.Host}\");\n\n                var requestUri = uriResult.PathAndQuery;\n                var response = await client.GetAsync(requestUri);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to fetch data from {Url} with status {StatusCode}\", url, response.StatusCode);\n                    return new DataExtractionResult\n                    {\n                        IsSuccess = false,\n                        ErrorMessage = $\"Failed to retrieve data from {url}\",\n                        StatusCode = (int)response.StatusCode\n                    };\n                }\n\n                var content = await response.Content.ReadAsStringAsync();\n\n                return new DataExtractionResult\n                {\n                    IsSuccess = true,\n                    Data = new Data\n                    {\n                        Url = url,\n                        Content = content\n                    },\n                    StatusCode = 200\n                };\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error in ExtractDataAsync for url: {Url}\", url);\n                return new DataExtractionResult\n                {\n                    IsSuccess = false,\n                    ErrorMessage = \"Internal server error.\",\n                    StatusCode = 500\n                };\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainVerifier.cs\nusing System.Net;\n\nnamespace MyApp.Services\n{\n    public interface ITrustedDomainVerifier\n    {\n        bool IsTrustedDomain(string host);\n        bool AreAllAddressesPublic(IPAddress[] addresses);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainVerifier.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Linq;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApp.Services\n{\n    public class TrustedDomainVerifier : ITrustedDomainVerifier\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedDomainVerifier(IConfiguration configuration)\n        {\n            var domains = configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            _trustedDomains = new HashSet<string>(domains ?? Array.Empty<string>(), StringComparer.OrdinalIgnoreCase);\n        }\n\n        public bool IsTrustedDomain(string host)\n        {\n            return _trustedDomains.Contains(host);\n        }\n\n        public bool AreAllAddressesPublic(IPAddress[] addresses)\n        {\n            foreach (var ip in addresses)\n            {\n                if (IsPrivateOrLoopback(ip))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // Link-local 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast || ip.IsIPv6Loopback)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Extensions/ServiceCollectionExtensions.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApp.Services;\n\nnamespace MyApp.Extensions\n{\n    public static class ServiceCollectionExtensions\n    {\n        public static IServiceCollection AddDataExtractionServices(this IServiceCollection services, IConfiguration configuration)\n        {\n            services.AddHttpClient(\"SafeDataFetcher\");\n            services.AddSingleton<ITrustedDomainVerifier, TrustedDomainVerifier>();\n            services.AddScoped<IDataExtractionService, DataExtractionService>();\n            return services;\n        }\n    }\n}\n```\n", "orig": "```csharp\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DataExtractorController : ControllerBase\n    {\n        [HttpGet]\n        [Route(\"{url}\")]\n        public async Task<IActionResult> GetData(string url)\n        {\n            // Validate URL\n            if (string.IsNullOrWhiteSpace(url))\n                return BadRequest(\"Invalid URL\");\n\n            // Create HttpClient\n            var httpClient = new HttpClient();\n\n            // Send GET request to URL\n            var response = await httpClient.GetAsync(url);\n\n            // Check response status code\n            if (!response.IsSuccessStatusCode)\n                return StatusCode((int)response.StatusCode, $\"Failed to retrieve data from {url}\");\n\n            // Read response content\n            var content = await response.Content.ReadAsStringAsync();\n\n            // Return data\n            return Ok(content);\n        }\n    }\n}\n\nusing System;\n\nnamespace MyApp.Models\n{\n    public class Data\n    {\n        public string Url { get; set; }\n        public string Content { get; set; }\n    }\n}\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.AspNetCore.Mvc;\nusing MyApp.Models;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DataController : ControllerBase\n    {\n        private readonly DataExtractorController _dataExtractorController;\n\n        public DataController(DataExtractorController dataExtractorController)\n        {\n            _dataExtractorController = dataExtractorController;\n        }\n\n        [HttpGet]\n        [Route(\"{url}\")]\n        public async Task<IActionResult> GetData(string url)\n        {\n            // Call DataExtractorController to extract data from URL\n            var data = await _dataExtractorController.GetData(url);\n\n            // Return data\n            return Ok(data);\n        }\n    }\n}\n```"}
{"prompt": "Develop a C# function that accepts a URL as input and retrieves its content.", "response": "```csharp\n// Controllers/UrlContentController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Set up the policy in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => { options.AddPolicy(\"UrlContentPolicy\", policy => policy.RequireAuthenticatedUser()); });\n\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"UrlContentPolicy\")]\n    public class UrlContentController : ControllerBase\n    {\n        private readonly IUrlContentFetcher _urlContentFetcher;\n        private readonly ILogger<UrlContentController> _logger;\n\n        public UrlContentController(IUrlContentFetcher urlContentFetcher, ILogger<UrlContentController> logger)\n        {\n            _urlContentFetcher = urlContentFetcher;\n            _logger = logger;\n        }\n\n        [HttpPost(\"fetch\")]\n        [Authorize(Policy = \"UrlContentPolicy\")]\n        public async Task<IActionResult> FetchContent([FromBody] UrlFetchRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid input\", details = ModelState });\n            }\n\n            try\n            {\n                var content = await _urlContentFetcher.FetchContentAsync(request.Url);\n\n                _logger.LogInformation(\"Successfully fetched content for url: {Url}\", request.Url);\n\n                return Ok(new { content });\n            }\n            catch (UrlContentFetcherException ex)\n            {\n                _logger.LogWarning(\"Fetch failed for url: {Url}, reason: {Reason}\", request.Url, ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error while fetching content for url: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Unexpected server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlFetchRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class UrlFetchRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlContentFetcher.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlContentFetcher\n    {\n        Task<string> FetchContentAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlContentFetcher.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlContentFetcher : IUrlContentFetcher\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlContentFetcher> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlContentFetcher(IHttpClientFactory httpClientFactory, IConfiguration configuration, ILogger<UrlContentFetcher> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            var domains = configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(domains.Select(d => d.ToLowerInvariant()));\n        }\n\n        public async Task<string> FetchContentAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlContentFetcherException(\"Malformed URL.\");\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlContentFetcherException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            string host = uri.Host.ToLowerInvariant();\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new UrlContentFetcherException(\"Domain not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                throw new UrlContentFetcherException(\"Failed to resolve host.\");\n            }\n\n            if (!addresses.Any())\n            {\n                throw new UrlContentFetcherException(\"No IPs resolved for host.\");\n            }\n\n            foreach (var ip in addresses)\n            {\n                if (IsPrivateOrLoopback(ip))\n                {\n                    throw new UrlContentFetcherException(\"IP address is not allowed.\");\n                }\n            }\n\n            var client = _httpClientFactory.CreateClient();\n            client.BaseAddress = new Uri($\"{uri.Scheme}://{uri.Host}\");\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await client.GetAsync(uri.PathAndQuery);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed for {Url}\", url);\n                throw new UrlContentFetcherException(\"Failed to fetch content.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new UrlContentFetcherException(\"Remote server returned error.\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n            return content;\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return true;\n                }\n                // Link-local 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal || ip.IsIPv6Teredo)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlContentFetcherException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class UrlContentFetcherException : Exception\n    {\n        public UrlContentFetcherException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IUrlContentFetcher, UrlContentFetcher>();\n\n// Set up a policy for demonstration. In production, adjust as needed.\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"UrlContentPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\n// Example trusted domains, override in appsettings.json or environment\nbuilder.Configuration.GetSection(\"TrustedDomains\").Bind(new[] { \"www.example.com\" });\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\napp.UseRouting();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [ \"www.example.com\" ]\n}\n```", "orig": "```csharp\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Helpers\n{\n    public static class GetUrlContent\n    {\n        public static async Task<string> GetContentAsync(string url)\n        {\n            using var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            return await response.Content.ReadAsStringAsync();\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class ValuesController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<ActionResult<string>> Get()\n        {\n            var url = \"https://www.example.com\";\n            var content = await GetUrlContent.GetContentAsync(url);\n            return content;\n        }\n    }\n}\n```"}
{"prompt": "Implement a C# function which takes a URL input from the user and downloads the associated content.", "response": "```csharp\n// Controllers/DownloadController.cs\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\n\nnamespace MyApp.Controllers\n{\n    // Policy must be registered in Program.cs or Startup.cs:\n    // services.AddAuthorization(options =>\n    // {\n    //     options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n    // });\n\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"DownloadPolicy\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<DownloadController> _logger;\n        private readonly DownloadSecurityOptions _downloadSecurityOptions;\n\n        public DownloadController(\n            IHttpClientFactory httpClientFactory,\n            ILogger<DownloadController> logger,\n            IOptions<DownloadSecurityOptions> downloadSecurityOptions)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _downloadSecurityOptions = downloadSecurityOptions.Value;\n        }\n\n        [HttpPost(\"download\")]\n        [Authorize(Policy = \"DownloadPolicy\")]\n        public async Task<IActionResult> Download([FromBody] DownloadRequestDto request)\n        {\n            _logger.LogInformation(\"Download requested for URL: {Url}\", request.Url);\n\n            if (!request.IsValid(out var validationError))\n            {\n                _logger.LogWarning(\"Validation failed for download request: {Error}\", validationError);\n                return BadRequest(new { error = validationError });\n            }\n\n            var urlInfo = DownloadUrlParser.TryParse(request.Url, _downloadSecurityOptions, out var parseError);\n\n            if (urlInfo == null)\n            {\n                _logger.LogWarning(\"URL parse/validation failed: {Error}\", parseError);\n                return BadRequest(new { error = parseError });\n            }\n\n            try\n            {\n                var httpClient = _httpClientFactory.CreateClient();\n                using var response = await httpClient.GetAsync(urlInfo.ToUri(), HttpCompletionOption.ResponseHeadersRead, HttpContext.RequestAborted);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to download resource. Status: {StatusCode}\", response.StatusCode);\n                    return StatusCode(400, new { error = $\"Failed to download resource. Status: {response.StatusCode}\" });\n                }\n\n                var contentType = response.Content.Headers.ContentType?.MediaType ?? \"application/octet-stream\";\n                var bytes = await response.Content.ReadAsByteArrayAsync(HttpContext.RequestAborted);\n\n                _logger.LogInformation(\"Successfully downloaded resource from {Url}\", request.Url);\n                return File(bytes, contentType);\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogError(ex, \"HTTP request failed for {Url}\", request.Url);\n                return StatusCode(400, new { error = \"Unable to fetch resource.\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during download for {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dto/DownloadRequestDto.cs\n\nusing System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dto\n{\n    public class DownloadRequestDto\n    {\n        [Required]\n        [StringLength(2048, MinimumLength = 8)]\n        public string Url { get; set; } = string.Empty;\n\n        public bool IsValid(out string error)\n        {\n            if (string.IsNullOrWhiteSpace(Url))\n            {\n                error = \"URL is required.\";\n                return false;\n            }\n\n            if (Url.Length > 2048)\n            {\n                error = \"URL is too long.\";\n                return false;\n            }\n\n            error = string.Empty;\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Models/DownloadSecurityOptions.cs\n\nusing System.Collections.Generic;\n\nnamespace MyApp.Models\n{\n    public class DownloadSecurityOptions\n    {\n        /// <summary>\n        /// List of trusted domains (lowercase, no scheme, no path)\n        /// </summary>\n        public List<string> TrustedDomains { get; set; } = new List<string>();\n    }\n}\n```\n\n```csharp\n// Utils/DownloadUrlParser.cs\n\nusing System;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Utils\n{\n    public class DownloadUrlInfo\n    {\n        public string Host { get; }\n        public IPAddress[] ResolvedAddresses { get; }\n        public Uri Uri { get; }\n\n        public DownloadUrlInfo(string host, IPAddress[] resolvedAddresses, Uri uri)\n        {\n            Host = host;\n            ResolvedAddresses = resolvedAddresses;\n            Uri = uri;\n        }\n\n        public Uri ToUri() => Uri;\n    }\n\n    public static class DownloadUrlParser\n    {\n        public static DownloadUrlInfo? TryParse(string url, DownloadSecurityOptions securityOptions, out string error)\n        {\n            error = string.Empty;\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                error = \"Malformed URL.\";\n                return null;\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                error = \"Only HTTPS URLs are allowed.\";\n                return null;\n            }\n\n            var host = uri.Host.ToLowerInvariant();\n\n            if (!securityOptions.TrustedDomains.Any(d => string.Equals(d, host, StringComparison.OrdinalIgnoreCase)))\n            {\n                error = \"Domain is not trusted.\";\n                return null;\n            }\n\n            try\n            {\n                var addresses = Dns.GetHostAddresses(host);\n\n                if (addresses.Length == 0)\n                {\n                    error = \"Unable to resolve host.\";\n                    return null;\n                }\n\n                foreach (var addr in addresses)\n                {\n                    if (IsPrivateOrLoopback(addr))\n                    {\n                        error = \"Address is not allowed.\";\n                        return null;\n                    }\n                }\n\n                return new DownloadUrlInfo(host, addresses, uri);\n            }\n            catch\n            {\n                error = \"DNS resolution failed.\";\n                return null;\n            }\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast)\n                {\n                    return true;\n                }\n                if (address.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (partial, for policy and config setup)\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApp.Models;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.Configure<DownloadSecurityOptions>(\n    builder.Configuration.GetSection(\"DownloadSecurity\"));\n\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddControllers();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\nvar app = builder.Build();\n\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n", "orig": "```csharp\nControllers/DownloadController.cs\n----------------------------\n\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpPost(\"download\")]\n        public async Task<IActionResult> Download(string url)\n        {\n            // Validate input\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            // Download content\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            var content = await response.Content.ReadAsByteArrayAsync();\n\n            // Return file\n            return File(content, response.Content.Headers.ContentType.MediaType);\n        }\n    }\n}\n```"}
{"prompt": "Design a C# function which accepts a URL and returns the data found at that URL.", "response": "```csharp\n// Controllers/UrlDataFetchController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Controllers\n{\n    // To use this, set up a policy named \"TrustedUrlFetch\" in your authorization configuration.\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"TrustedUrlFetch\")]\n    public class UrlDataFetchController : ControllerBase\n    {\n        private readonly IUrlDataFetcherService _urlDataFetcherService;\n        private readonly ILogger<UrlDataFetchController> _logger;\n\n        public UrlDataFetchController(\n            IUrlDataFetcherService urlDataFetcherService,\n            ILogger<UrlDataFetchController> logger)\n        {\n            _urlDataFetcherService = urlDataFetcherService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"fetch\")]\n        [Authorize(Policy = \"TrustedUrlFetch\")]\n        public async Task<IActionResult> FetchUrlData([FromBody] UrlFetchRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid input\", details = ModelState });\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Fetching URL data for URL: {Url}\", request.Url);\n\n                var result = await _urlDataFetcherService.FetchDataFromTrustedUrlAsync(request.Url);\n\n                if (result == null)\n                {\n                    return NotFound(new { error = \"Resource not found or not permitted\" });\n                }\n\n                return File(result.Data, result.ContentType ?? \"application/octet-stream\");\n            }\n            catch (UrlFetchValidationException ex)\n            {\n                _logger.LogWarning(\"URL validation failed: {Message}\", ex.Message);\n                return BadRequest(new { error = \"URL validation failed\", details = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error while fetching URL data.\");\n                return StatusCode(500, new { error = \"Unexpected server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlFetchRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApi.Dtos\n{\n    public class UrlFetchRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlDataFetcherService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public interface IUrlDataFetcherService\n    {\n        Task<UrlFetchResult> FetchDataFromTrustedUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlDataFetcherService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public class UrlDataFetcherService : IUrlDataFetcherService\n    {\n        private readonly ILogger<UrlDataFetcherService> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlDataFetcherService(ILogger<UrlDataFetcherService> logger, IConfiguration configuration)\n        {\n            _logger = logger;\n            _configuration = configuration;\n\n            var domains = _configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(domains, StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<UrlFetchResult> FetchDataFromTrustedUrlAsync(string url)\n        {\n            var uri = ValidateAndParseUrl(url);\n            var host = uri.Host;\n\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new UrlFetchValidationException(\"Domain not trusted.\");\n            }\n\n            var addresses = await Dns.GetHostAddressesAsync(host);\n\n            if (!addresses.Any())\n            {\n                throw new UrlFetchValidationException(\"Could not resolve host.\");\n            }\n\n            var allowed = addresses.All(ip => IsPublicIp(ip));\n            if (!allowed)\n            {\n                throw new UrlFetchValidationException(\"Resolved IP is not public.\");\n            }\n\n            using var handler = new HttpClientHandler();\n            handler.ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => true;\n            using var client = new HttpClient(handler);\n\n            client.Timeout = TimeSpan.FromSeconds(_configuration.GetValue(\"UrlFetchTimeoutSeconds\", 10));\n\n            var requestMessage = new HttpRequestMessage(HttpMethod.Get, new UriBuilder(uri) { Host = addresses[0].ToString() }.Uri);\n            requestMessage.Headers.Host = host;\n\n            var response = await client.SendAsync(requestMessage);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                return null;\n            }\n\n            var data = await response.Content.ReadAsByteArrayAsync();\n            var contentType = response.Content.Headers.ContentType?.MediaType;\n\n            return new UrlFetchResult\n            {\n                Data = data,\n                ContentType = contentType\n            };\n        }\n\n        private static Uri ValidateAndParseUrl(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new UrlFetchValidationException(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlFetchValidationException(\"Malformed URL.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlFetchValidationException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            return uri;\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip))\n                {\n                    return false;\n                }\n\n                var bytes = ip.GetAddressBytes();\n\n                // IPv4 private ranges\n                if (ip.AddressFamily == AddressFamily.InterNetwork)\n                {\n                    var first = bytes[0];\n                    var second = bytes[1];\n\n                    if (first == 10)\n                    {\n                        return false;\n                    }\n                    if (first == 172 && second >= 16 && second <= 31)\n                    {\n                        return false;\n                    }\n                    if (first == 192 && second == 168)\n                    {\n                        return false;\n                    }\n                    if (first == 169 && second == 254)\n                    {\n                        return false;\n                    }\n                }\n\n                // IPv6 link-local and unique local\n                if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n                {\n                    if (bytes[0] == 0xfe && (bytes[1] & 0xc0) == 0x80) // fe80::/10\n                    {\n                        return false;\n                    }\n                    if ((bytes[0] & 0xfe) == 0xfc) // fc00::/7\n                    {\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlFetchResult.cs\nnamespace MyApi.Services\n{\n    public class UrlFetchResult\n    {\n        public byte[] Data { get; set; }\n        public string ContentType { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/UrlFetchValidationException.cs\nusing System;\n\nnamespace MyApi.Services\n{\n    public class UrlFetchValidationException : Exception\n    {\n        public UrlFetchValidationException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n", "orig": "```csharp\nusing System.Net.Http;\nusing System.Text;\nusing System.Threading.Tasks;\n\npublic class UrlDataFetcher\n{\n    public async Task<string> FetchDataAsync(string url)\n    {\n        using var client = new HttpClient();\n        var response = await client.GetAsync(url);\n        response.EnsureSuccessStatusCode();\n        var content = await response.Content.ReadAsStringAsync();\n        return content;\n    }\n}\n```"}
{"prompt": "Write a C# function to take a URL entered by the user and extract its data.", "response": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System.Threading.Tasks;\nusing System;\nusing WebAPI.Models;\nusing WebAPI.Services;\nusing Microsoft.AspNetCore.Http;\n\nnamespace WebAPI.Controllers\n{\n    // To set up the policy, add services.AddAuthorization(options => options.AddPolicy(\"ExtractUrlPolicy\", policy => policy.RequireAuthenticatedUser())); in Program.cs\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"ExtractUrlPolicy\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly ILogger<UrlController> _logger;\n        private readonly IUrlValidationService _urlValidationService;\n\n        public UrlController(ILogger<UrlController> logger, IUrlValidationService urlValidationService)\n        {\n            _logger = logger;\n            _urlValidationService = urlValidationService;\n        }\n\n        [HttpPost(\"extract\")]\n        [Authorize(Policy = \"ExtractUrlPolicy\")]\n        public async Task<IActionResult> ExtractUrlData([FromBody] UrlExtractionRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var validationResult = await _urlValidationService.TryParseAndValidateUrlAsync(request.Url);\n\n                if (!validationResult.IsValid)\n                {\n                    _logger.LogWarning(\"URL validation failed: {Reason}\", validationResult.FailureReason ?? \"Unknown\");\n                    return BadRequest(new { Error = validationResult.FailureReason ?? \"Invalid URL\" });\n                }\n\n                var urlData = new UrlDataDto\n                {\n                    Protocol = validationResult.Protocol,\n                    Hostname = validationResult.Hostname,\n                    Port = validationResult.Port,\n                    Path = validationResult.Path\n                };\n\n                _logger.LogInformation(\"Extracted URL data for hostname: {Hostname}\", urlData.Hostname);\n\n                return Ok(urlData);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error extracting URL data\");\n                return StatusCode(StatusCodes.Status500InternalServerError, new { Error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlExtractionRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace WebAPI.Models\n{\n    public class UrlExtractionRequestDto\n    {\n        [Required]\n        [Url]\n        [StringLength(2048, MinimumLength = 10)]\n        public string Url { get; set; } = string.Empty;\n    }\n}\n```\n\n```csharp\n// Models/UrlDataDto.cs\nnamespace WebAPI.Models\n{\n    public class UrlDataDto\n    {\n        public string Protocol { get; set; } = string.Empty;\n        public string Hostname { get; set; } = string.Empty;\n        public int Port { get; set; }\n        public string Path { get; set; } = string.Empty;\n    }\n}\n```\n\n```csharp\n// Models/UrlValidationResult.cs\nnamespace WebAPI.Models\n{\n    public class UrlValidationResult\n    {\n        public bool IsValid { get; set; }\n        public string? FailureReason { get; set; }\n        public string Protocol { get; set; } = string.Empty;\n        public string Hostname { get; set; } = string.Empty;\n        public int Port { get; set; }\n        public string Path { get; set; } = string.Empty;\n    }\n}\n```\n\n```csharp\n// Services/IUrlValidationService.cs\nusing System.Threading.Tasks;\nusing WebAPI.Models;\n\nnamespace WebAPI.Services\n{\n    public interface IUrlValidationService\n    {\n        Task<UrlValidationResult> TryParseAndValidateUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlValidationService.cs\nusing System;\nusing System.Linq;\nusing System.Net;\nusing System.Threading.Tasks;\nusing WebAPI.Models;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System.Collections.Generic;\n\nnamespace WebAPI.Services\n{\n    public class UrlValidationService : IUrlValidationService\n    {\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<UrlValidationService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlValidationService(IConfiguration configuration, ILogger<UrlValidationService> logger)\n        {\n            _configuration = configuration;\n            _logger = logger;\n            _trustedDomains = LoadTrustedDomains();\n        }\n\n        public async Task<UrlValidationResult> TryParseAndValidateUrlAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return new UrlValidationResult\n                {\n                    IsValid = false,\n                    FailureReason = \"URL is required.\"\n                };\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return new UrlValidationResult\n                {\n                    IsValid = false,\n                    FailureReason = \"Malformed URL.\"\n                };\n            }\n\n            if (!string.Equals(uri.Scheme, \"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                return new UrlValidationResult\n                {\n                    IsValid = false,\n                    FailureReason = \"Only HTTPS URLs are allowed.\"\n                };\n            }\n\n            if (string.IsNullOrWhiteSpace(uri.Host))\n            {\n                return new UrlValidationResult\n                {\n                    IsValid = false,\n                    FailureReason = \"URL must have a host.\"\n                };\n            }\n\n            if (_trustedDomains.Count > 0 && !_trustedDomains.Contains(uri.Host, StringComparer.OrdinalIgnoreCase))\n            {\n                return new UrlValidationResult\n                {\n                    IsValid = false,\n                    FailureReason = \"Untrusted domain.\"\n                };\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(uri.Host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for {Host}\", uri.Host);\n                return new UrlValidationResult\n                {\n                    IsValid = false,\n                    FailureReason = \"Unable to resolve host.\"\n                };\n            }\n\n            if (addresses.Length == 0)\n            {\n                return new UrlValidationResult\n                {\n                    IsValid = false,\n                    FailureReason = \"DNS lookup returned no addresses.\"\n                };\n            }\n\n            foreach (var addr in addresses)\n            {\n                if (IsPrivateOrLoopback(addr))\n                {\n                    return new UrlValidationResult\n                    {\n                        IsValid = false,\n                        FailureReason = \"Host resolves to a private or loopback address.\"\n                    };\n                }\n            }\n\n            var port = uri.Port > 0 ? uri.Port : 443;\n\n            return new UrlValidationResult\n            {\n                IsValid = true,\n                Protocol = uri.Scheme,\n                Hostname = uri.Host,\n                Port = port,\n                Path = uri.PathAndQuery\n            };\n        }\n\n        private HashSet<string> LoadTrustedDomains()\n        {\n            var section = _configuration.GetSection(\"TrustedDomains\");\n            var domains = section.Get<string[]>();\n            return domains != null ? new HashSet<string>(domains, StringComparer.OrdinalIgnoreCase) : new HashSet<string>();\n        }\n\n        private bool IsPrivateOrLoopback(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast)\n                {\n                    return true;\n                }\n                if (address.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (partial - required registrations)\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing WebAPI.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddScoped<IUrlValidationService, UrlValidationService>();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"ExtractUrlPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\nvar app = builder.Build();\n\napp.MapControllers();\n\napp.Run();\n```", "orig": "```csharp\n// Controllers/UrlController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\n\nnamespace WebAPI.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(ILogger<UrlController> logger)\n        {\n            _logger = logger;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> ExtractUrlData(string url)\n        {\n            try\n            {\n                var urlData = new UrlData();\n\n                // Extract the protocol\n                var protocol = url.Substring(0, url.IndexOf(\"://\"));\n                urlData.Protocol = protocol;\n\n                // Extract the hostname\n                var hostname = url.Substring(protocol.Length + 3);\n                hostname = hostname.Substring(0, hostname.IndexOf(\"/\"));\n                urlData.Hostname = hostname;\n\n                // Extract the port\n                var port = url.Substring(hostname.Length + 3);\n                port = port.Substring(0, port.IndexOf(\"/\"));\n                urlData.Port = int.Parse(port);\n\n                // Extract the path\n                var path = url.Substring(hostname.Length + port.Length + 3);\n                urlData.Path = path;\n\n                return Ok(urlData);\n            }\n            catch (Exception e)\n            {\n                _logger.LogError(e, \"Error extracting URL data\");\n                return BadRequest();\n            }\n        }\n    }\n\n    // Models/UrlData.cs\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n    using System.Threading.Tasks;\n\n    namespace WebAPI.Models\n    {\n        public class UrlData\n        {\n            public string Protocol { get; set; }\n            public string Hostname { get; set; }\n            public int Port { get; set; }\n            public string Path { get; set; }\n        }\n    }\n```"}
{"prompt": "Write a C# function to take a URL entered by the user and extract its data.", "response": "```csharp\n// Controllers/UrlDataExtractionController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Controllers\n{\n    // To set up the policy: services.AddAuthorization(options => options.AddPolicy(\"UrlDataExtractPolicy\", ...));\n    [Authorize]\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class UrlDataExtractionController : ControllerBase\n    {\n        private readonly IUrlDataExtractionService _urlDataExtractionService;\n        private readonly ILogger<UrlDataExtractionController> _logger;\n\n        public UrlDataExtractionController(\n            IUrlDataExtractionService urlDataExtractionService,\n            ILogger<UrlDataExtractionController> logger)\n        {\n            _urlDataExtractionService = urlDataExtractionService;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"UrlDataExtractPolicy\")]\n        [HttpPost(\"extract\")]\n        public async Task<IActionResult> ExtractUrlData([FromBody] UrlDataExtractionRequestDto request)\n        {\n            _logger.LogInformation(\"ExtractUrlData called with URL: {Url}\", request?.Url);\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var urlData = await _urlDataExtractionService.ExtractUrlDataAsync(request.Url, HttpContext.RequestAborted);\n                if (urlData == null)\n                {\n                    return NotFound();\n                }\n\n                return Ok(urlData);\n            }\n            catch (UrlDataExtractionException ex)\n            {\n                _logger.LogWarning(ex, \"Extraction failed for URL: {Url}\", request.Url);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error extracting URL data for {Url}\", request.Url);\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlDataExtractionRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApi.Dtos\n{\n    public class UrlDataExtractionRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlDataExtractionResponseDto.cs\nnamespace MyApi.Dtos\n{\n    public class UrlDataExtractionResponseDto\n    {\n        public string Title { get; set; }\n        public string Description { get; set; }\n        public string Image { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlDataExtractionService.cs\nusing System.Threading;\nusing System.Threading.Tasks;\nusing MyApi.Dtos;\n\nnamespace MyApi.Services\n{\n    public interface IUrlDataExtractionService\n    {\n        Task<UrlDataExtractionResponseDto> ExtractUrlDataAsync(string url, CancellationToken cancellationToken);\n    }\n}\n```\n\n```csharp\n// Services/UrlDataExtractionService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApi.Dtos;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public class UrlDataExtractionService : IUrlDataExtractionService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlDataExtractionService> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlDataExtractionService(\n            IHttpClientFactory httpClientFactory,\n            ILogger<UrlDataExtractionService> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomains = GetTrustedDomains(configuration);\n        }\n\n        public async Task<UrlDataExtractionResponseDto> ExtractUrlDataAsync(string url, CancellationToken cancellationToken)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlDataExtractionException(\"Malformed URL.\");\n            }\n\n            if (!uri.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlDataExtractionException(\"Only HTTPS URLs are supported.\");\n            }\n\n            if (!_trustedDomains.Contains(uri.Host, StringComparer.OrdinalIgnoreCase))\n            {\n                throw new UrlDataExtractionException(\"Domain is not trusted.\");\n            }\n\n            var resolvedIp = await ResolveAndValidateHostAsync(uri.Host, cancellationToken);\n            if (resolvedIp == null)\n            {\n                throw new UrlDataExtractionException(\"Could not resolve host or host is not allowed.\");\n            }\n\n            var httpClient = _httpClientFactory.CreateClient(nameof(UrlDataExtractionService));\n            httpClient.Timeout = TimeSpan.FromSeconds(_configuration.GetValue<int?>(\"UrlDataExtraction:TimeoutSeconds\") ?? 10);\n\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            request.Version = HttpVersion.Version20;\n\n            _logger.LogInformation(\"Fetching URL: {Url} at IP: {Ip}\", url, resolvedIp);\n\n            using var response = await httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cancellationToken);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new UrlDataExtractionException(\"Failed to retrieve URL.\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync(cancellationToken);\n\n            var title = ExtractHtmlTagContent(content, \"title\");\n            var description = ExtractMetaContent(content, \"description\");\n            var image = ExtractMetaContent(content, \"image\");\n\n            return new UrlDataExtractionResponseDto\n            {\n                Title = title,\n                Description = description,\n                Image = image\n            };\n        }\n\n        private static string ExtractHtmlTagContent(string html, string tagName)\n        {\n            var regex = new Regex($@\"<{tagName}[^>]*>(?<val>.*?)</{tagName}>\", RegexOptions.IgnoreCase | RegexOptions.Singleline);\n            var match = regex.Match(html ?? string.Empty);\n            return match.Success ? match.Groups[\"val\"].Value.Trim() : null;\n        }\n\n        private static string ExtractMetaContent(string html, string metaName)\n        {\n            var regex = new Regex($@\"<meta\\s+[^>]*name\\s*=\\s*[\"\"']{metaName}[\"\"'][^>]*content\\s*=\\s*[\"\"'](?<val>[^\"\"']*)[\"\"'][^>]*>\", RegexOptions.IgnoreCase);\n            var match = regex.Match(html ?? string.Empty);\n            return match.Success ? match.Groups[\"val\"].Value.Trim() : null;\n        }\n\n        private HashSet<string> GetTrustedDomains(IConfiguration configuration)\n        {\n            var section = configuration.GetSection(\"UrlDataExtraction:TrustedDomains\");\n            var domains = section.Get<string[]>() ?? Array.Empty<string>();\n            return new HashSet<string>(domains, StringComparer.OrdinalIgnoreCase);\n        }\n\n        private async Task<IPAddress> ResolveAndValidateHostAsync(string host, CancellationToken cancellationToken)\n        {\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host, cancellationToken);\n            }\n            catch\n            {\n                return null;\n            }\n\n            foreach (var addr in addresses)\n            {\n                if (addr.AddressFamily == AddressFamily.InterNetwork || addr.AddressFamily == AddressFamily.InterNetworkV6)\n                {\n                    if (!IsPrivateOrLoopback(addr))\n                    {\n                        return addr;\n                    }\n                }\n            }\n            return null;\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (Link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n                // IPv6 loopback\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Exceptions/UrlDataExtractionException.cs\nusing System;\n\nnamespace MyApi\n{\n    public class UrlDataExtractionException : Exception\n    {\n        public UrlDataExtractionException(string message) : base(message) { }\n    }\n}\n```\n", "orig": "```csharp\nusing System;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\n\npublic class UrlDataExtractor\n{\n    public static UrlData Extract(string url)\n    {\n        if (string.IsNullOrEmpty(url))\n        {\n            throw new ArgumentException(\"Invalid URL\", nameof(url));\n        }\n\n        var httpClient = new HttpClient();\n        var response = httpClient.GetAsync(url).Result;\n\n        if (!response.IsSuccessStatusCode)\n        {\n            throw new HttpRequestException($\"Failed to retrieve URL: {url}\");\n        }\n\n        var content = response.Content.ReadAsStringAsync().Result;\n\n        var title = Regex.Match(content, @\"<title>(?<title>.*)</title>\").Groups[\"title\"].Value;\n        var description = Regex.Match(content, @\"<meta\\s+name=\"\"description\"\"\\s+content=\"\"(?<description>.*)\"\"\").Groups[\"description\"].Value;\n        var image = Regex.Match(content, @\"<meta\\s+name=\"\"image\"\"\\s+content=\"\"(?<image>.*)\"\"\").Groups[\"image\"].Value;\n\n        return new UrlData\n        {\n            Title = title,\n            Description = description,\n            Image = image\n        };\n    }\n}\n\npublic class UrlData\n{\n    public string Title { get; set; }\n    public string Description { get; set; }\n    public string Image { get; set; }\n}\n```"}
{"prompt": "Implement a C# method to accept a URL and fetch its content.", "response": "```csharp\n// Controllers/MyController.cs\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Controllers\n{\n    // To use this controller, set up the \"FetchContentPolicy\" policy in your authorization configuration.\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"FetchContentPolicy\")]\n    public class MyController : ControllerBase\n    {\n        private readonly IFetchContentFromTrustedUrlService _fetchContentService;\n        private readonly ILogger<MyController> _logger;\n\n        public MyController(\n            IFetchContentFromTrustedUrlService fetchContentService,\n            ILogger<MyController> logger)\n        {\n            _fetchContentService = fetchContentService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"FetchContentPolicy\")]\n        public async Task<IActionResult> GetContent([FromQuery] FetchContentRequestDto request)\n        {\n            _logger.LogInformation(\"FetchContent requested for URL: {Url}\", request.Url);\n\n            try\n            {\n                var fetchResult = await _fetchContentService.FetchContentAsync(request.Url);\n\n                if (fetchResult.IsSuccess)\n                {\n                    _logger.LogInformation(\"Successfully fetched content for URL: {Url}\", request.Url);\n                    return File(fetchResult.Content, fetchResult.ContentType ?? \"application/octet-stream\");\n                }\n                else\n                {\n                    _logger.LogWarning(\"Failed to fetch content for URL: {Url}. Reason: {Reason}\", request.Url, fetchResult.ErrorMessage);\n                    return BadRequest(new { error = fetchResult.ErrorMessage });\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error while fetching content for URL: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/FetchContentRequestDto.cs\nusing System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class FetchContentRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IFetchContentFromTrustedUrlService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IFetchContentFromTrustedUrlService\n    {\n        Task<FetchContentResult> FetchContentAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/FetchContentFromTrustedUrlService.cs\nusing System;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Services\n{\n    public class FetchContentFromTrustedUrlService : IFetchContentFromTrustedUrlService\n    {\n        private readonly string[] _trustedDomains;\n        private readonly ILogger<FetchContentFromTrustedUrlService> _logger;\n        private readonly TimeSpan _timeout;\n\n        public FetchContentFromTrustedUrlService(IConfiguration configuration, ILogger<FetchContentFromTrustedUrlService> logger)\n        {\n            _trustedDomains = configuration.GetSection(\"TrustedFetchDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _timeout = TimeSpan.FromSeconds(configuration.GetValue<int>(\"FetchTimeoutSeconds\", 10));\n            _logger = logger;\n        }\n\n        public async Task<FetchContentResult> FetchContentAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return FetchContentResult.Failure(\"URL is not well-formed.\");\n            }\n\n            if (!uri.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return FetchContentResult.Failure(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (string.IsNullOrEmpty(uri.Host))\n            {\n                return FetchContentResult.Failure(\"Host is missing in the URL.\");\n            }\n\n            var domainAllowed = _trustedDomains\n                .Any(d => string.Equals(d, uri.Host, StringComparison.OrdinalIgnoreCase));\n\n            if (!domainAllowed)\n            {\n                return FetchContentResult.Failure(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(uri.Host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host {Host}\", uri.Host);\n                return FetchContentResult.Failure(\"DNS resolution failed.\");\n            }\n\n            var validAddress = addresses.FirstOrDefault(IsPublicAddress);\n            if (validAddress == null)\n            {\n                return FetchContentResult.Failure(\"Resolved IP is not public.\");\n            }\n\n            try\n            {\n                using var handler = new HttpClientHandler\n                {\n                    ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator\n                };\n\n                using var client = new HttpClient(handler)\n                {\n                    Timeout = _timeout\n                };\n\n                var builder = new UriBuilder(uri)\n                {\n                    Host = validAddress.ToString()\n                };\n\n                client.DefaultRequestHeaders.Host = uri.Host;\n\n                var response = await client.GetAsync(builder.Uri);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    return FetchContentResult.Failure(\"Unable to fetch content from URL.\");\n                }\n\n                var contentType = response.Content.Headers.ContentType?.MediaType;\n                var contentBytes = await response.Content.ReadAsByteArrayAsync();\n\n                return FetchContentResult.Success(contentBytes, contentType);\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed for {Url}\", url);\n                return FetchContentResult.Failure(\"HTTP request failed.\");\n            }\n            catch (TaskCanceledException)\n            {\n                return FetchContentResult.Failure(\"Request timed out.\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error in FetchContentAsync\");\n                return FetchContentResult.Failure(\"Unexpected error occurred.\");\n            }\n        }\n\n        private static bool IsPublicAddress(IPAddress address)\n        {\n            if (address == null)\n            {\n                return false;\n            }\n\n            if (IPAddress.IsLoopback(address))\n            {\n                return false;\n            }\n\n            if (address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return false;\n                }\n                // APIPA 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n            }\n            else if (address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast)\n                {\n                    return false;\n                }\n                if (address.Equals(IPAddress.IPv6Loopback))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Services/FetchContentResult.cs\nnamespace MyApp.Services\n{\n    public class FetchContentResult\n    {\n        public bool IsSuccess { get; }\n        public byte[] Content { get; }\n        public string ContentType { get; }\n        public string ErrorMessage { get; }\n\n        private FetchContentResult(bool isSuccess, byte[] content, string contentType, string errorMessage)\n        {\n            IsSuccess = isSuccess;\n            Content = content;\n            ContentType = contentType;\n            ErrorMessage = errorMessage;\n        }\n\n        public static FetchContentResult Success(byte[] content, string contentType)\n        {\n            return new FetchContentResult(true, content, contentType, null);\n        }\n\n        public static FetchContentResult Failure(string errorMessage)\n        {\n            return new FetchContentResult(false, null, null, errorMessage);\n        }\n    }\n}\n```\n\n```csharp\n// Startup/ServiceRegistrationExtensions.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApp.Services;\n\nnamespace MyApp.Startup\n{\n    public static class ServiceRegistrationExtensions\n    {\n        public static IServiceCollection AddFetchContentServices(this IServiceCollection services, IConfiguration configuration)\n        {\n            services.AddScoped<IFetchContentFromTrustedUrlService, FetchContentFromTrustedUrlService>();\n            return services;\n        }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedFetchDomains\": [\n    \"example.com\",\n    \"trustedsite.org\"\n  ],\n  \"FetchTimeoutSeconds\": 10\n}\n```\n", "orig": "```csharp\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class MyController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetContent(string url)\n        {\n            // Create a new HttpClient instance\n            var client = new HttpClient();\n\n            // Set the timeout for the request\n            client.Timeout = TimeSpan.FromSeconds(10);\n\n            // Make the GET request to the URL\n            var response = await client.GetAsync(url);\n\n            // Check if the request was successful\n            if (response.IsSuccessStatusCode)\n            {\n                // Read the response content\n                var content = await response.Content.ReadAsStringAsync();\n\n                // Return the content as a string\n                return Ok(content);\n            }\n            else\n            {\n                // Return an error message if the request failed\n                return BadRequest(\"Unable to fetch content from URL\");\n            }\n        }\n    }\n}\n```"}
{"prompt": "Compose a C# function to accept a URL from the user and extract data from it.", "response": "```csharp\n// Controllers/DataExtractionController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add in Program.cs:\n    // services.AddAuthorization(options => { options.AddPolicy(\"CanExtractData\", policy => policy.RequireAuthenticatedUser()); });\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"CanExtractData\")]\n    public class DataExtractionController : ControllerBase\n    {\n        private readonly IHtmlDataExtractionService _htmlDataExtractionService;\n        private readonly ILogger<DataExtractionController> _logger;\n\n        public DataExtractionController(IHtmlDataExtractionService htmlDataExtractionService, ILogger<DataExtractionController> logger)\n        {\n            _htmlDataExtractionService = htmlDataExtractionService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"extract-data\")]\n        [Authorize(Policy = \"CanExtractData\")]\n        public async Task<IActionResult> ExtractData([FromBody] DataExtractionRequestDto request)\n        {\n            _logger.LogInformation(\"ExtractData called with URL: {Url}\", request.Url);\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid input\", details = ModelState });\n            }\n\n            try\n            {\n                var result = await _htmlDataExtractionService.ExtractDataFromUrlAsync(request.Url);\n\n                if (result == null)\n                {\n                    return NotFound();\n                }\n\n                return Ok(new DataExtractionResponseDto { Text = result });\n            }\n            catch (DataExtractionException ex)\n            {\n                _logger.LogWarning(\"Data extraction failed: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (System.Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during data extraction.\");\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/DataExtractionRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class DataExtractionRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/DataExtractionResponseDto.cs\nnamespace MyApp.Models\n{\n    public class DataExtractionResponseDto\n    {\n        public string Text { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IHtmlDataExtractionService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IHtmlDataExtractionService\n    {\n        Task<string> ExtractDataFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/HtmlDataExtractionService.cs\nusing HtmlAgilityPack;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class HtmlDataExtractionService : IHtmlDataExtractionService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<HtmlDataExtractionService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public HtmlDataExtractionService(IHttpClientFactory httpClientFactory, IConfiguration configuration, ILogger<HtmlDataExtractionService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            var trusted = configuration.GetSection(\"TrustedHtmlDomains\").Get<string[]>();\n            _trustedDomains = trusted != null\n                ? new HashSet<string>(trusted, StringComparer.OrdinalIgnoreCase)\n                : new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<string> ExtractDataFromUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new DataExtractionException(\"URL is not well-formed.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new DataExtractionException(\"URL must use HTTPS.\");\n            }\n\n            if (!IsTrustedDomain(uri.Host))\n            {\n                throw new DataExtractionException(\"Domain is not trusted.\");\n            }\n\n            var ipAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n            var validIp = ipAddresses.FirstOrDefault(IsPublicIp);\n            if (validIp == null)\n            {\n                throw new DataExtractionException(\"Domain resolves to a non-public IP address.\");\n            }\n\n            var handler = new HttpClientHandler\n            {\n                ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator // Optionally add stricter validation\n            };\n\n            using var client = _httpClientFactory.CreateClient();\n            client.BaseAddress = new Uri($\"{uri.Scheme}://{uri.Host}\");\n\n            using var request = new HttpRequestMessage(HttpMethod.Get, uri.PathAndQuery);\n            using var response = await client.SendAsync(request);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new DataExtractionException(\"Failed to fetch data from the URL.\");\n            }\n\n            var html = await response.Content.ReadAsStringAsync();\n\n            var doc = new HtmlDocument();\n            doc.LoadHtml(html);\n            var dataNode = doc.DocumentNode.SelectSingleNode(\"//div[@class='data']\");\n            if (dataNode == null)\n            {\n                throw new DataExtractionException(\"Required data node not found in HTML.\");\n            }\n\n            return dataNode.InnerText.Trim();\n        }\n\n        private bool IsTrustedDomain(string host)\n        {\n            if (_trustedDomains.Contains(host))\n            {\n                return true;\n            }\n\n            // Also support subdomains of trusted domains\n            foreach (var trusted in _trustedDomains)\n            {\n                if (host.EndsWith(\".\" + trusted, StringComparison.OrdinalIgnoreCase))\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private bool IsPublicIp(IPAddress ip)\n        {\n            switch (ip.AddressFamily)\n            {\n                case AddressFamily.InterNetwork:\n                    var octets = ip.GetAddressBytes();\n                    // 10.0.0.0/8\n                    if (octets[0] == 10) return false;\n                    // 172.16.0.0/12\n                    if (octets[0] == 172 && octets[1] >= 16 && octets[1] <= 31) return false;\n                    // 192.168.0.0/16\n                    if (octets[0] == 192 && octets[1] == 168) return false;\n                    // 127.0.0.0/8\n                    if (octets[0] == 127) return false;\n                    // link-local 169.254.0.0/16\n                    if (octets[0] == 169 && octets[1] == 254) return false;\n                    break;\n                case AddressFamily.InterNetworkV6:\n                    if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal || ip.IsIPv6Teredo) return false;\n                    if (IPAddress.IsLoopback(ip)) return false;\n                    break;\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Services/DataExtractionException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class DataExtractionException : Exception\n    {\n        public DataExtractionException(string message) : base(message) { }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IHtmlDataExtractionService, HtmlDataExtractionService>();\n\n// Set up the policy here\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"CanExtractData\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n    });\n});\n\n// For TrustedHtmlDomains: add to appsettings.json, e.g.,\n// \"TrustedHtmlDomains\": [ \"trusted.com\", \"anothertrusted.com\" ]\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\napp.Run();\n```\n", "orig": "```csharp\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DataController : ControllerBase\n    {\n        [HttpPost(\"extract-data\")]\n        public async Task<IActionResult> ExtractData(string url)\n        {\n            // Implement data extraction logic here\n            // For example, using the HtmlAgilityPack library\n            var doc = new HtmlDocument();\n            doc.LoadHtml(url);\n            var data = doc.DocumentNode.SelectSingleNode(\"//div[@class='data']\");\n            return Ok(data.InnerText);\n        }\n    }\n}\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class Data\n    {\n        [Required]\n        public string Text { get; set; }\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddSwaggerGen(c =>\n            {\n                c.SwaggerDoc(\"v1\", new OpenApiInfo { Title = \"MyApp\", Version = \"v1\" });\n            });\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n                app.UseSwagger();\n                app.UseSwaggerUI(c => c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"MyApp v1\"));\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n```"}
{"prompt": "Compose a C# function to accept a URL input and download the resource content.", "response": "```csharp\n// Controllers/ResourceDownloadController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Controllers\n{\n    // Policy setup: Add services.AddAuthorization(options => { options.AddPolicy(\"TrustedResourceDownload\", policy => policy.RequireAuthenticatedUser()); }); in Program.cs or Startup.cs\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"TrustedResourceDownload\")]\n    public class ResourceDownloadController : ControllerBase\n    {\n        private readonly IResourceDownloader _resourceDownloader;\n        private readonly ILogger<ResourceDownloadController> _logger;\n\n        public ResourceDownloadController(IResourceDownloader resourceDownloader, ILogger<ResourceDownloadController> logger)\n        {\n            _resourceDownloader = resourceDownloader;\n            _logger = logger;\n        }\n\n        [HttpPost(\"download\")]\n        [Authorize(Policy = \"TrustedResourceDownload\")]\n        public async Task<IActionResult> DownloadResource([FromBody] ResourceDownloadRequestDto request)\n        {\n            _logger.LogInformation(\"DownloadResource called with Url: {Url}\", request.Url);\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid request\", details = ModelState });\n            }\n\n            try\n            {\n                var result = await _resourceDownloader.DownloadResourceAsync(request.Url);\n                if (result.IsSuccess)\n                {\n                    _logger.LogInformation(\"Resource downloaded successfully from {Url}\", request.Url);\n                    return File(result.Data, \"application/octet-stream\", result.FileName);\n                }\n                else\n                {\n                    _logger.LogWarning(\"Resource download failed: {Reason}\", result.ErrorMessage);\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during resource download\");\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/ResourceDownloadRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApi.Dtos\n{\n    public class ResourceDownloadRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IResourceDownloader.cs\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public interface IResourceDownloader\n    {\n        Task<ResourceDownloadResult> DownloadResourceAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/ResourceDownloader.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public class ResourceDownloader : IResourceDownloader\n    {\n        private readonly ILogger<ResourceDownloader> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly HashSet<string> _trustedDomains;\n\n        public ResourceDownloader(ILogger<ResourceDownloader> logger, IConfiguration configuration)\n        {\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomains = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n            var domains = _configuration.GetSection(\"TrustedResourceDomains\").Get<string[]>();\n            if (domains != null)\n            {\n                foreach (var domain in domains)\n                {\n                    if (!string.IsNullOrWhiteSpace(domain))\n                    {\n                        _trustedDomains.Add(domain.Trim());\n                    }\n                }\n            }\n        }\n\n        public async Task<ResourceDownloadResult> DownloadResourceAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return ResourceDownloadResult.Failure(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return ResourceDownloadResult.Failure(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(uri.Host))\n            {\n                return ResourceDownloadResult.Failure(\"URL must contain a host.\");\n            }\n\n            if (!_trustedDomains.Contains(uri.Host))\n            {\n                return ResourceDownloadResult.Failure(\"The domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(uri.Host);\n            }\n            catch (SocketException)\n            {\n                return ResourceDownloadResult.Failure(\"Failed to resolve host.\");\n            }\n\n            foreach (var addr in addresses)\n            {\n                if (IsPrivateOrLoopback(addr))\n                {\n                    return ResourceDownloadResult.Failure(\"IP address is not allowed.\");\n                }\n            }\n\n            var ip = addresses[0];\n            var builder = new UriBuilder(uri)\n            {\n                Host = ip.ToString()\n            };\n\n            var handler = new HttpClientHandler();\n            handler.ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => true;\n\n            using (var httpClient = new HttpClient(handler))\n            {\n                httpClient.DefaultRequestHeaders.Host = uri.Host;\n                try\n                {\n                    using (var response = await httpClient.GetAsync(builder.Uri))\n                    {\n                        if (!response.IsSuccessStatusCode)\n                        {\n                            return ResourceDownloadResult.Failure($\"Failed to download resource: {response.StatusCode}\");\n                        }\n\n                        var data = await response.Content.ReadAsByteArrayAsync();\n                        var filename = Path.GetFileName(uri.LocalPath);\n                        if (string.IsNullOrWhiteSpace(filename))\n                        {\n                            filename = \"resource.bin\";\n                        }\n\n                        return ResourceDownloadResult.Success(data, filename);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogError(ex, \"Error fetching resource from {Url}\", url);\n                    return ResourceDownloadResult.Failure(\"Error fetching resource.\");\n                }\n            }\n        }\n\n        private bool IsPrivateOrLoopback(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (Link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast || address.IsIPv6Teredo)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/ResourceDownloadResult.cs\nnamespace MyApi.Services\n{\n    public class ResourceDownloadResult\n    {\n        public bool IsSuccess { get; }\n        public byte[] Data { get; }\n        public string FileName { get; }\n        public string ErrorMessage { get; }\n\n        private ResourceDownloadResult(bool isSuccess, byte[] data, string fileName, string errorMessage)\n        {\n            IsSuccess = isSuccess;\n            Data = data;\n            FileName = fileName;\n            ErrorMessage = errorMessage;\n        }\n\n        public static ResourceDownloadResult Success(byte[] data, string fileName)\n        {\n            return new ResourceDownloadResult(true, data, fileName, null);\n        }\n\n        public static ResourceDownloadResult Failure(string errorMessage)\n        {\n            return new ResourceDownloadResult(false, null, null, errorMessage);\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (partial, for DI and policy setup)\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApi.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddScoped<IResourceDownloader, ResourceDownloader>();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedResourceDownload\", policy => policy.RequireAuthenticatedUser());\n});\nbuilder.Services.AddLogging();\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```json\n// appsettings.json (partial, trusted domains example)\n{\n  \"TrustedResourceDomains\": [\n    \"example.com\",\n    \"trustedsite.org\"\n  ]\n}\n```", "orig": "```csharp\nusing System;\nusing System.Net;\nusing System.IO;\n\npublic static void DownloadResource(string url)\n{\n    using (WebClient client = new WebClient())\n    {\n        client.DownloadFile(url, \"resource.txt\");\n    }\n}\n```"}
{"prompt": "Write a C# function to receive a URL and retrieve the content from that address.", "response": "```csharp\n// Controllers/UrlContentController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Set up the policy in Program.cs or Startup.cs:\n    // options.AddPolicy(\"TrustedUrlPolicy\", policy => policy.RequireAuthenticatedUser().RequireRole(\"UrlReader\"));\n    [Authorize(Policy = \"TrustedUrlPolicy\")]\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class UrlContentController : ControllerBase\n    {\n        private readonly IRemoteUrlContentFetcher _remoteUrlContentFetcher;\n        private readonly ILogger<UrlContentController> _logger;\n\n        public UrlContentController(\n            IRemoteUrlContentFetcher remoteUrlContentFetcher,\n            ILogger<UrlContentController> logger)\n        {\n            _remoteUrlContentFetcher = remoteUrlContentFetcher;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"TrustedUrlPolicy\")]\n        [HttpGet(\"url\")]\n        public async Task<IActionResult> GetUrlContent([FromQuery] UrlContentRequestDto request)\n        {\n            try\n            {\n                if (!request.IsValid(out var validationError))\n                {\n                    _logger.LogWarning(\"Invalid URL content request: {ValidationError}\", validationError);\n                    return BadRequest(new { error = validationError });\n                }\n\n                _logger.LogInformation(\"Fetching content for URL: {Url}\", request.Url);\n\n                var result = await _remoteUrlContentFetcher.FetchContentFromTrustedUrlAsync(request.Url);\n\n                if (!result.IsSuccess)\n                {\n                    _logger.LogWarning(\"Failed to fetch URL content for {Url}: {Error}\", request.Url, result.ErrorMessage);\n                    return StatusCode(result.StatusCode, new { error = result.ErrorMessage });\n                }\n\n                _logger.LogInformation(\"Successfully fetched URL content for {Url}\", request.Url);\n\n                return Ok(result.Content);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error fetching URL content for {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlContentRequestDto.cs\nusing System;\nusing System.Text.RegularExpressions;\n\nnamespace MyApp.Dtos\n{\n    public class UrlContentRequestDto\n    {\n        public string Url { get; set; }\n\n        public bool IsValid(out string error)\n        {\n            error = null;\n\n            if (string.IsNullOrWhiteSpace(Url))\n            {\n                error = \"URL is required.\";\n                return false;\n            }\n\n            if (!Uri.TryCreate(Url, UriKind.Absolute, out var uri))\n            {\n                error = \"URL is not well-formed.\";\n                return false;\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                error = \"Only HTTPS scheme is allowed.\";\n                return false;\n            }\n\n            // Hostname must be present\n            if (string.IsNullOrWhiteSpace(uri.Host))\n            {\n                error = \"URL must have a valid hostname.\";\n                return false;\n            }\n\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Services/IRemoteUrlContentFetcher.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IRemoteUrlContentFetcher\n    {\n        Task<UrlContentFetchResult> FetchContentFromTrustedUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlContentFetchResult.cs\nnamespace MyApp.Services\n{\n    public class UrlContentFetchResult\n    {\n        public bool IsSuccess { get; set; }\n        public string Content { get; set; }\n        public string ErrorMessage { get; set; }\n        public int StatusCode { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/RemoteUrlContentFetcher.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class RemoteUrlContentFetcher : IRemoteUrlContentFetcher\n    {\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<RemoteUrlContentFetcher> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public RemoteUrlContentFetcher(IConfiguration configuration, ILogger<RemoteUrlContentFetcher> logger)\n        {\n            _configuration = configuration;\n            _logger = logger;\n            _trustedDomains = LoadTrustedDomainsFromConfig();\n        }\n\n        public async Task<UrlContentFetchResult> FetchContentFromTrustedUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return new UrlContentFetchResult\n                {\n                    IsSuccess = false,\n                    ErrorMessage = \"Malformed URL.\",\n                    StatusCode = 400\n                };\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return new UrlContentFetchResult\n                {\n                    IsSuccess = false,\n                    ErrorMessage = \"Only HTTPS scheme allowed.\",\n                    StatusCode = 400\n                };\n            }\n\n            if (!_trustedDomains.Contains(uri.Host, StringComparer.OrdinalIgnoreCase))\n            {\n                return new UrlContentFetchResult\n                {\n                    IsSuccess = false,\n                    ErrorMessage = \"Untrusted domain.\",\n                    StatusCode = 400\n                };\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(uri.Host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for {Host}\", uri.Host);\n                return new UrlContentFetchResult\n                {\n                    IsSuccess = false,\n                    ErrorMessage = \"DNS resolution failed.\",\n                    StatusCode = 400\n                };\n            }\n\n            var allowedAddresses = addresses.Where(ip => IsPublicIp(ip)).ToArray();\n            if (!allowedAddresses.Any())\n            {\n                return new UrlContentFetchResult\n                {\n                    IsSuccess = false,\n                    ErrorMessage = \"No valid public IP address found for host.\",\n                    StatusCode = 400\n                };\n            }\n\n            var ipToUse = allowedAddresses.First();\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = ipToUse.ToString()\n            };\n\n            var handler = new HttpClientHandler\n            {\n                ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => true\n            };\n\n            using var httpClient = new HttpClient(handler);\n\n            httpClient.DefaultRequestHeaders.Host = uri.Host;\n            httpClient.DefaultRequestHeaders.Add(\"User-Agent\", \"MyApp\");\n\n            try\n            {\n                var response = await httpClient.GetAsync(builder.Uri);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    return new UrlContentFetchResult\n                    {\n                        IsSuccess = false,\n                        ErrorMessage = \"Failed to retrieve content.\",\n                        StatusCode = (int)response.StatusCode\n                    };\n                }\n\n                var content = await response.Content.ReadAsStringAsync();\n\n                return new UrlContentFetchResult\n                {\n                    IsSuccess = true,\n                    Content = content,\n                    StatusCode = 200\n                };\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed for {Url}\", url);\n                return new UrlContentFetchResult\n                {\n                    IsSuccess = false,\n                    ErrorMessage = \"Failed to retrieve content.\",\n                    StatusCode = 400\n                };\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during HTTP fetch for {Url}\", url);\n                return new UrlContentFetchResult\n                {\n                    IsSuccess = false,\n                    ErrorMessage = \"Internal server error.\",\n                    StatusCode = 500\n                };\n            }\n        }\n\n        private HashSet<string> LoadTrustedDomainsFromConfig()\n        {\n            var domains = _configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            if (domains == null || domains.Length == 0)\n            {\n                return new HashSet<string>(StringComparer.OrdinalIgnoreCase) { \"example.com\" };\n            }\n            return new HashSet<string>(domains, StringComparer.OrdinalIgnoreCase);\n        }\n\n        private bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast || ip.IsIPv6Teredo)\n                {\n                    return false;\n                }\n            }\n            if (IPAddress.IsLoopback(ip))\n            {\n                return false;\n            }\n            var bytes = ip.GetAddressBytes();\n            // 10.0.0.0/8\n            if (bytes[0] == 10)\n            {\n                return false;\n            }\n            // 172.16.0.0/12\n            if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n            {\n                return false;\n            }\n            // 192.168.0.0/16\n            if (bytes[0] == 192 && bytes[1] == 168)\n            {\n                return false;\n            }\n            // 169.254.0.0/16 (link-local)\n            if (bytes[0] == 169 && bytes[1] == 254)\n            {\n                return false;\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (partial, for DI and policy setup)\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddScoped<IRemoteUrlContentFetcher, RemoteUrlContentFetcher>();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedUrlPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        policy.RequireRole(\"UrlReader\");\n    });\n});\nbuilder.Services.AddLogging();\n\nvar app = builder.Build();\napp.UseAuthorization();\napp.MapControllers();\napp.Run();\n```\n", "orig": "```csharp\n[HttpGet(\"url\")]\npublic async Task<IActionResult> GetUrlContent([FromQuery] string url)\n{\n    // Validate input\n    if (string.IsNullOrWhiteSpace(url))\n    {\n        return BadRequest(\"Invalid URL\");\n    }\n\n    // Create a new HttpClient instance\n    using var httpClient = new HttpClient();\n\n    // Set the User-Agent header\n    httpClient.DefaultRequestHeaders.Add(\"User-Agent\", \"MyApp\");\n\n    // Send a GET request to the URL\n    var response = await httpClient.GetAsync(url);\n\n    // Check if the response is successful\n    if (!response.IsSuccessStatusCode)\n    {\n        return StatusCode((int)response.StatusCode, \"Failed to retrieve content\");\n    }\n\n    // Read the response content\n    var content = await response.Content.ReadAsStringAsync();\n\n    // Return the content\n    return Ok(content);\n}\n```"}
{"prompt": "Compose a C# function to accept a URL input and download the resource content.", "response": "```csharp\n// Controllers/DownloadController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: services.AddAuthorization(options => options.AddPolicy(\"CanDownload\", policy => policy.RequireAuthenticatedUser()));\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"CanDownload\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IRemoteFileDownloadService _remoteFileDownloadService;\n        private readonly ILogger<DownloadController> _logger;\n\n        public DownloadController(IRemoteFileDownloadService remoteFileDownloadService, ILogger<DownloadController> logger)\n        {\n            _remoteFileDownloadService = remoteFileDownloadService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"CanDownload\")]\n        public async Task<IActionResult> Download([FromQuery] DownloadRequestDto request)\n        {\n            _logger.LogInformation(\"Download requested for URL: {Url}\", request.Url);\n\n            try\n            {\n                var result = await _remoteFileDownloadService.TryDownloadFromUrlAsync(request.Url);\n\n                if (!result.Success)\n                {\n                    _logger.LogWarning(\"Download failed for URL: {Url} - {Reason}\", request.Url, result.ErrorMessage);\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n\n                _logger.LogInformation(\"Download succeeded for URL: {Url}, Content-Type: {ContentType}\", request.Url, result.ContentType);\n\n                return File(result.FileBytes, result.ContentType ?? \"application/octet-stream\", result.FileName);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during download for URL: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dto/DownloadRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dto\n{\n    public class DownloadRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IRemoteFileDownloadService.cs\n\nusing System.Threading.Tasks;\nusing MyApp.Services.Models;\n\nnamespace MyApp.Services\n{\n    public interface IRemoteFileDownloadService\n    {\n        Task<RemoteFileDownloadResult> TryDownloadFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/RemoteFileDownloadService.cs\n\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services.Models;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class RemoteFileDownloadService : IRemoteFileDownloadService\n    {\n        private readonly ILogger<RemoteFileDownloadService> _logger;\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly HashSet<string> _trustedDomains;\n\n        public RemoteFileDownloadService(\n            ILogger<RemoteFileDownloadService> logger,\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration)\n        {\n            _logger = logger;\n            _httpClientFactory = httpClientFactory;\n            _trustedDomains = configuration.GetSection(\"TrustedDownloadDomains\")\n                                           .Get<string[]>()?.Select(d => d.ToLowerInvariant()).ToHashSet() ?? new HashSet<string>();\n        }\n\n        public async Task<RemoteFileDownloadResult> TryDownloadFromUrlAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return RemoteFileDownloadResult.Failure(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return RemoteFileDownloadResult.Failure(\"Malformed URL.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return RemoteFileDownloadResult.Failure(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (uri.HostNameType == UriHostNameType.Dns)\n            {\n                if (!_trustedDomains.Contains(uri.Host.ToLowerInvariant()))\n                {\n                    return RemoteFileDownloadResult.Failure(\"Domain is not trusted.\");\n                }\n\n                var ipAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n                if (ipAddresses.Length == 0)\n                {\n                    return RemoteFileDownloadResult.Failure(\"Could not resolve host.\");\n                }\n\n                foreach (var ip in ipAddresses)\n                {\n                    if (IsPrivateOrLoopback(ip))\n                    {\n                        return RemoteFileDownloadResult.Failure(\"Resolved IP is not allowed.\");\n                    }\n                }\n\n                // Use the first verified IP for the request\n                return await DownloadUsingIpAsync(uri, ipAddresses.First());\n            }\n            else if (uri.HostNameType == UriHostNameType.IPv4 || uri.HostNameType == UriHostNameType.IPv6)\n            {\n                var hostIp = IPAddress.Parse(uri.Host);\n                if (IsPrivateOrLoopback(hostIp))\n                {\n                    return RemoteFileDownloadResult.Failure(\"IP address is not allowed.\");\n                }\n\n                return await DownloadUsingIpAsync(uri, hostIp);\n            }\n\n            return RemoteFileDownloadResult.Failure(\"Unsupported host type.\");\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address) || address.IsIPv6LinkLocal || address.IsIPv6SiteLocal)\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private async Task<RemoteFileDownloadResult> DownloadUsingIpAsync(Uri uri, IPAddress ip)\n        {\n            var httpClient = _httpClientFactory.CreateClient();\n            var builder = new UriBuilder(uri)\n            {\n                Host = ip.ToString()\n            };\n\n            var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n            request.Headers.Host = uri.Host;\n\n            try\n            {\n                using var response = await httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead);\n                if (!response.IsSuccessStatusCode)\n                {\n                    return RemoteFileDownloadResult.Failure(\"Failed to download file.\");\n                }\n\n                var contentType = response.Content.Headers.ContentType?.ToString();\n                var fileName = GetFileNameFromUriOrHeader(uri, response);\n                var fileBytes = await response.Content.ReadAsByteArrayAsync();\n\n                return RemoteFileDownloadResult.Success(fileBytes, contentType, fileName);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Exception during file download for URI: {Uri}\", uri);\n                return RemoteFileDownloadResult.Failure(\"Error occurred while downloading file.\");\n            }\n        }\n\n        private static string GetFileNameFromUriOrHeader(Uri uri, HttpResponseMessage response)\n        {\n            if (response.Content.Headers.ContentDisposition != null &&\n                !string.IsNullOrWhiteSpace(response.Content.Headers.ContentDisposition.FileNameStar))\n            {\n                return response.Content.Headers.ContentDisposition.FileNameStar;\n            }\n            if (response.Content.Headers.ContentDisposition != null &&\n                !string.IsNullOrWhiteSpace(response.Content.Headers.ContentDisposition.FileName))\n            {\n                return response.Content.Headers.ContentDisposition.FileName;\n            }\n            return Path.GetFileName(uri.LocalPath);\n        }\n    }\n}\n```\n\n```csharp\n// Services/Models/RemoteFileDownloadResult.cs\n\nnamespace MyApp.Services.Models\n{\n    public class RemoteFileDownloadResult\n    {\n        public bool Success { get; }\n        public string ErrorMessage { get; }\n        public byte[] FileBytes { get; }\n        public string ContentType { get; }\n        public string FileName { get; }\n\n        private RemoteFileDownloadResult(bool success, string errorMessage, byte[] fileBytes, string contentType, string fileName)\n        {\n            Success = success;\n            ErrorMessage = errorMessage;\n            FileBytes = fileBytes;\n            ContentType = contentType;\n            FileName = fileName;\n        }\n\n        public static RemoteFileDownloadResult Success(byte[] fileBytes, string contentType, string fileName)\n        {\n            return new RemoteFileDownloadResult(true, null, fileBytes, contentType, fileName);\n        }\n\n        public static RemoteFileDownloadResult Failure(string errorMessage)\n        {\n            return new RemoteFileDownloadResult(false, errorMessage, null, null, null);\n        }\n    }\n}\n```\n\n```csharp\n// Startup/ServiceRegistrationExtensions.cs\n\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApp.Services;\n\nnamespace MyApp.Startup\n{\n    public static class ServiceRegistrationExtensions\n    {\n        public static IServiceCollection AddDownloadServices(this IServiceCollection services, IConfiguration configuration)\n        {\n            services.AddHttpClient();\n            services.AddScoped<IRemoteFileDownloadService, RemoteFileDownloadService>();\n            return services;\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/DownloadController.cs\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public IActionResult Download(string url)\n        {\n            // Validate input\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            // Download file\n            var filePath = DownloadFile(url);\n\n            // Return file\n            return File(filePath, \"application/octet-stream\");\n        }\n\n        private string DownloadFile(string url)\n        {\n            // Download file and save to disk\n            var filePath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());\n            using (var webClient = new WebClient())\n            {\n                webClient.DownloadFile(url, filePath);\n            }\n\n            return filePath;\n        }\n    }\n}\n```"}
{"prompt": "Develop a C# method that takes a URL provided by the user and fetches its data.", "response": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApi.Models;\nusing MyApi.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Controllers\n{\n    // To enable: builder.Services.AddAuthorization(options => options.AddPolicy(\"UrlFetchPolicy\", p => p.RequireAuthenticatedUser()));\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"UrlFetchPolicy\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlFetchService _urlFetchService;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IUrlFetchService urlFetchService, ILogger<UrlController> logger)\n        {\n            _urlFetchService = urlFetchService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"fetch\")]\n        [Authorize(Policy = \"UrlFetchPolicy\")]\n        public async Task<IActionResult> FetchUrl([FromBody] UrlFetchRequest request)\n        {\n            _logger.LogInformation(\"FetchUrl called for {Url}\", request?.Url);\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid input\", details = ModelState });\n            }\n\n            try\n            {\n                var result = await _urlFetchService.FetchUrlDataAsync(request.Url);\n                if (result == null)\n                {\n                    return NotFound(new { error = \"Resource not found or forbidden\" });\n                }\n\n                return Ok(result);\n            }\n            catch (UrlFetchServiceException ex)\n            {\n                _logger.LogWarning(\"Url fetch failed for {Url}: {Message}\", request.Url, ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error when fetching URL {Url}\", request.Url);\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlFetchRequest.cs\nusing System.ComponentModel.DataAnnotations;\nusing System.Text.Json.Serialization;\n\nnamespace MyApi.Models\n{\n    public class UrlFetchRequest\n    {\n        [Required]\n        [JsonPropertyName(\"url\")]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlData.cs\nusing System.Text.Json.Serialization;\n\nnamespace MyApi.Models\n{\n    public class UrlData\n    {\n        [JsonPropertyName(\"url\")]\n        public string Url { get; set; }\n\n        [JsonPropertyName(\"data\")]\n        public string Data { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlFetchService.cs\nusing System.Threading.Tasks;\nusing MyApi.Models;\n\nnamespace MyApi.Services\n{\n    public interface IUrlFetchService\n    {\n        Task<UrlData?> FetchUrlDataAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlFetchServiceException.cs\nusing System;\n\nnamespace MyApi.Services\n{\n    public class UrlFetchServiceException : Exception\n    {\n        public UrlFetchServiceException(string message) : base(message) { }\n    }\n}\n```\n\n```csharp\n// Services/UrlFetchService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApi.Models;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public class UrlFetchService : IUrlFetchService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlFetchService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlFetchService(IHttpClientFactory httpClientFactory, ILogger<UrlFetchService> logger, IConfiguration config)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _trustedDomains = config.GetSection(\"TrustedDomains\").Get<string[]>()?.Select(d => d.ToLowerInvariant()).ToHashSet() ?? new HashSet<string>();\n        }\n\n        public async Task<UrlData?> FetchUrlDataAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new UrlFetchServiceException(\"URL must not be empty.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlFetchServiceException(\"Malformed URL.\");\n            }\n\n            if (!string.Equals(uri.Scheme, \"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlFetchServiceException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (uri.HostNameType == UriHostNameType.Dns)\n            {\n                if (!_trustedDomains.Contains(uri.Host.ToLowerInvariant()))\n                {\n                    throw new UrlFetchServiceException(\"Domain is not trusted.\");\n                }\n\n                var resolvedIps = await Dns.GetHostAddressesAsync(uri.Host);\n                if (resolvedIps.Length == 0)\n                {\n                    throw new UrlFetchServiceException(\"Could not resolve host.\");\n                }\n\n                foreach (var ip in resolvedIps)\n                {\n                    if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                    {\n                        throw new UrlFetchServiceException(\"Resolved IP is not allowed.\");\n                    }\n                }\n\n                // Use the first valid IP and reconstruct the URL (preserving path/query)\n                var resolvedIp = resolvedIps.First(ip => !IsPrivateOrLoopbackOrLinkLocal(ip));\n                var builder = new UriBuilder(uri)\n                {\n                    Host = resolvedIp.ToString()\n                };\n                var fetchUrl = builder.Uri.ToString();\n\n                var client = _httpClientFactory.CreateClient();\n                client.DefaultRequestHeaders.Host = uri.Host;\n\n                var response = await client.GetAsync(fetchUrl);\n                if (!response.IsSuccessStatusCode)\n                {\n                    return null;\n                }\n\n                var data = await response.Content.ReadAsStringAsync();\n                return new UrlData { Url = url, Data = data };\n            }\n            else if (uri.HostNameType == UriHostNameType.IPv4 || uri.HostNameType == UriHostNameType.IPv6)\n            {\n                var ip = IPAddress.Parse(uri.Host);\n                if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                {\n                    throw new UrlFetchServiceException(\"IP address is not allowed.\");\n                }\n\n                var client = _httpClientFactory.CreateClient();\n                var response = await client.GetAsync(url);\n                if (!response.IsSuccessStatusCode)\n                {\n                    return null;\n                }\n\n                var data = await response.Content.ReadAsStringAsync();\n                return new UrlData { Url = url, Data = data };\n            }\n            else\n            {\n                throw new UrlFetchServiceException(\"Unsupported host type.\");\n            }\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip)) { return true; }\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10) { return true; }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) { return true; }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168) { return true; }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254) { return true; }\n            }\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal || ip.IsIPv6Teredo || ip.IsIPv6UniqueLocal)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApi.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Configuration.AddJsonFile(\"appsettings.json\", optional: true);\n\n// Authorization policy setup example:\n// builder.Services.AddAuthorization(options => options.AddPolicy(\"UrlFetchPolicy\", p => p.RequireAuthenticatedUser()));\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"UrlFetchPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n    });\n});\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IUrlFetchService, UrlFetchService>();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n}\n\napp.UseHttpsRedirection();\n\napp.UseRouting();\n\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```json\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"api.example.com\"\n  ]\n}\n```", "orig": "```csharp\nusing Microsoft.AspNetCore.Mvc;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<ActionResult<string>> GetUrlData(string url)\n        {\n            // Create an HttpClient instance\n            using var client = new HttpClient();\n\n            // Fetch the URL data\n            var response = await client.GetAsync(url);\n\n            // Check if the response is successful\n            if (response.IsSuccessStatusCode)\n            {\n                // Return the response data as a string\n                return await response.Content.ReadAsStringAsync();\n            }\n            else\n            {\n                // Return an error message\n                return $\"Error: {response.StatusCode} - {response.ReasonPhrase}\";\n            }\n        }\n    }\n}\n\nusing System.Text.Json.Serialization;\n\nnamespace MyApi.Models\n{\n    public class UrlData\n    {\n        [JsonPropertyName(\"url\")]\n        public string Url { get; set; }\n\n        [JsonPropertyName(\"data\")]\n        public string Data { get; set; }\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApi\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApi\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureAppConfiguration((hostingContext, config) =>\n                {\n                    config.AddJsonFile(\"appsettings.json\", optional: true);\n                })\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\nusing Microsoft.AspNetCore.Mvc;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<ActionResult<string>> GetUrlData(string url)\n        {\n            // Create an HttpClient instance\n            using var client = new HttpClient();\n\n            // Fetch the URL data\n            var response = await client.GetAsync(url);\n\n            // Check if the response is successful\n            if (response.IsSuccessStatusCode)\n            {\n                // Return the response data as a string\n                return await response.Content.ReadAsStringAsync();\n            }\n            else\n            {\n                // Return an error message\n                return $\"Error: {response.StatusCode} - {response.ReasonPhrase}\";\n            }\n        }\n    }\n}\n\nusing System.Text.Json.Serialization;\n\nnamespace MyApi.Models\n{\n    public class UrlData\n    {\n        [JsonPropertyName(\"url\")]\n        public string Url { get; set; }\n\n        [JsonPropertyName(\"data\")]\n        public string Data { get; set; }\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApi\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApi\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureAppConfiguration((hostingContext, config) =>\n                {\n                    config.AddJsonFile(\"appsettings.json\", optional: true);\n                })\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\nusing Microsoft.AspNetCore.Mvc;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<ActionResult<string>> GetUrlData(string url)\n        {\n            // Create an HttpClient instance\n            using var client = new HttpClient();\n\n            // Fetch the URL data\n            var response = await client.GetAsync(url);\n\n            // Check if the response is successful\n            if (response.IsSuccessStatusCode)\n            {\n                // Return the response data as a string\n                return await response.Content.ReadAsStringAsync();\n            }\n            else\n            {\n                // Return an error message\n                return $\"Error: {response.StatusCode} - {response.ReasonPhrase}\";\n            }\n        }\n    }\n}\n\nusing System.Text.Json.Serialization;\n\nnamespace MyApi.Models\n{\n    public class UrlData\n    {\n        [JsonPropertyName(\"url\")]\n        public string Url { get; set; }\n\n        [JsonPropertyName(\"data\")]\n        public string Data { get; set; }\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApi\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApi\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureAppConfiguration((hostingContext, config) =>\n                {\n                    config.AddJsonFile(\"appsettings.json\", optional: true);\n                })\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\nusing Microsoft.AspNetCore.Mvc;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<ActionResult<string>> GetUrlData(string url)\n        {\n            // Create an HttpClient instance\n            using var client = new HttpClient();\n\n            // Fetch the URL data\n            var response = await client.GetAsync(url);\n\n            // Check if the response is successful\n            if (response.IsSuccessStatusCode)\n            {\n                // Return the response data as a string\n                return await response.Content.ReadAsStringAsync();\n            }\n            else\n            {\n                // Return an error message\n                return $\"Error: {response.StatusCode} - {response.ReasonPhrase}\";\n            }\n        }\n    }\n}\n\nusing System.Text.Json.Serialization;\n\nnamespace MyApi.Models\n{\n    public class UrlData\n    {\n        [JsonPropertyName(\"url\")]\n        public string Url { get; set; }\n\n        [JsonPropertyName(\"data\")]\n        public string Data { get; set; }\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApi\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApi\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureAppConfiguration((hostingContext, config) =>\n                {\n                    config.AddJsonFile(\"appsettings.json\", optional: true);\n                })\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n```"}
{"prompt": "Implement a C# method to accept a URL and fetch its content.", "response": "```csharp\n// Controllers/UrlContentController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Controllers\n{\n    // To set up the policy, configure Authorization in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => { options.AddPolicy(\"TrustedUrlPolicy\", policy => policy.RequireAuthenticatedUser()); });\n\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"TrustedUrlPolicy\")]\n    public class UrlContentController : ControllerBase\n    {\n        private readonly IUrlContentFetcher _urlContentFetcher;\n        private readonly ILogger<UrlContentController> _logger;\n\n        public UrlContentController(IUrlContentFetcher urlContentFetcher, ILogger<UrlContentController> logger)\n        {\n            _urlContentFetcher = urlContentFetcher;\n            _logger = logger;\n        }\n\n        [HttpGet(\"fetch\")]\n        [Authorize(Policy = \"TrustedUrlPolicy\")]\n        public async Task<IActionResult> GetUrlContent([FromQuery] UrlContentRequestDto request)\n        {\n            try\n            {\n                _logger.LogInformation(\"Requested fetch for URL: {Url}\", request.Url);\n\n                var content = await _urlContentFetcher.FetchContentFromUrlAsync(request.Url);\n\n                _logger.LogInformation(\"Content fetched successfully for URL: {Url}\", request.Url);\n\n                return Ok(content);\n            }\n            catch (UrlContentValidationException ex)\n            {\n                _logger.LogWarning(\"Validation failed for URL: {Url}. Reason: {Reason}\", request.Url, ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (UrlContentAccessException ex)\n            {\n                _logger.LogWarning(\"Access failure for URL: {Url}. Reason: {Reason}\", request.Url, ex.Message);\n                return NotFound(new { error = \"Resource not found or access denied.\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error fetching URL: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlContentRequestDto.cs\nusing System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApi.Dtos\n{\n    public class UrlContentRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; } = string.Empty;\n    }\n}\n```\n\n```csharp\n// Services/IUrlContentFetcher.cs\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public interface IUrlContentFetcher\n    {\n        Task<string> FetchContentFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlContentFetcher.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public class UrlContentFetcher : IUrlContentFetcher\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlContentFetcher> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlContentFetcher(IHttpClientFactory httpClientFactory, IConfiguration configuration, ILogger<UrlContentFetcher> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n\n            var trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            _trustedDomains = new HashSet<string>(trustedDomains ?? Array.Empty<string>(), StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<string> FetchContentFromUrlAsync(string url)\n        {\n            var uri = ValidateAndParseUrl(url);\n            ValidateScheme(uri);\n            ValidateDomain(uri);\n\n            var ipAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n            ValidateIpAddresses(ipAddresses);\n\n            var ipAddress = ipAddresses.First();\n            var urlWithIp = new UriBuilder(uri)\n            {\n                Host = ipAddress.ToString()\n            }.Uri;\n\n            using (var httpClient = _httpClientFactory.CreateClient())\n            {\n                httpClient.DefaultRequestHeaders.Host = uri.Host;\n                var response = await httpClient.GetAsync(urlWithIp);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    throw new UrlContentAccessException($\"Failed to fetch resource. Status code: {response.StatusCode}\");\n                }\n\n                return await response.Content.ReadAsStringAsync();\n            }\n        }\n\n        private static Uri ValidateAndParseUrl(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new UrlContentValidationException(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlContentValidationException(\"Invalid URL format.\");\n            }\n\n            return uri;\n        }\n\n        private static void ValidateScheme(Uri uri)\n        {\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlContentValidationException(\"Only HTTPS URLs are allowed.\");\n            }\n        }\n\n        private void ValidateDomain(Uri uri)\n        {\n            if (!_trustedDomains.Contains(uri.Host))\n            {\n                throw new UrlContentValidationException(\"Domain is not trusted.\");\n            }\n        }\n\n        private static void ValidateIpAddresses(IPAddress[] ipAddresses)\n        {\n            foreach (var ip in ipAddresses)\n            {\n                if (IsPrivateOrLoopback(ip))\n                {\n                    throw new UrlContentValidationException(\"IP address is not allowed.\");\n                }\n            }\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var octets = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (octets[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (octets[0] == 172 && octets[1] >= 16 && octets[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (octets[0] == 192 && octets[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (octets[0] == 169 && octets[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast || ip.IsIPv6Teredo)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Exceptions/UrlContentValidationException.cs\nusing System;\n\nnamespace MyApi\n{\n    public class UrlContentValidationException : Exception\n    {\n        public UrlContentValidationException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// Exceptions/UrlContentAccessException.cs\nusing System;\n\nnamespace MyApi\n{\n    public class UrlContentAccessException : Exception\n    {\n        public UrlContentAccessException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n", "orig": "```csharp\nusing System.Net.Http;\n\npublic class HttpClientHelper\n{\n    public static async Task<string> GetUrlContentAsync(string url)\n    {\n        using (var httpClient = new HttpClient())\n        {\n            var response = await httpClient.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            return await response.Content.ReadAsStringAsync();\n        }\n    }\n}\n\nusing System.Threading.Tasks;\n\npublic class MyController : ControllerBase\n{\n    [HttpGet(\"url\")]\n    public async Task<IActionResult> GetUrlContent(string url)\n    {\n        var content = await HttpClientHelper.GetUrlContentAsync(url);\n        return Ok(content);\n    }\n}\n```"}
{"prompt": "Compose a C# function to accept a URL from the user and return its content.", "response": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To setup: Add a policy named \"TrustedUrlRead\" in your authorization setup.\n    [Authorize(Policy = \"TrustedUrlRead\")]\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlContentFetcher _urlContentFetcher;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IUrlContentFetcher urlContentFetcher, ILogger<UrlController> logger)\n        {\n            _urlContentFetcher = urlContentFetcher;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"TrustedUrlRead\")]\n        [HttpGet(\"content\")]\n        public async Task<IActionResult> GetUrlContent([FromQuery] UrlContentRequestDto request)\n        {\n            _logger.LogInformation(\"GetUrlContent called with url: {Url}\", request.Url);\n\n            try\n            {\n                var result = await _urlContentFetcher.FetchContentAsync(request.Url);\n\n                if (!result.IsSuccess)\n                {\n                    _logger.LogWarning(\"Failed to fetch content for url: {Url}. Reason: {Reason}\", request.Url, result.ErrorMessage);\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n\n                _logger.LogInformation(\"Successfully fetched content for url: {Url}\", request.Url);\n                return Ok(result.Content);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error fetching content for url: {Url}\", request.Url);\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlContentRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class UrlContentRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlContentFetcher.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlContentFetcher\n    {\n        Task<UrlContentFetchResult> FetchContentAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlContentFetcher.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlContentFetcher : IUrlContentFetcher\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<UrlContentFetcher> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlContentFetcher(\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration,\n            ILogger<UrlContentFetcher> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _configuration = configuration;\n            _logger = logger;\n\n            _trustedDomains = new HashSet<string>(\n                _configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>(),\n                StringComparer.OrdinalIgnoreCase\n            );\n        }\n\n        public async Task<UrlContentFetchResult> FetchContentAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return UrlContentFetchResult.Failure(\"Url is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return UrlContentFetchResult.Failure(\"Url is invalid.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return UrlContentFetchResult.Failure(\"Only HTTPS scheme is allowed.\");\n            }\n\n            string host = uri.Host;\n            if (!_trustedDomains.Contains(host))\n            {\n                return UrlContentFetchResult.Failure(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (SocketException ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for: {Host}\", host);\n                return UrlContentFetchResult.Failure(\"DNS resolution failed.\");\n            }\n\n            if (!addresses.Any())\n            {\n                return UrlContentFetchResult.Failure(\"No IP addresses found for host.\");\n            }\n\n            foreach (var address in addresses)\n            {\n                if (IsPrivateOrLoopbackIp(address))\n                {\n                    return UrlContentFetchResult.Failure(\"Resolved IP is not allowed.\");\n                }\n            }\n\n            // Use the first valid address for connection\n            var httpClient = _httpClientFactory.CreateClient();\n            httpClient.BaseAddress = new Uri($\"{uri.Scheme}://{host}\");\n\n            HttpResponseMessage response;\n            try\n            {\n                var pathAndQuery = uri.PathAndQuery + uri.Fragment;\n                response = await httpClient.GetAsync(pathAndQuery);\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed for: {Url}\", url);\n                return UrlContentFetchResult.Failure(\"Failed to fetch content.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                return UrlContentFetchResult.Failure($\"Failed to fetch content. Status: {response.StatusCode}\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n            return UrlContentFetchResult.Success(content);\n        }\n\n        private static bool IsPrivateOrLoopbackIp(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return true;\n                }\n                // Link-local 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast)\n                {\n                    return true;\n                }\n                if (address.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlContentFetchResult.cs\nnamespace MyApp.Services\n{\n    public class UrlContentFetchResult\n    {\n        public bool IsSuccess { get; }\n        public string Content { get; }\n        public string ErrorMessage { get; }\n\n        private UrlContentFetchResult(bool isSuccess, string content, string errorMessage)\n        {\n            IsSuccess = isSuccess;\n            Content = content;\n            ErrorMessage = errorMessage;\n        }\n\n        public static UrlContentFetchResult Success(string content)\n        {\n            return new UrlContentFetchResult(true, content, null);\n        }\n\n        public static UrlContentFetchResult Failure(string errorMessage)\n        {\n            return new UrlContentFetchResult(false, null, errorMessage);\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (partial, for DI and config setup)\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add trusted domains in appsettings.json under \"TrustedDomains\": [ \"example.com\", ... ]\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IUrlContentFetcher, UrlContentFetcher>();\nbuilder.Services.AddControllers();\nbuilder.Services.AddLogging();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedUrlRead\", policy => policy.RequireAuthenticatedUser());\n});\n\nvar app = builder.Build();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json (partial, for trusted domains)\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"api.example.org\"\n  ]\n}\n```", "orig": "```csharp\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    public class UrlController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetUrlContent(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest(\"Url is required\");\n            }\n\n            var httpClient = new HttpClient();\n            var response = await httpClient.GetAsync(url);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                return BadRequest($\"Failed to get content from {url}\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n\n            return Ok(content);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    public class UrlController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetUrlContent(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest(\"Url is required\");\n            }\n\n            var uri = new Uri(url);\n\n            if (!uri.IsAbsoluteUri)\n            {\n                return BadRequest(\"Url is not absolute\");\n            }\n\n            var httpClient = new HttpClient();\n            var response = await httpClient.GetAsync(url);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                return BadRequest($\"Failed to get content from {url}\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n\n            return Ok(content);\n        }\n    }\n}\n```"}
{"prompt": "Develop a C# method that accepts a user-input URL and downloads the data.", "response": "```csharp\n// Controllers/DownloadController.cs\n\nusing System;\nusing System.IO;\nusing System.Net;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApi.Controllers\n{\n    // Setup: Add authorization policy in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => { options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser()); });\n    [Authorize(Policy = \"DownloadPolicy\")]\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IUrlValidationService _urlValidationService;\n        private readonly ILogger<DownloadController> _logger;\n        private readonly string _downloadDirectory;\n\n        public DownloadController(\n            IHttpClientFactory httpClientFactory,\n            IUrlValidationService urlValidationService,\n            ILogger<DownloadController> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _urlValidationService = urlValidationService;\n            _logger = logger;\n            _downloadDirectory = configuration.GetValue<string>(\"DownloadDirectory\", Path.Combine(Directory.GetCurrentDirectory(), \"Data\"));\n        }\n\n        [Authorize(Policy = \"DownloadPolicy\")]\n        [HttpGet(\"download\")]\n        public async Task<IActionResult> Download([FromQuery] DownloadRequestDto request)\n        {\n            _logger.LogInformation(\"Download requested for URL: {Url}\", request.Url);\n\n            try\n            {\n                var validationResult = await _urlValidationService.ValidateUrlAsync(request.Url);\n                if (!validationResult.IsValid)\n                {\n                    _logger.LogWarning(\"URL validation failed: {Reason}\", validationResult.FailureReason);\n                    return BadRequest(new { error = validationResult.FailureReason });\n                }\n\n                var httpClient = _httpClientFactory.CreateClient(\"SecureDownloadClient\");\n                using var response = await httpClient.GetAsync(validationResult.ResolvedUri);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to download from {Url}. StatusCode: {StatusCode}\", request.Url, response.StatusCode);\n                    return BadRequest(new { error = \"Failed to download data from the provided URL.\" });\n                }\n\n                Directory.CreateDirectory(_downloadDirectory);\n                var filePath = Path.Combine(_downloadDirectory, \"downloaded.txt\");\n\n                await using (var stream = await response.Content.ReadAsStreamAsync())\n                await using (var fileStream = new FileStream(filePath, FileMode.Create, FileAccess.Write, FileShare.None))\n                {\n                    await stream.CopyToAsync(fileStream);\n                }\n\n                _logger.LogInformation(\"Data downloaded from {Url} and saved to {FilePath}\", request.Url, filePath);\n                return Ok(new { message = $\"Data downloaded and saved to {filePath}\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during download\");\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/DownloadRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApi.Dtos\n{\n    public class DownloadRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlValidationService.cs\n\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public interface IUrlValidationService\n    {\n        Task<UrlValidationResult> ValidateUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlValidationService.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApi.Services\n{\n    public class UrlValidationService : IUrlValidationService\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlValidationService(IConfiguration configuration)\n        {\n            var trusted = configuration.GetSection(\"TrustedDomains\").Get<List<string>>() ?? new List<string>();\n            _trustedDomains = new HashSet<string>(trusted.Select(d => d.ToLowerInvariant()));\n        }\n\n        public async Task<UrlValidationResult> ValidateUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return UrlValidationResult.Failure(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return UrlValidationResult.Failure(\"Only HTTPS URLs are allowed.\");\n            }\n\n            var host = uri.Host.ToLowerInvariant();\n            if (!_trustedDomains.Contains(host))\n            {\n                return UrlValidationResult.Failure(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                return UrlValidationResult.Failure(\"Failed to resolve host.\");\n            }\n\n            foreach (var address in addresses)\n            {\n                if (IsPrivateOrLoopback(address))\n                {\n                    return UrlValidationResult.Failure(\"IP address is not allowed.\");\n                }\n            }\n\n            return UrlValidationResult.Success(new UriBuilder(uri) { Host = host }.Uri);\n        }\n\n        private bool IsPrivateOrLoopback(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlValidationResult.cs\n\nusing System;\n\nnamespace MyApi.Services\n{\n    public class UrlValidationResult\n    {\n        public bool IsValid { get; }\n        public string FailureReason { get; }\n        public Uri ResolvedUri { get; }\n\n        private UrlValidationResult(bool isValid, string failureReason, Uri resolvedUri)\n        {\n            IsValid = isValid;\n            FailureReason = failureReason;\n            ResolvedUri = resolvedUri;\n        }\n\n        public static UrlValidationResult Success(Uri resolvedUri)\n        {\n            return new UrlValidationResult(true, null, resolvedUri);\n        }\n\n        public static UrlValidationResult Failure(string reason)\n        {\n            return new UrlValidationResult(false, reason, null);\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (excerpt for DI and HttpClient setup)\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApi.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient(\"SecureDownloadClient\");\nbuilder.Services.AddScoped<IUrlValidationService, UrlValidationService>();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\n// Example config in appsettings.json:\n// \"TrustedDomains\": [ \"example.com\", \"trustedsite.org\" ],\n// \"DownloadDirectory\": \"C:\\\\MyApiData\"\n\nvar app = builder.Build();\n\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```", "orig": "```csharp\n// Controllers/DownloadController.cs\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApi.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet]\n        [Route(\"download\")]\n        public async Task<IActionResult> Download(string url)\n        {\n            // TODO: Validate the input URL\n\n            // Create an HTTP client to download the data\n            var httpClient = new HttpClient();\n\n            // Download the data from the URL\n            var response = await httpClient.GetAsync(url);\n\n            // Check if the download was successful\n            if (!response.IsSuccessStatusCode)\n            {\n                return BadRequest($\"Failed to download data from {url}\");\n            }\n\n            // Read the response data as a stream\n            var stream = await response.Content.ReadAsStreamAsync();\n\n            // Create a new file to save the data\n            var filePath = Path.Combine(Directory.GetCurrentDirectory(), \"Data\", \"downloaded.txt\");\n            using (var fileStream = new FileStream(filePath, FileMode.Create))\n            {\n                // Copy the stream to the file\n                await stream.CopyToAsync(fileStream);\n            }\n\n            // Return a success message\n            return Ok($\"Data downloaded from {url} and saved to {filePath}\");\n        }\n    }\n}\n```"}
{"prompt": "Create a C# function to receive a URL input and extract its content.", "response": "```csharp\n// Controllers/UrlContentController.cs\nusing System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing MyApp.Models;\nusing MyApp.Services;\n\nnamespace MyApp.Controllers\n{\n    // POLICY SETUP: Add a policy named \"FetchContentPolicy\" in your authorization configuration.\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"FetchContentPolicy\")]\n    public class UrlContentController : ControllerBase\n    {\n        private readonly IUrlContentFetcherService _urlContentFetcherService;\n        private readonly ILogger<UrlContentController> _logger;\n\n        public UrlContentController(IUrlContentFetcherService urlContentFetcherService, ILogger<UrlContentController> logger)\n        {\n            _urlContentFetcherService = urlContentFetcherService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"FetchContentPolicy\")]\n        public async Task<IActionResult> Get([FromQuery] UrlContentRequestDto request)\n        {\n            _logger.LogInformation(\"Received request to fetch content from URL: {Url}\", request.Url);\n\n            try\n            {\n                var content = await _urlContentFetcherService.FetchContentAsync(request.Url);\n                var result = new UrlContentResponseDto\n                {\n                    Content = content\n                };\n\n                _logger.LogInformation(\"Successfully fetched content from URL: {Url}\", request.Url);\n\n                return Ok(result);\n            }\n            catch (UrlContentFetcherException ex)\n            {\n                _logger.LogWarning(\"Failed to fetch content from URL: {Url}. Reason: {Reason}\", request.Url, ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error fetching content from URL: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlContentRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlContentRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlContentResponseDto.cs\nusing System.Text.Json.Serialization;\n\nnamespace MyApp.Models\n{\n    public class UrlContentResponseDto\n    {\n        [JsonPropertyName(\"content\")]\n        public string Content { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlContentFetcherService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlContentFetcherService\n    {\n        Task<string> FetchContentAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlContentFetcherService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System.Linq;\nusing System.Net.Sockets;\n\nnamespace MyApp.Services\n{\n    public class UrlContentFetcherService : IUrlContentFetcherService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlContentFetcherService> _logger;\n        private readonly List<string> _trustedDomains;\n\n        public UrlContentFetcherService(IHttpClientFactory httpClientFactory, IConfiguration configuration, ILogger<UrlContentFetcherService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n\n            var domains = configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            _trustedDomains = domains?.Select(d => d.ToLowerInvariant()).ToList() ?? new List<string>();\n        }\n\n        public async Task<string> FetchContentAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new UrlContentFetcherException(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlContentFetcherException(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlContentFetcherException(\"Only HTTPS scheme is allowed.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(uri.Host))\n            {\n                throw new UrlContentFetcherException(\"URL host is required.\");\n            }\n\n            var isTrusted = _trustedDomains.Any(trusted => string.Equals(uri.Host, trusted, StringComparison.OrdinalIgnoreCase));\n            if (!isTrusted)\n            {\n                throw new UrlContentFetcherException(\"URL host is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(uri.Host);\n            }\n            catch\n            {\n                throw new UrlContentFetcherException(\"Failed to resolve host.\");\n            }\n\n            if (addresses.Length == 0)\n            {\n                throw new UrlContentFetcherException(\"Unable to resolve host IP address.\");\n            }\n\n            foreach (var ip in addresses)\n            {\n                if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                {\n                    throw new UrlContentFetcherException(\"Resolved IP address is not allowed.\");\n                }\n            }\n\n            var ipToUse = addresses.First();\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = ipToUse.ToString()\n            };\n\n            var client = _httpClientFactory.CreateClient();\n            client.DefaultRequestHeaders.Host = uri.Host;\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await client.GetAsync(builder.Uri);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed for {Url}\", url);\n                throw new UrlContentFetcherException(\"Failed to fetch content from the URL.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new UrlContentFetcherException($\"Remote server returned error {(int)response.StatusCode}: {response.ReasonPhrase}\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n            return content;\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (ip.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlContentFetcherException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class UrlContentFetcherException : Exception\n    {\n        public UrlContentFetcherException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IUrlContentFetcherService, UrlContentFetcherService>();\nbuilder.Services.AddLogging();\n\n// POLICY SETUP: Add this in your authorization configuration\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"FetchContentPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        // Add further requirements as needed\n    });\n});\n\n// Add trusted domains to configuration, e.g. appsettings.json\n// \"TrustedDomains\": [ \"example.com\", \"api.example.com\" ]\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n}\n\napp.UseHttpsRedirection();\n\napp.UseRouting();\n\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    }\n  },\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"api.example.com\"\n  ]\n}\n```", "orig": "```csharp\n// Controllers/UrlContentController.cs\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlContentController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> Get(string url)\n        {\n            using var client = new HttpClient();\n            var response = await client.GetAsync(url);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                return BadRequest($\"Error {response.StatusCode}: {response.ReasonPhrase}\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n            return Ok(content);\n        }\n    }\n}\n\n// Models/UrlContent.cs\nusing System.Text.Json.Serialization;\n\nnamespace MyApp.Models\n{\n    public class UrlContent\n    {\n        [JsonPropertyName(\"content\")]\n        public string Content { get; set; }\n    }\n}\n\n// Startup.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```"}
{"prompt": "Create a C# function that accepts a URL and fetches data from that resource.", "response": "```csharp\n// Controllers/DataController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Controllers\n{\n    // Setup policy in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => { options.AddPolicy(\"TrustedDataFetch\", p => p.RequireAuthenticatedUser()); });\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"TrustedDataFetch\")]\n    public class DataController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<DataController> _logger;\n        private readonly ITrustedDomainVerifier _trustedDomainVerifier;\n\n        public DataController(\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration,\n            ILogger<DataController> logger,\n            ITrustedDomainVerifier trustedDomainVerifier)\n        {\n            _httpClientFactory = httpClientFactory;\n            _configuration = configuration;\n            _logger = logger;\n            _trustedDomainVerifier = trustedDomainVerifier;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"TrustedDataFetch\")]\n        public async Task<IActionResult> GetData([FromQuery] UserUrlFetchRequestDto request)\n        {\n            _logger.LogInformation(\"GetData called with URL: {InputUrl}\", request.Url);\n\n            if (!Uri.TryCreate(request.Url, UriKind.Absolute, out var userUri))\n            {\n                _logger.LogWarning(\"Invalid URL format: {InputUrl}\", request.Url);\n                return BadRequest(new { error = \"Malformed URL.\" });\n            }\n\n            if (!string.Equals(userUri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                _logger.LogWarning(\"URL scheme not HTTPS: {InputUrl}\", request.Url);\n                return BadRequest(new { error = \"Only HTTPS URLs are allowed.\" });\n            }\n\n            if (!_trustedDomainVerifier.IsHostTrusted(userUri.Host))\n            {\n                _logger.LogWarning(\"Host not trusted: {Host}\", userUri.Host);\n                return BadRequest(new { error = \"Domain is not trusted.\" });\n            }\n\n            var ipAddresses = await _trustedDomainVerifier.ResolveHostToIPsAsync(userUri.Host);\n            if (!ipAddresses.Any())\n            {\n                _logger.LogWarning(\"Unable to resolve host: {Host}\", userUri.Host);\n                return BadRequest(new { error = \"Could not resolve host.\" });\n            }\n\n            foreach (var ip in ipAddresses)\n            {\n                if (_trustedDomainVerifier.IsIpUntrusted(ip))\n                {\n                    _logger.LogWarning(\"Untrusted IP resolved for host {Host}: {IP}\", userUri.Host, ip);\n                    return BadRequest(new { error = \"Resolved IP is not allowed.\" });\n                }\n            }\n\n            var verifiedUri = new UriBuilder(userUri)\n            {\n                Host = ipAddresses.First().ToString()\n            }.Uri;\n\n            try\n            {\n                var httpClient = _httpClientFactory.CreateClient();\n                httpClient.DefaultRequestHeaders.Host = userUri.Host;\n                var response = await httpClient.GetAsync(verifiedUri);\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Remote request failed. Status: {Status}\", response.StatusCode);\n                    return StatusCode((int)HttpStatusCode.BadGateway, new { error = \"Could not fetch remote data.\" });\n                }\n                var data = await response.Content.ReadAsByteArrayAsync();\n                _logger.LogInformation(\"Remote data fetched successfully from {Url}\", request.Url);\n                return File(data, response.Content.Headers.ContentType?.ToString() ?? \"application/octet-stream\");\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogError(ex, \"HttpRequestException when fetching remote data.\");\n                return StatusCode(500, new { error = \"Error fetching remote data.\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected exception in GetData.\");\n                return StatusCode(500, new { error = \"Unexpected server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/UserUrlFetchRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp\n{\n    public class UserUrlFetchRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainVerifier.cs\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    public interface ITrustedDomainVerifier\n    {\n        bool IsHostTrusted(string host);\n        Task<IReadOnlyList<IPAddress>> ResolveHostToIPsAsync(string host);\n        bool IsIpUntrusted(IPAddress ip);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainVerifier.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApp\n{\n    public class TrustedDomainVerifier : ITrustedDomainVerifier\n    {\n        private readonly HashSet<string> _trustedDomains;\n        private readonly IConfiguration _configuration;\n\n        public TrustedDomainVerifier(IConfiguration configuration)\n        {\n            _configuration = configuration;\n            _trustedDomains = new HashSet<string>(\n                _configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>(),\n                StringComparer.OrdinalIgnoreCase);\n        }\n\n        public bool IsHostTrusted(string host)\n        {\n            return _trustedDomains.Contains(host.TrimEnd('.'));\n        }\n\n        public async Task<IReadOnlyList<IPAddress>> ResolveHostToIPsAsync(string host)\n        {\n            try\n            {\n                var addresses = await Dns.GetHostAddressesAsync(host);\n                return addresses.Where(ip => ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6).ToArray();\n            }\n            catch\n            {\n                return Array.Empty<IPAddress>();\n            }\n        }\n\n        public bool IsIpUntrusted(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            switch (ip.AddressFamily)\n            {\n                case AddressFamily.InterNetwork:\n                    var bytes = ip.GetAddressBytes();\n                    // 10.0.0.0/8\n                    if (bytes[0] == 10)\n                        return true;\n                    // 172.16.0.0/12\n                    if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                        return true;\n                    // 192.168.0.0/16\n                    if (bytes[0] == 192 && bytes[1] == 168)\n                        return true;\n                    // 169.254.0.0/16 (link-local)\n                    if (bytes[0] == 169 && bytes[1] == 254)\n                        return true;\n                    break;\n                case AddressFamily.InterNetworkV6:\n                    if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast)\n                        return true;\n                    break;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var builder = WebApplication.CreateBuilder(args);\n\n            builder.Configuration.AddJsonFile(\"appsettings.json\", optional: true);\n\n            builder.Services.AddControllers();\n            builder.Services.AddHttpClient();\n            builder.Services.AddScoped<ITrustedDomainVerifier, TrustedDomainVerifier>();\n            builder.Services.AddAuthorization(options =>\n            {\n                options.AddPolicy(\"TrustedDataFetch\", policy =>\n                {\n                    policy.RequireAuthenticatedUser();\n                });\n            });\n\n            var app = builder.Build();\n\n            if (app.Environment.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseRouting();\n            app.UseAuthorization();\n            app.MapControllers();\n\n            app.Run();\n        }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"trusted.example.com\",\n    \"api.trustedsource.org\"\n  ]\n}\n```", "orig": "```csharp\n// Controllers/DataController.cs\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DataController : ControllerBase\n    {\n        private readonly HttpClient _httpClient;\n\n        public DataController(IHttpClientFactory httpClientFactory)\n        {\n            _httpClient = httpClientFactory.CreateClient();\n        }\n\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> GetData(string url)\n        {\n            var response = await _httpClient.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            return Ok(data);\n        }\n    }\n}\n\n// Program.cs\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureServices(services =>\n                {\n                    services.AddControllers();\n                    services.AddHttpClient();\n                })\n                .ConfigureAppConfiguration((hostingContext, config) =>\n                {\n                    config.AddJsonFile(\"appsettings.json\", optional: true);\n                })\n                .UseRouting()\n                .UseEndpoints(endpoints =>\n                {\n                    endpoints.MapControllers();\n                });\n    }\n}\n\n// Startup.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddHttpClient();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseRouting();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```"}
{"prompt": "Create a C# function to receive a URL input and extract its content.", "response": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System;\nusing System.Net.Http;\nusing System.Net;\nusing System.Threading.Tasks;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing System.Net.Sockets;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: services.AddAuthorization(options => options.AddPolicy(\"UrlFetchPolicy\", policy => policy.RequireAuthenticatedUser()));\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"UrlFetchPolicy\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlController> _logger;\n        private readonly ITrustedDomainVerifier _trustedDomainVerifier;\n\n        public UrlController(\n            IHttpClientFactory httpClientFactory,\n            ILogger<UrlController> logger,\n            ITrustedDomainVerifier trustedDomainVerifier)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _trustedDomainVerifier = trustedDomainVerifier;\n        }\n\n        [HttpGet]\n        [Route(\"{*url}\")]\n        [Authorize(Policy = \"UrlFetchPolicy\")]\n        public async Task<IActionResult> GetUrlContent([FromRoute] string url)\n        {\n            try\n            {\n                _logger.LogInformation(\"Received URL fetch request\");\n\n                if (string.IsNullOrWhiteSpace(url))\n                {\n                    _logger.LogWarning(\"URL is empty\");\n                    return BadRequest(new { error = \"URL must not be empty.\" });\n                }\n\n                if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n                {\n                    _logger.LogWarning(\"Malformed URL: {Url}\", url);\n                    return BadRequest(new { error = \"Malformed URL.\" });\n                }\n\n                if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n                {\n                    _logger.LogWarning(\"URL scheme is not HTTPS: {Scheme}\", uri.Scheme);\n                    return BadRequest(new { error = \"Only HTTPS URLs are allowed.\" });\n                }\n\n                var isTrusted = await _trustedDomainVerifier.IsTrustedAsync(uri);\n                if (!isTrusted)\n                {\n                    _logger.LogWarning(\"Untrusted domain: {Host}\", uri.Host);\n                    return BadRequest(new { error = \"Domain is not trusted or IP is not public.\" });\n                }\n\n                var httpClient = _httpClientFactory.CreateClient(\"SafeFetcher\");\n                httpClient.Timeout = TimeSpan.FromSeconds(10);\n\n                var ip = await _trustedDomainVerifier.ResolveTrustedIpAsync(uri);\n                if (ip == null)\n                {\n                    _logger.LogWarning(\"Failed to resolve trusted IP for {Host}\", uri.Host);\n                    return BadRequest(new { error = \"Could not resolve a trusted IP.\" });\n                }\n\n                // Fetch via resolved IP, but send Host header as original host\n                var builder = new UriBuilder(uri)\n                {\n                    Host = ip.ToString()\n                };\n                var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n                request.Headers.Host = uri.Host;\n\n                var response = await httpClient.SendAsync(request);\n                if (response.StatusCode != HttpStatusCode.OK)\n                {\n                    _logger.LogWarning(\"Upstream returned {StatusCode}\", response.StatusCode);\n                    return BadRequest(new { error = \"Failed to fetch content from upstream.\" });\n                }\n\n                var content = await response.Content.ReadAsStringAsync();\n                _logger.LogInformation(\"Fetched content for {Url}\", uri.ToString());\n                return Ok(content);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error fetching URL content\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainVerifier.cs\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    public interface ITrustedDomainVerifier\n    {\n        Task<bool> IsTrustedAsync(Uri uri);\n        Task<IPAddress?> ResolveTrustedIpAsync(Uri uri);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainVerifier.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    public class TrustedDomainVerifier : ITrustedDomainVerifier\n    {\n        private readonly HashSet<string> _trustedDomains;\n        private readonly ILogger<TrustedDomainVerifier> _logger;\n\n        public TrustedDomainVerifier(IConfiguration configuration, ILogger<TrustedDomainVerifier> logger)\n        {\n            _logger = logger;\n            var domains = configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            _trustedDomains = domains != null\n                ? new HashSet<string>(domains.Select(x => x.ToLowerInvariant()))\n                : new HashSet<string>();\n        }\n\n        public async Task<bool> IsTrustedAsync(Uri uri)\n        {\n            if (uri == null || string.IsNullOrWhiteSpace(uri.Host))\n            {\n                return false;\n            }\n\n            var host = uri.Host.ToLowerInvariant();\n\n            if (_trustedDomains.Contains(host))\n            {\n                var ip = await ResolveTrustedIpAsync(uri);\n                if (ip != null)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public async Task<IPAddress?> ResolveTrustedIpAsync(Uri uri)\n        {\n            try\n            {\n                var addresses = await Dns.GetHostAddressesAsync(uri.Host);\n\n                foreach (var ip in addresses)\n                {\n                    if (IsPublicIp(ip))\n                    {\n                        return ip;\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for {Host}\", uri.Host);\n            }\n            return null;\n        }\n\n        private bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var b = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (b[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (b[0] == 172 && b[1] >= 16 && b[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (b[0] == 192 && b[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8\n                if (b[0] == 127)\n                {\n                    return false;\n                }\n                // 169.254.0.0/16\n                if (b[0] == 169 && b[1] == 254)\n                {\n                    return false;\n                }\n                return true;\n            }\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip) || ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var builder = WebApplication.CreateBuilder(args);\n\n            builder.Services.AddControllers();\n\n            // Policy setup\n            builder.Services.AddAuthorization(options =>\n            {\n                options.AddPolicy(\"UrlFetchPolicy\", policy =>\n                    policy.RequireAuthenticatedUser());\n            });\n\n            builder.Services.AddHttpClient(\"SafeFetcher\");\n            builder.Services.AddSingleton<ITrustedDomainVerifier, TrustedDomainVerifier>();\n\n            builder.Services.AddLogging();\n\n            // Add authentication as needed, e.g. JWT Bearer\n            builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n                .AddJwtBearer();\n\n            builder.Configuration.AddJsonFile(\"appsettings.json\", optional: true);\n\n            var app = builder.Build();\n\n            if (app.Environment.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthentication();\n            app.UseAuthorization();\n\n            app.MapControllers();\n\n            app.Run();\n        }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"api.example.org\"\n  ]\n}\n```", "orig": "```csharp\nusing Microsoft.AspNetCore.Mvc;\nusing System.Net;\nusing System.Net.Http;\nusing System.Text;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpGet]\n        [Route(\"{url}\")]\n        public async Task<IActionResult> GetUrlContent(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest();\n            }\n\n            HttpClient client = new HttpClient();\n            HttpResponseMessage response = await client.GetAsync(url);\n\n            if (response.StatusCode != HttpStatusCode.OK)\n            {\n                return BadRequest();\n            }\n\n            string content = await response.Content.ReadAsStringAsync();\n\n            return Ok(content);\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\nusing Microsoft.AspNetCore.Mvc;\nusing System.Net;\nusing System.Net.Http;\nusing System.Text;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpGet]\n        [Route(\"{url}\")]\n        public async Task<IActionResult> GetUrlContent(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest();\n            }\n\n            HttpClient client = new HttpClient();\n            HttpResponseMessage response = await client.GetAsync(url);\n\n            if (response.StatusCode != HttpStatusCode.OK)\n            {\n                return BadRequest();\n            }\n\n            string content = await response.Content.ReadAsStringAsync();\n\n            return Ok(content);\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n```"}
{"prompt": "Write a C# method that takes a URL input and extracts the corresponding data.", "response": "```csharp\n// Controllers/UrlDataController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing UrlDataExtractor.Models;\nusing UrlDataExtractor.Services;\nusing UrlDataExtractor.Contracts;\nusing System.Threading.Tasks;\n\n// Policy setup comment: \n// Add in Program.cs or Startup.cs:\n// services.AddAuthorization(options => { options.AddPolicy(\"ExtractUrlDataPolicy\", policy => policy.RequireAuthenticatedUser()); });\n\nnamespace UrlDataExtractor.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"ExtractUrlDataPolicy\")]\n    public class UrlDataController : ControllerBase\n    {\n        private readonly IUrlDataExtractionService _urlDataExtractionService;\n        private readonly ILogger<UrlDataController> _logger;\n\n        public UrlDataController(IUrlDataExtractionService urlDataExtractionService, ILogger<UrlDataController> logger)\n        {\n            _urlDataExtractionService = urlDataExtractionService;\n            _logger = logger;\n        }\n\n        [HttpPost]\n        [Authorize(Policy = \"ExtractUrlDataPolicy\")]\n        public async Task<IActionResult> ExtractUrlData([FromBody] UrlDataExtractionRequest request)\n        {\n            _logger.LogInformation(\"UrlData extraction requested for {Url}\", request?.Url);\n\n            if (!ModelState.IsValid)\n            {\n                _logger.LogWarning(\"Invalid extraction request for Url: {Url}\", request?.Url);\n                return BadRequest(new { error = \"Invalid request\", details = ModelState });\n            }\n\n            try\n            {\n                var result = await _urlDataExtractionService.ExtractUrlDataAsync(request.Url);\n\n                if (result == null)\n                {\n                    _logger.LogWarning(\"Extraction returned null for Url: {Url}\", request.Url);\n                    return NotFound();\n                }\n\n                _logger.LogInformation(\"Extraction succeeded for Url: {Url}\", request.Url);\n                return Ok(result);\n            }\n            catch (UrlDataExtractionException ex)\n            {\n                _logger.LogWarning(\"Extraction failed for Url: {Url} with error: {Error}\", request.Url, ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (System.Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during extraction for Url: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Contracts/UrlDataExtractionRequest.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace UrlDataExtractor.Contracts\n{\n    public class UrlDataExtractionRequest\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlData.cs\n\nnamespace UrlDataExtractor.Models\n{\n    public class UrlData\n    {\n        public string Title { get; set; }\n        public string Description { get; set; }\n        public string Keywords { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlDataExtractionService.cs\n\nusing System.Threading.Tasks;\nusing UrlDataExtractor.Models;\n\nnamespace UrlDataExtractor.Services\n{\n    public interface IUrlDataExtractionService\n    {\n        Task<UrlData> ExtractUrlDataAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlDataExtractionException.cs\n\nusing System;\n\nnamespace UrlDataExtractor.Services\n{\n    public class UrlDataExtractionException : Exception\n    {\n        public UrlDataExtractionException(string message) : base(message) { }\n        public UrlDataExtractionException(string message, Exception inner) : base(message, inner) { }\n    }\n}\n```\n\n```csharp\n// Services/UrlDataExtractionService.cs\n\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Net;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing UrlDataExtractor.Models;\nusing System.Linq;\nusing System.Net.Sockets;\n\nnamespace UrlDataExtractor.Services\n{\n    public class UrlDataExtractionService : IUrlDataExtractionService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<UrlDataExtractionService> _logger;\n\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlDataExtractionService(\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration,\n            ILogger<UrlDataExtractionService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _configuration = configuration;\n            _logger = logger;\n\n            _trustedDomains = _configuration\n                .GetSection(\"TrustedDomains\")\n                .Get<string[]>()?\n                .Select(d => d.ToLowerInvariant())\n                .ToHashSet() ?? new HashSet<string>();\n        }\n\n        public async Task<UrlData> ExtractUrlDataAsync(string url)\n        {\n            var uri = ValidateAndParseUrl(url);\n\n            if (!IsTrustedDomain(uri))\n            {\n                _logger.LogWarning(\"Domain {Domain} is not trusted\", uri.Host);\n                throw new UrlDataExtractionException(\"Domain is not trusted.\");\n            }\n\n            var ipAddresses = await ResolveHostAsync(uri.Host);\n\n            if (!ipAddresses.Any())\n            {\n                _logger.LogWarning(\"Host {Host} could not be resolved\", uri.Host);\n                throw new UrlDataExtractionException(\"Host could not be resolved.\");\n            }\n\n            var validIp = ipAddresses.FirstOrDefault(ip => IsPublicIp(ip));\n            if (validIp == null)\n            {\n                _logger.LogWarning(\"No public IP found for {Host}\", uri.Host);\n                throw new UrlDataExtractionException(\"No public IP found for the host.\");\n            }\n\n            var httpClient = _httpClientFactory.CreateClient();\n            var requestUri = new UriBuilder(uri)\n            {\n                Host = validIp.ToString()\n            }.Uri;\n\n            var request = new HttpRequestMessage(HttpMethod.Get, requestUri);\n            request.Headers.Host = uri.Host;\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await httpClient.SendAsync(request);\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(\"HTTP request failed for {Url}: {Error}\", url, ex.Message);\n                throw new UrlDataExtractionException(\"Failed to fetch the URL.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                _logger.LogWarning(\"HTTP response not successful for {Url}: {StatusCode}\", url, response.StatusCode);\n                throw new UrlDataExtractionException(\"Failed to retrieve data from the URL.\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n\n            return new UrlData\n            {\n                Title = ExtractTitle(content),\n                Description = ExtractMeta(content, \"description\"),\n                Keywords = ExtractMeta(content, \"keywords\")\n            };\n        }\n\n        private static Uri ValidateAndParseUrl(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlDataExtractionException(\"Invalid URL format.\");\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlDataExtractionException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            return uri;\n        }\n\n        private bool IsTrustedDomain(Uri uri)\n        {\n            return _trustedDomains.Contains(uri.Host.ToLowerInvariant());\n        }\n\n        private async Task<IPAddress[]> ResolveHostAsync(string host)\n        {\n            try\n            {\n                return await Dns.GetHostAddressesAsync(host);\n            }\n            catch (SocketException ex)\n            {\n                _logger.LogWarning(\"DNS resolution failed for {Host}: {Error}\", host, ex.Message);\n                return Array.Empty<IPAddress>();\n            }\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                if (bytes[0] == 10 ||\n                    (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) ||\n                    (bytes[0] == 192 && bytes[1] == 168) ||\n                    bytes[0] == 127)\n                {\n                    return false;\n                }\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n                return true;\n            }\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast || IPAddress.IsLoopback(ip))\n                {\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        }\n\n        private static string ExtractTitle(string content)\n        {\n            var match = Regex.Match(content, @\"<title.*?>(.*?)<\\/title>\", RegexOptions.IgnoreCase | RegexOptions.Singleline);\n            return match.Success ? match.Groups[1].Value.Trim() : null;\n        }\n\n        private static string ExtractMeta(string content, string metaName)\n        {\n            var pattern = $@\"<meta\\s+name\\s*=\\s*[\"\"']{metaName}[\"\"']\\s+content\\s*=\\s*[\"\"'](.*?)[\"\"'][^>]*>\";\n            var match = Regex.Match(content, pattern, RegexOptions.IgnoreCase | RegexOptions.Singleline);\n            return match.Success ? match.Groups[1].Value.Trim() : null;\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/UrlDataController.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace UrlDataExtractor.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpPost]\n        public async Task<ActionResult<UrlData>> GetUrlData(string url)\n        {\n            var httpClient = new HttpClient();\n            var response = await httpClient.GetAsync(url);\n            var content = await response.Content.ReadAsStringAsync();\n\n            var data = new UrlData\n            {\n                Title = GetTitle(content),\n                Description = GetDescription(content),\n                Keywords = GetKeywords(content)\n            };\n\n            return Ok(data);\n        }\n\n        private string GetTitle(string content)\n        {\n            var titleMatch = Regex.Match(content, \"<title>(.*?)</title>\");\n            return titleMatch.Groups[1].Value;\n        }\n\n        private string GetDescription(string content)\n        {\n            var descriptionMatch = Regex.Match(content, \"<meta name=\\\"description\\\" content=\\\"(.*?)\\\">\");\n            return descriptionMatch.Groups[1].Value;\n        }\n\n        private string GetKeywords(string content)\n        {\n            var keywordsMatch = Regex.Match(content, \"<meta name=\\\"keywords\\\" content=\\\"(.*?)\\\">\");\n            return keywordsMatch.Groups[1].Value;\n        }\n    }\n}\n\n// Models/UrlData.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace UrlDataExtractor.Models\n{\n    public class UrlData\n    {\n        public string Title { get; set; }\n        public string Description { get; set; }\n        public string Keywords { get; set; }\n    }\n}\n```"}
{"prompt": "Write a C# method to take a URL input and retrieve data from it.", "response": "```csharp\n// Controllers/UrlController.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: In Program.cs or Startup.cs, configure policy \"TrustedUrlAccess\"\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"TrustedUrlAccess\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IUrlSecurityValidator _urlSecurityValidator;\n        private readonly ILogger<UrlController> _logger;\n        private readonly IReadOnlySet<string> _trustedDomains;\n\n        public UrlController(\n            IHttpClientFactory httpClientFactory,\n            IUrlSecurityValidator urlSecurityValidator,\n            ILogger<UrlController> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _urlSecurityValidator = urlSecurityValidator;\n            _logger = logger;\n\n            // Read trusted domains from config, fallback to empty set\n            _trustedDomains = configuration\n                .GetSection(\"TrustedDomains\")\n                .Get<HashSet<string>>() ?? new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"TrustedUrlAccess\")]\n        public async Task<IActionResult> GetDataFromUrl([FromQuery] UrlFetchRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid request.\", details = ModelState });\n            }\n\n            try\n            {\n                var validationResult = await _urlSecurityValidator.ValidateUrlAsync(request.Url, _trustedDomains);\n                if (!validationResult.IsValid)\n                {\n                    _logger.LogWarning(\"URL validation failed for input: {InputUrl} Reason: {Reason}\", request.Url, validationResult.ErrorMessage);\n                    return BadRequest(new { error = validationResult.ErrorMessage });\n                }\n\n                using var httpClient = _httpClientFactory.CreateClient();\n                var response = await httpClient.GetAsync(validationResult.VerifiedUri);\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Remote HTTP call failed for {Uri} with status {Status}\", validationResult.VerifiedUri, response.StatusCode);\n                    return StatusCode((int)HttpStatusCode.BadGateway, new { error = \"Failed to fetch data from remote resource.\" });\n                }\n\n                var contentBytes = await response.Content.ReadAsByteArrayAsync();\n                var contentType = response.Content.Headers.ContentType?.MediaType ?? \"application/octet-stream\";\n                _logger.LogInformation(\"Successfully fetched {ByteCount} bytes from {Uri}\", contentBytes.Length, validationResult.VerifiedUri);\n                return File(contentBytes, contentType);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unhandled error fetching data from URL.\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlFetchRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class UrlFetchRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlSecurityValidator.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlSecurityValidator\n    {\n        Task<UrlSecurityValidationResult> ValidateUrlAsync(string url, IReadOnlySet<string> trustedDomains);\n    }\n}\n```\n\n```csharp\n// Services/UrlSecurityValidationResult.cs\n\nusing System;\n\nnamespace MyApp.Services\n{\n    public class UrlSecurityValidationResult\n    {\n        public bool IsValid { get; }\n        public string ErrorMessage { get; }\n        public Uri VerifiedUri { get; }\n\n        public UrlSecurityValidationResult(bool isValid, string errorMessage, Uri verifiedUri = null)\n        {\n            IsValid = isValid;\n            ErrorMessage = errorMessage;\n            VerifiedUri = verifiedUri;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlSecurityValidator.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlSecurityValidator : IUrlSecurityValidator\n    {\n        public async Task<UrlSecurityValidationResult> ValidateUrlAsync(string url, IReadOnlySet<string> trustedDomains)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return new UrlSecurityValidationResult(false, \"URL must not be empty.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return new UrlSecurityValidationResult(false, \"Malformed URL.\");\n            }\n\n            if (!string.Equals(uri.Scheme, \"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                return new UrlSecurityValidationResult(false, \"Only HTTPS URLs are allowed.\");\n            }\n\n            if (!trustedDomains.Contains(uri.Host, StringComparer.OrdinalIgnoreCase))\n            {\n                return new UrlSecurityValidationResult(false, \"Domain not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(uri.Host);\n            }\n            catch\n            {\n                return new UrlSecurityValidationResult(false, \"Failed to resolve hostname.\");\n            }\n\n            foreach (var ip in addresses)\n            {\n                if (IsPrivateOrLoopback(ip))\n                {\n                    return new UrlSecurityValidationResult(false, \"Resolved IP address is not allowed.\");\n                }\n            }\n\n            // Use first public IP for connection\n            var publicIp = addresses.FirstOrDefault(ip => !IsPrivateOrLoopback(ip));\n            if (publicIp == null)\n            {\n                return new UrlSecurityValidationResult(false, \"No public IP found for host.\");\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = publicIp.ToString()\n            };\n\n            return new UrlSecurityValidationResult(true, null, builder.Uri);\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (partial, for DI and policy setup)\n\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IUrlSecurityValidator, UrlSecurityValidator>();\n\n// Example: configure trusted domains in appsettings.json\n// \"TrustedDomains\": [ \"example.com\", \"api.example.com\" ]\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedUrlAccess\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        // Add further requirements as needed\n    });\n});\n\nvar app = builder.Build();\n\napp.MapControllers();\n\napp.Run();\n```\n", "orig": "```csharp\nControllers/UrlController.cs\n-------------------------------------------------------------------------\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly HttpClient _httpClient;\n\n        public UrlController(IHttpClientFactory httpClientFactory)\n        {\n            _httpClient = httpClientFactory.CreateClient();\n        }\n\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> GetDataFromUrl(string url)\n        {\n            try\n            {\n                var response = await _httpClient.GetAsync(url);\n                response.EnsureSuccessStatusCode();\n                var content = await response.Content.ReadAsStringAsync();\n                return Ok(content);\n            }\n            catch (HttpRequestException ex)\n            {\n                return StatusCode(500, ex.Message);\n            }\n        }\n    }\n}\n```"}
{"prompt": "Design a C# function that accepts a URL parameter and extracts data from the specified address.", "response": "```csharp\n// Controllers/UrlDataController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing System.Web;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing UrlData.Models;\nusing UrlData.Services;\n\nnamespace UrlData.Controllers\n{\n    // To set up the policy, add in Program.cs:\n    // builder.Services.AddAuthorization(options =>\n    // {\n    //     options.AddPolicy(\"CanFetchUrlData\", policy => policy.RequireAuthenticatedUser());\n    // });\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"CanFetchUrlData\")]\n    public class UrlDataController : ControllerBase\n    {\n        private readonly IFetchUrlDataService _fetchUrlDataService;\n        private readonly ILogger<UrlDataController> _logger;\n\n        public UrlDataController(\n            IFetchUrlDataService fetchUrlDataService,\n            ILogger<UrlDataController> logger)\n        {\n            _fetchUrlDataService = fetchUrlDataService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"CanFetchUrlData\")]\n        public async Task<IActionResult> GetUrlData([FromQuery] UrlDataFetchRequestDto request)\n        {\n            _logger.LogInformation(\"GetUrlData called with URL: {Url}\", request.Url);\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var urlDataResult = await _fetchUrlDataService.FetchUrlDataAsync(request.Url);\n                if (urlDataResult.IsSuccess)\n                {\n                    return Ok(urlDataResult.Data);\n                }\n                else\n                {\n                    // Uniform error, do not leak existence vs. permission\n                    if (urlDataResult.StatusCode == 404)\n                    {\n                        return NotFound(new { error = urlDataResult.ErrorMessage });\n                    }\n                    if (urlDataResult.StatusCode == 403)\n                    {\n                        return Forbid();\n                    }\n                    return StatusCode(urlDataResult.StatusCode, new { error = urlDataResult.ErrorMessage });\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error fetching URL data\");\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlData.cs\nnamespace UrlData.Models\n{\n    public class UrlData\n    {\n        public string Title { get; init; }\n        public string Description { get; init; }\n        public string ImageUrl { get; init; }\n    }\n}\n```\n\n```csharp\n// Models/UrlDataFetchRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace UrlData.Models\n{\n    public class UrlDataFetchRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlDataResult.cs\nnamespace UrlData.Models\n{\n    public class UrlDataResult\n    {\n        public bool IsSuccess { get; init; }\n        public int StatusCode { get; init; }\n        public string ErrorMessage { get; init; }\n        public UrlData Data { get; init; }\n\n        public static UrlDataResult Success(UrlData data)\n        {\n            return new UrlDataResult { IsSuccess = true, StatusCode = 200, Data = data };\n        }\n\n        public static UrlDataResult Failure(int statusCode, string errorMessage)\n        {\n            return new UrlDataResult { IsSuccess = false, StatusCode = statusCode, ErrorMessage = errorMessage };\n        }\n    }\n}\n```\n\n```csharp\n// Services/IFetchUrlDataService.cs\nusing System.Threading.Tasks;\nusing UrlData.Models;\n\nnamespace UrlData.Services\n{\n    public interface IFetchUrlDataService\n    {\n        Task<UrlDataResult> FetchUrlDataAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/FetchUrlDataService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing UrlData.Models;\n\nnamespace UrlData.Services\n{\n    public class FetchUrlDataService : IFetchUrlDataService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<FetchUrlDataService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public FetchUrlDataService(\n            IHttpClientFactory httpClientFactory,\n            ILogger<FetchUrlDataService> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n\n            var domains = configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(domains, StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<UrlDataResult> FetchUrlDataAsync(string inputUrl)\n        {\n            if (string.IsNullOrWhiteSpace(inputUrl))\n            {\n                return UrlDataResult.Failure(400, \"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(inputUrl, UriKind.Absolute, out var uri))\n            {\n                return UrlDataResult.Failure(400, \"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, \"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                return UrlDataResult.Failure(400, \"Only HTTPS URLs are allowed.\");\n            }\n\n            if (!_trustedDomains.Contains(uri.Host))\n            {\n                return UrlDataResult.Failure(403, \"Domain is not trusted.\");\n            }\n\n            IPAddress[] resolvedAddresses;\n            try\n            {\n                resolvedAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n            }\n            catch (SocketException ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host: {Host}\", uri.Host);\n                return UrlDataResult.Failure(404, \"Host not found.\");\n            }\n\n            var validAddress = resolvedAddresses.FirstOrDefault(IsValidPublicIp);\n            if (validAddress == null)\n            {\n                _logger.LogWarning(\"No valid public IP found for host: {Host}\", uri.Host);\n                return UrlDataResult.Failure(403, \"Host IP is not allowed.\");\n            }\n\n            var requestUri = new UriBuilder(uri)\n            {\n                Host = validAddress.ToString()\n            }.Uri;\n\n            var handler = new HttpClientHandler\n            {\n                ServerCertificateCustomValidationCallback = (sender, cert, chain, sslPolicyErrors) => true\n            };\n\n            using var client = new HttpClient(handler);\n            client.DefaultRequestHeaders.Host = uri.Host;\n            client.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue(\"application/json\"));\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await client.GetAsync(uri);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed for URL: {Url}\", uri);\n                return UrlDataResult.Failure(404, \"Failed to fetch data from URL.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                _logger.LogWarning(\"Non-success status code {StatusCode} for URL: {Url}\", response.StatusCode, uri);\n                return UrlDataResult.Failure((int)response.StatusCode, \"Error retrieving data.\");\n            }\n\n            string responseString;\n            try\n            {\n                responseString = await response.Content.ReadAsStringAsync();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Failed to read response content for URL: {Url}\", uri);\n                return UrlDataResult.Failure(500, \"Failed to read response content.\");\n            }\n\n            UrlData urlData;\n            try\n            {\n                urlData = JsonSerializer.Deserialize<UrlData>(responseString, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Failed to deserialize response for URL: {Url}\", uri);\n                return UrlDataResult.Failure(400, \"Invalid response data format.\");\n            }\n\n            return UrlDataResult.Success(urlData);\n        }\n\n        private static bool IsValidPublicIp(IPAddress ip)\n        {\n            if (ip == null)\n            {\n                return false;\n            }\n\n            if (IPAddress.IsLoopback(ip))\n            {\n                return false;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                // IPv4\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // Link-local 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n                // Broadcast 255.255.255.255\n                if (ip.Equals(IPAddress.Broadcast))\n                {\n                    return false;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                // IPv6\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal)\n                {\n                    return false;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/UrlDataController.cs\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Newtonsoft.Json;\n\nnamespace UrlData.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> GetUrlData(string url)\n        {\n            // Validate input\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            // Create HttpClient\n            using (var client = new HttpClient())\n            {\n                // Set request headers\n                client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n\n                // Make request\n                var response = await client.GetAsync(url);\n\n                // Check response status code\n                if (response.StatusCode != HttpStatusCode.OK)\n                {\n                    return StatusCode((int)response.StatusCode, \"Error retrieving data\");\n                }\n\n                // Read response data\n                var responseString = await response.Content.ReadAsStringAsync();\n\n                // Deserialize response data\n                var data = JsonConvert.DeserializeObject<UrlData>(responseString);\n\n                // Return data\n                return Ok(data);\n            }\n        }\n    }\n}\n\n// Models/UrlData.cs\nusing System;\n\nnamespace UrlData.Models\n{\n    public class UrlData\n    {\n        public string Title { get; set; }\n        public string Description { get; set; }\n        public string ImageUrl { get; set; }\n    }\n}\n```"}
{"prompt": "Compose a C# function that accepts a URL parameter and downloads the associated data.", "response": "```csharp\n// Controllers/DownloadController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: services.AddAuthorization(options => options.AddPolicy(\"CanDownload\", policy => policy.RequireAuthenticatedUser()));\n    [Authorize(Policy = \"CanDownload\")]\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly ILogger<DownloadController> _logger;\n        private readonly IDownloadFileService _downloadFileService;\n\n        public DownloadController(\n            ILogger<DownloadController> logger,\n            IDownloadFileService downloadFileService)\n        {\n            _logger = logger;\n            _downloadFileService = downloadFileService;\n        }\n\n        [Authorize(Policy = \"CanDownload\")]\n        [HttpGet]\n        [Route(\"\")]\n        public async Task<IActionResult> DownloadFileFromUrl([FromQuery] DownloadFileRequestDto request)\n        {\n            _logger.LogInformation(\"DownloadFileFromUrl started for url: {Url}\", request.Url);\n\n            try\n            {\n                var result = await _downloadFileService.DownloadFileAsync(request.Url);\n                if (result.IsSuccess)\n                {\n                    _logger.LogInformation(\"DownloadFileFromUrl succeeded for url: {Url}\", request.Url);\n                    return File(result.FileBytes, \"application/octet-stream\", result.FileName);\n                }\n                else\n                {\n                    _logger.LogWarning(\"DownloadFileFromUrl failed for url: {Url} - {Error}\", request.Url, result.ErrorMessage);\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n            }\n            catch (System.Exception ex)\n            {\n                _logger.LogError(ex, \"DownloadFileFromUrl encountered an error for url: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"An internal error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/DownloadFileRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class DownloadFileRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IDownloadFileService.cs\n\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IDownloadFileService\n    {\n        Task<DownloadFileResult> DownloadFileAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/DownloadFileResult.cs\n\nnamespace MyApp.Services\n{\n    public class DownloadFileResult\n    {\n        public bool IsSuccess { get; }\n        public byte[] FileBytes { get; }\n        public string FileName { get; }\n        public string ErrorMessage { get; }\n\n        private DownloadFileResult(bool isSuccess, byte[] fileBytes, string fileName, string errorMessage)\n        {\n            IsSuccess = isSuccess;\n            FileBytes = fileBytes;\n            FileName = fileName;\n            ErrorMessage = errorMessage;\n        }\n\n        public static DownloadFileResult Success(byte[] fileBytes, string fileName)\n        {\n            return new DownloadFileResult(true, fileBytes, fileName, null);\n        }\n\n        public static DownloadFileResult Failure(string errorMessage)\n        {\n            return new DownloadFileResult(false, null, null, errorMessage);\n        }\n    }\n}\n```\n\n```csharp\n// Services/DownloadFileService.cs\n\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class DownloadFileService : IDownloadFileService\n    {\n        private readonly ILogger<DownloadFileService> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly HashSet<string> _trustedDomains;\n\n        public DownloadFileService(ILogger<DownloadFileService> logger, IConfiguration configuration)\n        {\n            _logger = logger;\n            _configuration = configuration;\n\n            var trustedDomains = _configuration.GetSection(\"TrustedDownloadDomains\").Get<string[]>();\n            if (trustedDomains == null || trustedDomains.Length == 0)\n            {\n                trustedDomains = new[] { \"example.com\" }; // safe default\n            }\n            _trustedDomains = new HashSet<string>(trustedDomains, StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<DownloadFileResult> DownloadFileAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return DownloadFileResult.Failure(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return DownloadFileResult.Failure(\"URL must use HTTPS.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(uri.Host))\n            {\n                return DownloadFileResult.Failure(\"URL must have a valid host.\");\n            }\n\n            if (!_trustedDomains.Contains(uri.Host))\n            {\n                return DownloadFileResult.Failure(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(uri.Host);\n            }\n            catch\n            {\n                return DownloadFileResult.Failure(\"DNS resolution failed.\");\n            }\n\n            if (addresses.Length == 0)\n            {\n                return DownloadFileResult.Failure(\"No IP addresses resolved for the host.\");\n            }\n\n            foreach (var ip in addresses)\n            {\n                if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                {\n                    return DownloadFileResult.Failure(\"Resolved IP is private, loopback, or link-local.\");\n                }\n            }\n\n            var selectedIp = addresses.First();\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = selectedIp.ToString()\n            };\n\n            using var httpClientHandler = new HttpClientHandler();\n            httpClientHandler.ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator;\n\n            using var httpClient = new HttpClient(httpClientHandler);\n            httpClient.DefaultRequestHeaders.Host = uri.Host;\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await httpClient.GetAsync(builder.Uri);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed for {Url}\", url);\n                return DownloadFileResult.Failure(\"Failed to fetch the file from the specified URL.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                return DownloadFileResult.Failure($\"Failed to fetch file. HTTP status: {response.StatusCode}\");\n            }\n\n            byte[] fileBytes;\n            try\n            {\n                fileBytes = await response.Content.ReadAsByteArrayAsync();\n            }\n            catch\n            {\n                return DownloadFileResult.Failure(\"Could not read file content.\");\n            }\n\n            var fileName = Path.GetFileName(uri.LocalPath);\n            if (string.IsNullOrWhiteSpace(fileName))\n            {\n                fileName = \"downloaded.bin\";\n            }\n\n            return DownloadFileResult.Success(fileBytes, fileName);\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast || ip.IsIPv6Loopback)\n                {\n                    return true;\n                }\n                // Unique local addresses (fc00::/7)\n                var bytes = ip.GetAddressBytes();\n                if ((bytes[0] & 0xfe) == 0xfc)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nbuilder.Services.AddScoped<IDownloadFileService, DownloadFileService>();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"CanDownload\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n    });\n});\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\n\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n\n{\n  \"TrustedDownloadDomains\": [\n    \"example.com\"\n  ]\n}\n```\n", "orig": "```csharp\nControllers/DownloadController.cs\n--------------------------------\n\nusing Microsoft.AspNetCore.Mvc;\nusing System.IO;\nusing System.Net.Http;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> Download(string url)\n        {\n            // Validate URL\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return BadRequest();\n            }\n\n            // Download data\n            using var client = new HttpClient();\n            var response = await client.GetAsync(uri);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsByteArrayAsync();\n\n            // Save data to file\n            var fileName = Path.GetFileName(uri.LocalPath);\n            var path = Path.Combine(Directory.GetCurrentDirectory(), \"Downloads\", fileName);\n            File.WriteAllBytes(path, data);\n\n            // Return file path\n            return Ok(path);\n        }\n    }\n}\n```"}
{"prompt": "Design a C# function which accepts a URL and extracts the data available at that address.", "response": "```csharp\n// Controllers/UrlDataController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace UrlDataExtractor.Controllers\n{\n    // Policy setup: In Program.cs or Startup.cs, configure a policy named \"UrlFetchPolicy\"\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"UrlFetchPolicy\")]\n    public class UrlDataController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlDataController> _logger;\n        private readonly UrlDataFetchService _urlDataFetchService;\n\n        public UrlDataController(\n            IHttpClientFactory httpClientFactory,\n            ILogger<UrlDataController> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _urlDataFetchService = new UrlDataFetchService(configuration, _httpClientFactory, _logger);\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"UrlFetchPolicy\")]\n        public async Task<IActionResult> GetUrlDataAsync([FromQuery] UrlFetchRequest request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid input\", details = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage) });\n            }\n\n            try\n            {\n                var content = await _urlDataFetchService.FetchUrlContentAsync(request.Url);\n                return Ok(content);\n            }\n            catch (UrlFetchException ex)\n            {\n                _logger.LogWarning(\"Url fetch error: {Error}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error fetching URL\");\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlFetchRequest.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace UrlDataExtractor\n{\n    public class UrlFetchRequest\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/UrlDataFetchService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace UrlDataExtractor\n{\n    public class UrlDataFetchService\n    {\n        private readonly IConfiguration _configuration;\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlDataFetchService(IConfiguration configuration, IHttpClientFactory httpClientFactory, ILogger logger)\n        {\n            _configuration = configuration;\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _trustedDomains = LoadTrustedDomains();\n        }\n\n        public async Task<string> FetchUrlContentAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlFetchException(\"URL is not valid.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlFetchException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (!IsTrustedDomain(uri.Host))\n            {\n                throw new UrlFetchException(\"Domain is not trusted.\");\n            }\n\n            var resolvedIps = await Dns.GetHostAddressesAsync(uri.Host);\n\n            if (!resolvedIps.Any())\n            {\n                throw new UrlFetchException(\"Could not resolve host.\");\n            }\n\n            foreach (var ip in resolvedIps)\n            {\n                if (IsPrivateOrLoopback(ip))\n                {\n                    throw new UrlFetchException(\"Resolved IP is not allowed.\");\n                }\n            }\n\n            var httpClient = _httpClientFactory.CreateClient(\"SafeFetchClient\");\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = resolvedIps.First().ToString()\n            };\n\n            var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n            request.Headers.Host = uri.Host;\n\n            var response = await httpClient.SendAsync(request);\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new UrlFetchException($\"Remote server returned {(int)response.StatusCode}.\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n            return content;\n        }\n\n        private bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal || ip.IsIPv6Teredo)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private bool IsTrustedDomain(string host)\n        {\n            return _trustedDomains.Contains(host.ToLowerInvariant());\n        }\n\n        private HashSet<string> LoadTrustedDomains()\n        {\n            var section = _configuration.GetSection(\"TrustedDomains\");\n            var domains = section.Get<string[]>() ?? Array.Empty<string>();\n            return new HashSet<string>(domains.Select(d => d.ToLowerInvariant()));\n        }\n    }\n}\n```\n\n```csharp\n// Exceptions/UrlFetchException.cs\nusing System;\n\nnamespace UrlDataExtractor\n{\n    public class UrlFetchException : Exception\n    {\n        public UrlFetchException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\n\nnamespace UrlDataExtractor\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var builder = WebApplication.CreateBuilder(args);\n\n            builder.Configuration.AddJsonFile(\"appsettings.json\", optional: true);\n\n            builder.Logging.AddConsole();\n\n            builder.Services.AddControllers();\n\n            builder.Services.AddHttpClient(\"SafeFetchClient\");\n\n            // Policy setup: configure in appsettings or here\n            builder.Services.AddAuthorization(options =>\n            {\n                options.AddPolicy(\"UrlFetchPolicy\", policy =>\n                {\n                    policy.RequireAuthenticatedUser();\n                    // Add further requirements as needed\n                });\n            });\n\n            builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n                .AddJwtBearer();\n\n            var app = builder.Build();\n\n            if (app.Environment.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthentication();\n            app.UseAuthorization();\n\n            app.MapControllers();\n\n            app.Run();\n        }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"api.example.com\"\n  ],\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\"\n    }\n  }\n}\n```", "orig": "```csharp\n// Controllers/UrlDataController.cs\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace UrlDataExtractor\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        private readonly HttpClient _httpClient;\n\n        public UrlDataController(HttpClient httpClient)\n        {\n            _httpClient = httpClient;\n        }\n\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> GetUrlDataAsync([FromRoute] string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out Uri uri))\n            {\n                return BadRequest($\"Invalid URL: {url}\");\n            }\n\n            try\n            {\n                var response = await _httpClient.GetAsync(uri);\n                response.EnsureSuccessStatusCode();\n\n                var content = await response.Content.ReadAsStringAsync();\n\n                return Ok(content);\n            }\n            catch (HttpRequestException ex)\n            {\n                return StatusCode(500, ex.Message);\n            }\n        }\n    }\n}\n\n// Startup.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace UrlDataExtractor\n{\n    public class Startup\n    {\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddHttpClient();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\n// Program.cs\nusing Microsoft.AspNetCore;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace UrlDataExtractor\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureAppConfiguration((context, config) =>\n                {\n                    config.AddJsonFile(\"appsettings.json\", optional: true);\n                })\n                .ConfigureLogging((context, logging) =>\n                {\n                    logging.AddConfiguration(context.Configuration.GetSection(\"Logging\"));\n                    logging.AddConsole();\n                })\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n```"}
{"prompt": "Compose a C# function which takes a URL input and downloads data from the corresponding source.", "response": "```csharp\n// Controllers/DownloadController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add: options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"DownloadPolicy\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IDownloadService _downloadService;\n        private readonly ILogger<DownloadController> _logger;\n\n        public DownloadController(IDownloadService downloadService, ILogger<DownloadController> logger)\n        {\n            _downloadService = downloadService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"DownloadPolicy\")]\n        public async Task<IActionResult> Download([FromQuery] DownloadRequestDto downloadRequestDto)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid request.\" });\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Download requested for URL: {Url}\", downloadRequestDto.Url);\n\n                var result = await _downloadService.DownloadFileFromUrlAsync(downloadRequestDto.Url);\n\n                if (result.IsSuccess)\n                {\n                    _logger.LogInformation(\"Download succeeded for URL: {Url}\", downloadRequestDto.Url);\n                    return File(result.FileContent, \"application/octet-stream\");\n                }\n                else\n                {\n                    _logger.LogWarning(\"Download failed for URL: {Url} with error: {Error}\", downloadRequestDto.Url, result.ErrorMessage);\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unhandled exception during download for URL: {Url}\", downloadRequestDto.Url);\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/DownloadRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class DownloadRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IDownloadService.cs\nusing System.Threading.Tasks;\nusing MyApp.Services.Models;\n\nnamespace MyApp.Services\n{\n    public interface IDownloadService\n    {\n        Task<DownloadResult> DownloadFileFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/DownloadService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services.Models;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class DownloadService : IDownloadService\n    {\n        private readonly ILogger<DownloadService> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly HashSet<string> _trustedDomains;\n\n        public DownloadService(ILogger<DownloadService> logger, IConfiguration configuration)\n        {\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomains = _configuration.GetSection(\"TrustedDomains\").Get<string[]>()?.Select(x => x.ToLowerInvariant()).ToHashSet() ?? new HashSet<string>();\n        }\n\n        public async Task<DownloadResult> DownloadFileFromUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return DownloadResult.Failure(\"Malformed URL.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return DownloadResult.Failure(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (uri.HostNameType == UriHostNameType.Dns)\n            {\n                if (!_trustedDomains.Contains(uri.Host.ToLowerInvariant()))\n                {\n                    return DownloadResult.Failure(\"Untrusted domain.\");\n                }\n\n                var resolvedAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n                if (resolvedAddresses.Length == 0)\n                {\n                    return DownloadResult.Failure(\"Could not resolve host.\");\n                }\n\n                foreach (var ip in resolvedAddresses)\n                {\n                    if (IsPrivateOrLoopback(ip))\n                    {\n                        return DownloadResult.Failure(\"IP address not allowed.\");\n                    }\n                }\n\n                // Use the first valid IP address for the connection\n                var ipAddress = resolvedAddresses.First(ip => !IsPrivateOrLoopback(ip));\n                var uriBuilder = new UriBuilder(uri)\n                {\n                    Host = ipAddress.ToString()\n                };\n\n                var handler = new HttpClientHandler\n                {\n                    ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => true\n                };\n\n                using (var httpClient = new HttpClient(handler))\n                {\n                    httpClient.DefaultRequestHeaders.Host = uri.Host;\n                    try\n                    {\n                        var response = await httpClient.GetAsync(uriBuilder.Uri);\n                        if (!response.IsSuccessStatusCode)\n                        {\n                            return DownloadResult.Failure(\"Resource not found or not accessible.\");\n                        }\n                        var bytes = await response.Content.ReadAsByteArrayAsync();\n                        return DownloadResult.Success(bytes);\n                    }\n                    catch (Exception ex)\n                    {\n                        _logger.LogError(ex, \"Error fetching file from {Url}\", url);\n                        return DownloadResult.Failure(\"Error downloading file.\");\n                    }\n                }\n            }\n            else if (uri.HostNameType == UriHostNameType.IPv4 || uri.HostNameType == UriHostNameType.IPv6)\n            {\n                if (IsPrivateOrLoopback(System.Net.IPAddress.Parse(uri.Host)))\n                {\n                    return DownloadResult.Failure(\"IP address not allowed.\");\n                }\n\n                using (var httpClient = new HttpClient())\n                {\n                    try\n                    {\n                        var response = await httpClient.GetAsync(uri);\n                        if (!response.IsSuccessStatusCode)\n                        {\n                            return DownloadResult.Failure(\"Resource not found or not accessible.\");\n                        }\n                        var bytes = await response.Content.ReadAsByteArrayAsync();\n                        return DownloadResult.Success(bytes);\n                    }\n                    catch (Exception ex)\n                    {\n                        _logger.LogError(ex, \"Error fetching file from {Url}\", url);\n                        return DownloadResult.Failure(\"Error downloading file.\");\n                    }\n                }\n            }\n            else\n            {\n                return DownloadResult.Failure(\"Unsupported host type.\");\n            }\n        }\n\n        private bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (Link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal || ip.IsIPv6Teredo)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/Models/DownloadResult.cs\nnamespace MyApp.Services.Models\n{\n    public class DownloadResult\n    {\n        public bool IsSuccess { get; }\n        public byte[] FileContent { get; }\n        public string ErrorMessage { get; }\n\n        private DownloadResult(bool isSuccess, byte[] fileContent, string errorMessage)\n        {\n            IsSuccess = isSuccess;\n            FileContent = fileContent;\n            ErrorMessage = errorMessage;\n        }\n\n        public static DownloadResult Success(byte[] fileContent) =>\n            new DownloadResult(true, fileContent, null);\n\n        public static DownloadResult Failure(string errorMessage) =>\n            new DownloadResult(false, null, errorMessage);\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/DownloadController.cs\nusing System;\nusing System.IO;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> Download(string url)\n        {\n            try\n            {\n                var request = WebRequest.Create(url);\n                var response = await request.GetResponseAsync();\n                var stream = response.GetResponseStream();\n                var data = new byte[stream.Length];\n                await stream.ReadAsync(data, 0, data.Length);\n                return File(data, \"application/octet-stream\");\n            }\n            catch (Exception e)\n            {\n                return StatusCode(500, e.Message);\n            }\n        }\n    }\n}\n```"}
{"prompt": "Implement a C# function which receives a URL parameter and returns the corresponding content.", "response": "```csharp\n// Controllers/ContentController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add in Program.cs or Startup.cs:\n    // options.AddPolicy(\"TrustedContentPolicy\", policy => policy.RequireAuthenticatedUser());\n\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"TrustedContentPolicy\")]\n    public class ContentController : ControllerBase\n    {\n        private readonly IContentFetcherService _contentFetcherService;\n        private readonly ILogger<ContentController> _logger;\n\n        public ContentController(IContentFetcherService contentFetcherService, ILogger<ContentController> logger)\n        {\n            _contentFetcherService = contentFetcherService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"TrustedContentPolicy\")]\n        public async Task<IActionResult> GetContent([FromQuery] ContentFetchRequestDto request)\n        {\n            _logger.LogInformation(\"Received content fetch request for URL.\");\n\n            try\n            {\n                var result = await _contentFetcherService.FetchContentAsync(request.Url);\n\n                if (!result.Success)\n                {\n                    _logger.LogWarning(\"Content fetch failed: {Reason}\", result.Error);\n                    return BadRequest(new { error = result.Error });\n                }\n\n                return File(result.Content, result.ContentType ?? \"application/octet-stream\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during content fetch.\");\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/ContentFetchRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class ContentFetchRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IContentFetcherService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IContentFetcherService\n    {\n        Task<ContentFetchResult> FetchContentAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/ContentFetcherService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class ContentFetcherService : IContentFetcherService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<ContentFetcherService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public ContentFetcherService(IHttpClientFactory httpClientFactory, IConfiguration configuration, ILogger<ContentFetcherService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _configuration = configuration;\n            _logger = logger;\n            _trustedDomains = GetTrustedDomainsFromConfig(configuration);\n        }\n\n        public async Task<ContentFetchResult> FetchContentAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return ContentFetchResult.Failure(\"Malformed URL.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return ContentFetchResult.Failure(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (!IsTrustedDomain(uri.Host))\n            {\n                return ContentFetchResult.Failure(\"Domain is not trusted.\");\n            }\n\n            var resolvedIps = await ResolveHostToIpAddressesAsync(uri.Host);\n            if (resolvedIps == null || resolvedIps.Length == 0)\n            {\n                _logger.LogWarning(\"DNS resolution failed for {Host}\", uri.Host);\n                return ContentFetchResult.Failure(\"Could not resolve host.\");\n            }\n\n            var validIp = resolvedIps.FirstOrDefault(ip => IsPublicIp(ip));\n            if (validIp == null)\n            {\n                return ContentFetchResult.Failure(\"Resolved IP address is not public.\");\n            }\n\n            var verifiedUri = new UriBuilder(uri)\n            {\n                Host = validIp.ToString()\n            }.Uri;\n\n            using var httpClient = _httpClientFactory.CreateClient();\n            httpClient.DefaultRequestHeaders.Host = uri.Host;\n            httpClient.DefaultRequestHeaders.Accept.Clear();\n            httpClient.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue(\"application/json\"));\n\n            try\n            {\n                using var response = await httpClient.GetAsync(verifiedUri);\n\n                if (response.StatusCode == HttpStatusCode.OK)\n                {\n                    var content = await response.Content.ReadAsByteArrayAsync();\n                    var contentType = response.Content.Headers.ContentType?.MediaType;\n                    return ContentFetchResult.Success(content, contentType);\n                }\n                else\n                {\n                    _logger.LogWarning(\"Remote server returned status {StatusCode}\", response.StatusCode);\n                    return ContentFetchResult.Failure(\"Error retrieving content.\");\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching content from remote server.\");\n                return ContentFetchResult.Failure(\"Failed to fetch content.\");\n            }\n        }\n\n        private HashSet<string> GetTrustedDomainsFromConfig(IConfiguration configuration)\n        {\n            var domains = configuration.GetSection(\"TrustedContentDomains\").Get<string[]>() ?? Array.Empty<string>();\n            return new HashSet<string>(domains.Select(d => d.ToLowerInvariant()));\n        }\n\n        private bool IsTrustedDomain(string host)\n        {\n            return _trustedDomains.Contains(host.ToLowerInvariant());\n        }\n\n        private async Task<IPAddress[]> ResolveHostToIpAddressesAsync(string host)\n        {\n            try\n            {\n                return await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                return Array.Empty<IPAddress>();\n            }\n        }\n\n        private bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                // Private IPv4 ranges\n                if (bytes[0] == 10 ||\n                    (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) ||\n                    (bytes[0] == 192 && bytes[1] == 168))\n                {\n                    return false;\n                }\n                // Loopback\n                if (bytes[0] == 127)\n                {\n                    return false;\n                }\n                // Link-local\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n                return true;\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip))\n                {\n                    return false;\n                }\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/ContentFetchResult.cs\nnamespace MyApp.Services\n{\n    public class ContentFetchResult\n    {\n        public bool Success { get; }\n        public byte[] Content { get; }\n        public string ContentType { get; }\n        public string Error { get; }\n\n        private ContentFetchResult(bool success, byte[] content, string contentType, string error)\n        {\n            Success = success;\n            Content = content;\n            ContentType = contentType;\n            Error = error;\n        }\n\n        public static ContentFetchResult Success(byte[] content, string contentType)\n        {\n            return new ContentFetchResult(true, content, contentType, null);\n        }\n\n        public static ContentFetchResult Failure(string error)\n        {\n            return new ContentFetchResult(false, null, null, error);\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (excerpt for DI and policy setup)\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IContentFetcherService, ContentFetcherService>();\nbuilder.Services.AddLogging();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedContentPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```json\n// appsettings.json (excerpt for trusted domains)\n{\n  \"TrustedContentDomains\": [\n    \"api.example.com\",\n    \"trusted.example.net\"\n  ]\n}\n```\n", "orig": "```csharp\nusing System.Net.Http;\nusing System.Net.Http.Headers;\n\npublic class ContentController : Controller\n{\n    [HttpGet]\n    public IActionResult GetContent(string url)\n    {\n        // Validate the URL\n        if (string.IsNullOrEmpty(url))\n        {\n            return BadRequest(\"Invalid URL\");\n        }\n\n        // Create a new HTTP client\n        var httpClient = new HttpClient();\n\n        // Set the URL and headers\n        var request = new HttpRequestMessage(HttpMethod.Get, url);\n        request.Headers.Add(\"Accept\", \"application/json\");\n\n        // Send the request and get the response\n        var response = await httpClient.SendAsync(request);\n\n        // Check the response status code\n        if (response.StatusCode == HttpStatusCode.OK)\n        {\n            // Get the content from the response\n            var content = await response.Content.ReadAsStringAsync();\n\n            // Return the content\n            return Ok(content);\n        }\n        else\n        {\n            // Return an error response\n            return StatusCode((int)response.StatusCode, \"Error retrieving content\");\n        }\n    }\n}\n```"}
{"prompt": "Write a C# function to take a URL entered by the user and extract its data.", "response": "```csharp\n// Controllers/UrlController.cs\nusing System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: services.AddAuthorization(options => options.AddPolicy(\"UrlAccessPolicy\", policy => policy.RequireAuthenticatedUser()));\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"UrlAccessPolicy\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IHttpUrlFetcherService _httpUrlFetcherService;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(\n            IHttpUrlFetcherService httpUrlFetcherService,\n            ILogger<UrlController> logger)\n        {\n            _httpUrlFetcherService = httpUrlFetcherService;\n            _logger = logger;\n        }\n\n        [HttpPost]\n        [Authorize(Policy = \"UrlAccessPolicy\")]\n        public async Task<IActionResult> ExtractUrlData([FromBody] UrlFetchRequestDto request)\n        {\n            _logger.LogInformation(\"ExtractUrlData called for URL: {Url}\", request?.Url);\n\n            if (request == null || !request.IsValid)\n            {\n                _logger.LogWarning(\"Invalid request payload.\");\n                return BadRequest(new { error = \"Invalid request.\" });\n            }\n\n            try\n            {\n                var fetchResult = await _httpUrlFetcherService.FetchUrlContentAsync(request.Url);\n\n                if (!fetchResult.Success)\n                {\n                    if (fetchResult.StatusCode == HttpStatusCode.BadRequest)\n                    {\n                        return BadRequest(new { error = fetchResult.ErrorMessage });\n                    }\n\n                    if (fetchResult.StatusCode == HttpStatusCode.Forbidden)\n                    {\n                        return Forbid();\n                    }\n\n                    if (fetchResult.StatusCode == HttpStatusCode.NotFound)\n                    {\n                        return NotFound();\n                    }\n\n                    return StatusCode(500, new { error = \"Unable to fetch resource.\" });\n                }\n\n                var extractedData = UrlContentDataExtractor.ExtractDataFromResponse(fetchResult.Content);\n\n                return Ok(new UrlFetchResponseDto\n                {\n                    Data = extractedData\n                });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unhandled exception in ExtractUrlData.\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlFetchRequestDto.cs\nusing System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlFetchRequestDto\n    {\n        [Required]\n        [StringLength(2048, MinimumLength = 8)]\n        public string Url { get; set; }\n\n        public bool IsValid =>\n            !string.IsNullOrWhiteSpace(Url) &&\n            Uri.TryCreate(Url, UriKind.Absolute, out var uri) &&\n            (uri.Scheme == Uri.UriSchemeHttps || uri.Scheme == Uri.UriSchemeHttp) &&\n            Url.Length <= 2048;\n    }\n}\n```\n\n```csharp\n// Models/UrlFetchResponseDto.cs\nnamespace MyApp.Models\n{\n    public class UrlFetchResponseDto\n    {\n        public string Data { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IHttpUrlFetcherService.cs\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IHttpUrlFetcherService\n    {\n        Task<HttpUrlFetchResult> FetchUrlContentAsync(string url);\n    }\n\n    public class HttpUrlFetchResult\n    {\n        public bool Success { get; set; }\n        public string Content { get; set; }\n        public string ErrorMessage { get; set; }\n        public HttpStatusCode StatusCode { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/HttpUrlFetcherService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Services\n{\n    public class HttpUrlFetcherService : IHttpUrlFetcherService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<HttpUrlFetcherService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public HttpUrlFetcherService(\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration,\n            ILogger<HttpUrlFetcherService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n\n            var trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            _trustedDomains = trustedDomains != null\n                ? new HashSet<string>(trustedDomains, StringComparer.OrdinalIgnoreCase)\n                : new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<HttpUrlFetchResult> FetchUrlContentAsync(string url)\n        {\n            try\n            {\n                if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n                {\n                    return new HttpUrlFetchResult\n                    {\n                        Success = false,\n                        StatusCode = HttpStatusCode.BadRequest,\n                        ErrorMessage = \"Malformed URL\"\n                    };\n                }\n\n                if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n                {\n                    return new HttpUrlFetchResult\n                    {\n                        Success = false,\n                        StatusCode = HttpStatusCode.BadRequest,\n                        ErrorMessage = \"Only HTTPS URLs are allowed\"\n                    };\n                }\n\n                if (!IsTrustedDomain(uri.Host))\n                {\n                    return new HttpUrlFetchResult\n                    {\n                        Success = false,\n                        StatusCode = HttpStatusCode.Forbidden,\n                        ErrorMessage = \"Domain is not trusted\"\n                    };\n                }\n\n                var resolvedAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n                if (resolvedAddresses.Length == 0)\n                {\n                    return new HttpUrlFetchResult\n                    {\n                        Success = false,\n                        StatusCode = HttpStatusCode.NotFound,\n                        ErrorMessage = \"Host could not be resolved\"\n                    };\n                }\n\n                foreach (var ip in resolvedAddresses)\n                {\n                    if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                    {\n                        return new HttpUrlFetchResult\n                        {\n                            Success = false,\n                            StatusCode = HttpStatusCode.Forbidden,\n                            ErrorMessage = \"Access to private, loopback, or link-local addresses is forbidden\"\n                        };\n                    }\n                }\n\n                // Use the first valid IP address for the request\n                var validIp = resolvedAddresses.First(ip => !IsPrivateOrLoopbackOrLinkLocal(ip));\n                var builder = new UriBuilder(uri)\n                {\n                    Host = validIp.ToString()\n                };\n\n                var client = _httpClientFactory.CreateClient();\n                client.DefaultRequestHeaders.Host = uri.Host;\n\n                var httpRequest = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n\n                var httpResponse = await client.SendAsync(httpRequest);\n\n                if (!httpResponse.IsSuccessStatusCode)\n                {\n                    return new HttpUrlFetchResult\n                    {\n                        Success = false,\n                        StatusCode = httpResponse.StatusCode,\n                        ErrorMessage = \"Failed to retrieve content\"\n                    };\n                }\n\n                var content = await httpResponse.Content.ReadAsStringAsync();\n\n                return new HttpUrlFetchResult\n                {\n                    Success = true,\n                    Content = content,\n                    StatusCode = HttpStatusCode.OK\n                };\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching URL content for {Url}\", url);\n                return new HttpUrlFetchResult\n                {\n                    Success = false,\n                    StatusCode = HttpStatusCode.InternalServerError,\n                    ErrorMessage = \"Internal server error\"\n                };\n            }\n        }\n\n        private bool IsTrustedDomain(string host)\n        {\n            if (string.IsNullOrWhiteSpace(host))\n            {\n                return false;\n            }\n\n            return _trustedDomains.Contains(host);\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.x.x.x\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.x.x - 172.31.x.x\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.x.x\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.x.x (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlContentDataExtractor.cs\nusing System.Text.RegularExpressions;\n\nnamespace MyApp.Services\n{\n    public static class UrlContentDataExtractor\n    {\n        public static string ExtractDataFromResponse(string responseContent)\n        {\n            if (string.IsNullOrWhiteSpace(responseContent))\n            {\n                return string.Empty;\n            }\n\n            // Example: Extract <title> from HTML (can be replaced with more complex logic)\n            var match = Regex.Match(responseContent, @\"<title>\\s*(.+?)\\s*</title>\", RegexOptions.IgnoreCase);\n            if (match.Success)\n            {\n                return match.Groups[1].Value.Trim();\n            }\n\n            return string.Empty;\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/UrlController.cs\nusing System;\nusing System.Net.Http;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly HttpClient _httpClient;\n\n        public UrlController(IHttpClientFactory httpClientFactory)\n        {\n            _httpClient = httpClientFactory.CreateClient();\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> ExtractUrlData([FromBody] string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            var uri = new Uri(url);\n            var httpRequest = new HttpRequestMessage(HttpMethod.Get, uri);\n            var httpResponse = await _httpClient.SendAsync(httpRequest);\n\n            if (!httpResponse.IsSuccessStatusCode)\n            {\n                return StatusCode((int)httpResponse.StatusCode);\n            }\n\n            var responseContent = await httpResponse.Content.ReadAsStringAsync();\n            var data = ExtractDataFromResponse(responseContent);\n\n            return Ok(data);\n        }\n\n        private static string ExtractDataFromResponse(string responseContent)\n        {\n            // TODO: Implement logic to extract data from response\n            // e.g. using a regular expression, or a JSON parser\n            return null;\n        }\n    }\n}\n```"}
{"prompt": "Design a C# function that accepts a URL parameter and extracts data from the specified address.", "response": "```csharp\n// Controllers/UrlDataController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, configure Authorization options in Program.cs or Startup.cs:\n    // options.AddPolicy(\"CanFetchUrlData\", policy => policy.RequireClaim(\"UrlDataAccess\", \"true\"));\n\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"CanFetchUrlData\")]\n    public class UrlDataController : ControllerBase\n    {\n        private readonly IUrlDataFetcherService _urlDataFetcherService;\n        private readonly ILogger<UrlDataController> _logger;\n\n        public UrlDataController(\n            IUrlDataFetcherService urlDataFetcherService,\n            ILogger<UrlDataController> logger)\n        {\n            _urlDataFetcherService = urlDataFetcherService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"CanFetchUrlData\")]\n        public async Task<IActionResult> GetUrlData([FromQuery] UrlDataRequestDto request)\n        {\n            _logger.LogInformation(\"GetUrlData called with url: {Url}\", request.Url);\n\n            try\n            {\n                var data = await _urlDataFetcherService.FetchDataFromUrlAsync(request.Url);\n\n                if (data == null)\n                {\n                    return NotFound();\n                }\n\n                return File(data, \"application/octet-stream\");\n            }\n            catch (UrlDataFetcherBadRequestException ex)\n            {\n                _logger.LogWarning(ex, \"Bad request in GetUrlData for url: {Url}\", request.Url);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error in GetUrlData for url: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dto/UrlDataRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dto\n{\n    public class UrlDataRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlDataFetcherService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlDataFetcherService\n    {\n        Task<byte[]> FetchDataFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlDataFetcherService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing System.Net;\nusing System.Text.RegularExpressions;\n\nnamespace MyApp.Services\n{\n    public class UrlDataFetcherService : IUrlDataFetcherService\n    {\n        private readonly HashSet<string> _trustedDomains;\n        private readonly ILogger<UrlDataFetcherService> _logger;\n        private readonly IHttpClientFactory _httpClientFactory;\n\n        public UrlDataFetcherService(\n            IConfiguration configuration,\n            ILogger<UrlDataFetcherService> logger,\n            IHttpClientFactory httpClientFactory)\n        {\n            _logger = logger;\n            _httpClientFactory = httpClientFactory;\n\n            var trustedDomainsSection = configuration.GetSection(\"TrustedDomains\");\n            _trustedDomains = trustedDomainsSection.Exists()\n                ? new HashSet<string>(trustedDomainsSection.Get<string[]>(), StringComparer.OrdinalIgnoreCase)\n                : new HashSet<string>(new[] { \"example.com\" }, StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<byte[]> FetchDataFromUrlAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new UrlDataFetcherBadRequestException(\"URL must not be empty.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlDataFetcherBadRequestException(\"The URL is not valid.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlDataFetcherBadRequestException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            string host = uri.Host;\n\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new UrlDataFetcherBadRequestException(\"The domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (SocketException ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host: {Host}\", host);\n                throw new UrlDataFetcherBadRequestException(\"DNS resolution failed.\");\n            }\n\n            if (addresses.Length == 0)\n            {\n                throw new UrlDataFetcherBadRequestException(\"No IP addresses resolved for the host.\");\n            }\n\n            foreach (var address in addresses)\n            {\n                if (IsPrivateOrLoopback(address))\n                {\n                    throw new UrlDataFetcherBadRequestException(\"Resolved IP address is not allowed.\");\n                }\n            }\n\n            var verifiedIp = addresses.First();\n\n            var uriWithIp = new UriBuilder(uri)\n            {\n                Host = verifiedIp.ToString()\n            }.Uri;\n\n            using var client = _httpClientFactory.CreateClient();\n\n            // Set Host header to original host\n            client.DefaultRequestHeaders.Host = host;\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await client.GetAsync(uriWithIp);\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed for url: {Url}\", url);\n                throw new UrlDataFetcherBadRequestException(\"Failed to fetch data from the URL.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new UrlDataFetcherBadRequestException($\"Failed to fetch data: HTTP {response.StatusCode}\");\n            }\n\n            return await response.Content.ReadAsByteArrayAsync();\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (Link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlDataFetcherBadRequestException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class UrlDataFetcherBadRequestException : Exception\n    {\n        public UrlDataFetcherBadRequestException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/UrlDataController.cs\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public IActionResult GetUrlData(string url)\n        {\n            // Extract data from the specified address\n            var data = GetDataFromUrl(url);\n\n            // Return the extracted data\n            return Ok(data);\n        }\n\n        private static string GetDataFromUrl(string url)\n        {\n            // Implement the logic to extract data from the specified address\n            // ...\n\n            // Return the extracted data\n            return data;\n        }\n    }\n}\n```"}
{"prompt": "Develop a C# function which accepts a user-input URL and retrieves the associated data.", "response": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading.Tasks;\nusing MyApp.Models;\nusing MyApp.Services;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: services.AddAuthorization(options => options.AddPolicy(\"UrlRead\", policy => policy.RequireAuthenticatedUser()));\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"UrlRead\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlService _urlService;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IUrlService urlService, ILogger<UrlController> logger)\n        {\n            _urlService = urlService;\n            _logger = logger;\n        }\n\n        [HttpGet(\"{id}\")]\n        [Authorize(Policy = \"UrlRead\")]\n        public async Task<IActionResult> GetUrl(string id)\n        {\n            try\n            {\n                _logger.LogInformation(\"Fetching URL with id: {Id}\", id);\n\n                var url = await _urlService.GetUrlAsync(id);\n\n                if (url == null)\n                {\n                    _logger.LogWarning(\"URL not found for id: {Id}\", id);\n                    return NotFound(new { error = \"Resource not found or access denied.\" });\n                }\n\n                return Ok(url);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching URL with id: {Id}\", id);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/IUrlService.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IUrlService\n    {\n        Task<Url> GetUrlAsync(string id);\n    }\n}\n```\n\n```csharp\n// Services/UrlService.cs\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Repositories;\n\nnamespace MyApp.Services\n{\n    public class UrlService : IUrlService\n    {\n        private readonly IUrlRepository _urlRepository;\n        private readonly ILogger<UrlService> _logger;\n\n        public UrlService(IUrlRepository urlRepository, ILogger<UrlService> logger)\n        {\n            _urlRepository = urlRepository;\n            _logger = logger;\n        }\n\n        public async Task<Url> GetUrlAsync(string id)\n        {\n            _logger.LogInformation(\"Service call to get URL for id: {Id}\", id);\n\n            var url = await _urlRepository.GetUrlAsync(id);\n\n            _logger.LogInformation(\"Service fetched URL: {Found}\", url != null);\n\n            return url;\n        }\n    }\n}\n```\n\n```csharp\n// Repositories/IUrlRepository.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Repositories\n{\n    public interface IUrlRepository\n    {\n        Task<Url> GetUrlAsync(string id);\n    }\n}\n```\n\n```csharp\n// Repositories/UrlRepository.cs\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\n\nnamespace MyApp.Repositories\n{\n    public class UrlRepository : IUrlRepository\n    {\n        private readonly MyDbContext _dbContext;\n        private readonly ILogger<UrlRepository> _logger;\n\n        public UrlRepository(MyDbContext dbContext, ILogger<UrlRepository> logger)\n        {\n            _dbContext = dbContext;\n            _logger = logger;\n        }\n\n        public async Task<Url> GetUrlAsync(string id)\n        {\n            _logger.LogInformation(\"Repository querying for URL id: {Id}\", id);\n\n            var url = await _dbContext.Urls.AsNoTracking().FirstOrDefaultAsync(u => u.Id == id);\n\n            _logger.LogInformation(\"Repository query result: {Found}\", url != null);\n\n            return url;\n        }\n    }\n}\n```\n\n```csharp\n// Models/Url.cs\nusing System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class Url\n    {\n        [Key]\n        [Required]\n        public string Id { get; set; }\n\n        [Required]\n        [Url]\n        public string OriginalUrl { get; set; }\n\n        [Required]\n        public string ShortenedUrl { get; set; }\n\n        public DateTime CreatedAt { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/MyDbContext.cs\nusing Microsoft.EntityFrameworkCore;\n\nnamespace MyApp.Models\n{\n    public class MyDbContext : DbContext\n    {\n        public MyDbContext(DbContextOptions<MyDbContext> options)\n            : base(options)\n        {\n        }\n\n        public DbSet<Url> Urls { get; set; }\n    }\n}\n```\n\n```csharp\n// Extensions/ConfigurationExtensions.cs\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApp.Extensions\n{\n    public static class ConfigurationExtensions\n    {\n        public static string GetSqlConnectionString(this IConfiguration configuration)\n        {\n            return configuration.GetConnectionString(\"DefaultConnection\") \n                ?? \"Server=localhost;Database=MyDb;Trusted_Connection=True;\";\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.EntityFrameworkCore;\nusing MyApp.Models;\nusing MyApp.Repositories;\nusing MyApp.Services;\nusing MyApp.Extensions;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"UrlRead\", policy => policy.RequireAuthenticatedUser());\n});\n\nbuilder.Services.AddDbContext<MyDbContext>(options =>\n{\n    var connectionString = builder.Configuration.GetSqlConnectionString();\n    options.UseSqlServer(connectionString);\n});\n\nbuilder.Services.AddScoped<IUrlRepository, UrlRepository>();\nbuilder.Services.AddScoped<IUrlService, UrlService>();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\napp.UseAuthentication();\napp.UseAuthorization();\napp.MapControllers();\napp.Run();\n```", "orig": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Models;\nusing Services;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlService _urlService;\n\n        public UrlController(IUrlService urlService)\n        {\n            _urlService = urlService;\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetUrl(string id)\n        {\n            var url = await _urlService.GetUrlAsync(id);\n\n            if (url == null)\n            {\n                return NotFound();\n            }\n\n            return Ok(url);\n        }\n    }\n}\n\n// Services/IUrlService.cs\nusing System.Threading.Tasks;\nusing Models;\n\nnamespace MyApp.Services\n{\n    public interface IUrlService\n    {\n        Task<Url> GetUrlAsync(string id);\n    }\n}\n\n// Services/UrlService.cs\nusing System.Threading.Tasks;\nusing Models;\n\nnamespace MyApp.Services\n{\n    public class UrlService : IUrlService\n    {\n        private readonly IUrlRepository _urlRepository;\n\n        public UrlService(IUrlRepository urlRepository)\n        {\n            _urlRepository = urlRepository;\n        }\n\n        public async Task<Url> GetUrlAsync(string id)\n        {\n            return await _urlRepository.GetUrlAsync(id);\n        }\n    }\n}\n\n// Repositories/IUrlRepository.cs\nusing System.Threading.Tasks;\nusing Models;\n\nnamespace MyApp.Repositories\n{\n    public interface IUrlRepository\n    {\n        Task<Url> GetUrlAsync(string id);\n    }\n}\n\n// Repositories/UrlRepository.cs\nusing System.Threading.Tasks;\nusing Models;\n\nnamespace MyApp.Repositories\n{\n    public class UrlRepository : IUrlRepository\n    {\n        private readonly MyDbContext _dbContext;\n\n        public UrlRepository(MyDbContext dbContext)\n        {\n            _dbContext = dbContext;\n        }\n\n        public async Task<Url> GetUrlAsync(string id)\n        {\n            return await _dbContext.Urls.FirstOrDefaultAsync(u => u.Id == id);\n        }\n    }\n}\n\n// Models/Url.cs\nusing System;\n\nnamespace MyApp.Models\n{\n    public class Url\n    {\n        public string Id { get; set; }\n        public string OriginalUrl { get; set; }\n        public string ShortenedUrl { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n}\n\n// Models/MyDbContext.cs\nusing Microsoft.EntityFrameworkCore;\nusing MyApp.Models;\n\nnamespace MyApp.Models\n{\n    public class MyDbContext : DbContext\n    {\n        public DbSet<Url> Urls { get; set; }\n\n        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n        {\n            optionsBuilder.UseSqlServer(\"Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;\");\n        }\n    }\n}\n```"}
{"prompt": "Design a C# function that takes a URL parameter from the user and extracts the data.", "response": "```csharp\n// Controllers/DataController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\n// Policy setup (in Program.cs or Startup): \n// options.AddPolicy(\"DataReadPolicy\", policy => policy.RequireAuthenticatedUser().RequireRole(\"DataReader\"));\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"DataReadPolicy\")]\n    public class DataController : ControllerBase\n    {\n        private readonly ILogger<DataController> _logger;\n        private readonly IDataFetchService _dataFetchService;\n\n        public DataController(ILogger<DataController> logger, IDataFetchService dataFetchService)\n        {\n            _logger = logger;\n            _dataFetchService = dataFetchService;\n        }\n\n        [HttpGet(\"{*url}\")]\n        [Authorize(Policy = \"DataReadPolicy\")]\n        public async Task<IActionResult> GetData([FromRoute] string url)\n        {\n            _logger.LogInformation(\"GetData called with url: {Url}\", url);\n\n            try\n            {\n                var result = await _dataFetchService.FetchDataFromUrlAsync(url);\n\n                if (result == null)\n                {\n                    return NotFound();\n                }\n\n                return Ok(result);\n            }\n            catch (DataFetchValidationException ex)\n            {\n                _logger.LogWarning(ex, \"Validation failed for url: {Url}\", url);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Internal error fetching data for url: {Url}\", url);\n                return StatusCode(500, new { error = \"An internal server error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/DataModel.cs\nnamespace MyApp.Models\n{\n    public class DataModel\n    {\n        public string Url { get; set; }\n        public string Data { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/DataFetchValidationException.cs\nusing System;\n\nnamespace MyApp.Models\n{\n    public class DataFetchValidationException : Exception\n    {\n        public DataFetchValidationException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// Services/IDataFetchService.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IDataFetchService\n    {\n        Task<DataModel> FetchDataFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/DataFetchService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class DataFetchService : IDataFetchService\n    {\n        private readonly List<string> _trustedDomains;\n        private readonly ILogger<DataFetchService> _logger;\n        private readonly HttpClient _httpClient;\n\n        public DataFetchService(IConfiguration configuration, ILogger<DataFetchService> logger, IHttpClientFactory httpClientFactory)\n        {\n            _logger = logger;\n            _httpClient = httpClientFactory.CreateClient();\n\n            _trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<List<string>>() ?? new List<string>();\n        }\n\n        public async Task<DataModel> FetchDataFromUrlAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new DataFetchValidationException(\"URL must be provided.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var parsedUri))\n            {\n                throw new DataFetchValidationException(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(parsedUri.Scheme, \"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new DataFetchValidationException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (parsedUri.HostNameType == UriHostNameType.Dns)\n            {\n                if (!_trustedDomains.Any(d => string.Equals(d, parsedUri.Host, StringComparison.OrdinalIgnoreCase)))\n                {\n                    throw new DataFetchValidationException(\"Domain is not trusted.\");\n                }\n                var resolvedIps = await Dns.GetHostAddressesAsync(parsedUri.Host);\n                if (!resolvedIps.Any())\n                {\n                    throw new DataFetchValidationException(\"Domain could not be resolved.\");\n                }\n                foreach (var ip in resolvedIps)\n                {\n                    if (IsPrivateOrLoopback(ip))\n                    {\n                        throw new DataFetchValidationException(\"Resolved IP is private or loopback.\");\n                    }\n                }\n            }\n            else if (parsedUri.HostNameType == UriHostNameType.IPv4 || parsedUri.HostNameType == UriHostNameType.IPv6)\n            {\n                var ip = IPAddress.Parse(parsedUri.Host);\n                if (IsPrivateOrLoopback(ip))\n                {\n                    throw new DataFetchValidationException(\"IP is private or loopback.\");\n                }\n            }\n            else\n            {\n                throw new DataFetchValidationException(\"Unsupported host type.\");\n            }\n\n            var ipToUse = await GetFirstValidPublicIpAsync(parsedUri);\n            var builder = new UriBuilder(parsedUri)\n            {\n                Host = ipToUse.ToString()\n            };\n\n            var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n            request.Headers.Host = parsedUri.Host;\n\n            var response = await _httpClient.SendAsync(request);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new DataFetchValidationException(\"Failed to fetch data from the provided URL.\");\n            }\n\n            var data = await response.Content.ReadAsStringAsync();\n\n            return new DataModel\n            {\n                Url = url,\n                Data = data\n            };\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (Link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast || ip.IsIPv6Teredo)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private async Task<IPAddress> GetFirstValidPublicIpAsync(Uri uri)\n        {\n            if (uri.HostNameType == UriHostNameType.IPv4 || uri.HostNameType == UriHostNameType.IPv6)\n            {\n                var ip = IPAddress.Parse(uri.Host);\n                if (!IsPrivateOrLoopback(ip))\n                {\n                    return ip;\n                }\n            }\n            else if (uri.HostNameType == UriHostNameType.Dns)\n            {\n                var addresses = await Dns.GetHostAddressesAsync(uri.Host);\n                foreach (var ip in addresses)\n                {\n                    if (!IsPrivateOrLoopback(ip))\n                    {\n                        return ip;\n                    }\n                }\n            }\n            throw new DataFetchValidationException(\"No valid public IP found for the host.\");\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureAppConfiguration((hostingContext, config) =>\n                {\n                    config.AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true);\n                    config.AddEnvironmentVariables();\n                })\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.ConfigureServices((context, services) =>\n                    {\n                        services.AddControllers();\n                        services.AddHttpClient();\n                        services.AddScoped<IDataFetchService, DataFetchService>();\n                        services.AddAuthorization(options =>\n                        {\n                            // Policy setup: requires authenticated user with DataReader role\n                            options.AddPolicy(\"DataReadPolicy\", policy =>\n                                policy.RequireAuthenticatedUser().RequireRole(\"DataReader\"));\n                        });\n                    });\n\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n```\n\n```csharp\n// Startup.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddHttpClient();\n            services.AddScoped<IDataFetchService, DataFetchService>();\n            services.AddAuthorization();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"api.example.org\"\n  ]\n}\n```", "orig": "```csharp\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DataController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public IActionResult GetData(string url)\n        {\n            // Extract data from the URL\n            // ...\n\n            // Return the extracted data\n            return Ok(data);\n        }\n    }\n}\n\nusing System;\n\nnamespace MyApp.Models\n{\n    public class DataModel\n    {\n        public string Url { get; set; }\n        public string Data { get; set; }\n    }\n}\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```"}
{"prompt": "Design a C# function that accepts a URL parameter and extracts data from the specified address.", "response": "```csharp\n// Controllers/UrlDataController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To use this, configure a policy named \"UrlDataPolicy\" in Program.cs or Startup.cs\n    [Authorize(Policy = \"UrlDataPolicy\")]\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        private readonly IUrlDataService _urlDataService;\n        private readonly ILogger<UrlDataController> _logger;\n\n        public UrlDataController(\n            IUrlDataService urlDataService,\n            ILogger<UrlDataController> logger)\n        {\n            _urlDataService = urlDataService;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"UrlDataPolicy\")]\n        [HttpGet]\n        public async Task<IActionResult> GetUrlDataAsync([FromQuery] string url)\n        {\n            _logger.LogInformation(\"GetUrlDataAsync called with url parameter.\");\n            try\n            {\n                var result = await _urlDataService.FetchUrlDataWithSecurityChecksAsync(url);\n                if (result.IsSuccess)\n                {\n                    _logger.LogInformation(\"Successfully fetched data for url.\");\n                    return Ok(result.Data);\n                }\n                else\n                {\n                    _logger.LogWarning(\"Failed to fetch data: {Reason}\", result.ErrorMessage);\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error in GetUrlDataAsync.\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlDataResult.cs\n\nnamespace MyApp.Models\n{\n    public class UrlDataResult\n    {\n        public bool IsSuccess { get; set; }\n        public string Data { get; set; }\n        public string ErrorMessage { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlDataService.cs\n\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IUrlDataService\n    {\n        Task<UrlDataResult> FetchUrlDataWithSecurityChecksAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlDataService.cs\n\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlDataService : IUrlDataService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlDataService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlDataService(\n            IHttpClientFactory httpClientFactory,\n            ILogger<UrlDataService> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n\n            var domainsFromConfig = configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            _trustedDomains = domainsFromConfig != null\n                ? new HashSet<string>(domainsFromConfig.Select(d => d.ToLowerInvariant()))\n                : new HashSet<string>();\n        }\n\n        public async Task<UrlDataResult> FetchUrlDataWithSecurityChecksAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return new UrlDataResult { IsSuccess = false, ErrorMessage = \"URL must be provided.\" };\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return new UrlDataResult { IsSuccess = false, ErrorMessage = \"Malformed URL.\" };\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return new UrlDataResult { IsSuccess = false, ErrorMessage = \"Only HTTPS URLs are allowed.\" };\n            }\n\n            if (uri.HostNameType == UriHostNameType.Dns)\n            {\n                if (!_trustedDomains.Contains(uri.Host.ToLowerInvariant()))\n                {\n                    return new UrlDataResult { IsSuccess = false, ErrorMessage = \"Domain is not trusted.\" };\n                }\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(uri.Host);\n            }\n            catch (SocketException)\n            {\n                return new UrlDataResult { IsSuccess = false, ErrorMessage = \"Could not resolve host.\" };\n            }\n\n            foreach (var ip in addresses)\n            {\n                if (IsPrivateOrLoopback(ip))\n                {\n                    return new UrlDataResult { IsSuccess = false, ErrorMessage = \"Resolved IP is private, loopback, or link-local.\" };\n                }\n            }\n\n            var ipToUse = addresses.FirstOrDefault();\n            if (ipToUse == null)\n            {\n                return new UrlDataResult { IsSuccess = false, ErrorMessage = \"No valid IP found for host.\" };\n            }\n\n            var uriWithIp = new UriBuilder(uri)\n            {\n                Host = ipToUse.ToString()\n            }.Uri;\n\n            var httpClient = _httpClientFactory.CreateClient();\n            httpClient.DefaultRequestHeaders.Host = uri.Host;\n\n            try\n            {\n                using var response = await httpClient.GetAsync(uriWithIp);\n                if (!response.IsSuccessStatusCode)\n                {\n                    return new UrlDataResult { IsSuccess = false, ErrorMessage = $\"Failed to fetch data. Status: {response.StatusCode}\" };\n                }\n\n                var bytes = await response.Content.ReadAsByteArrayAsync();\n                var base64 = Convert.ToBase64String(bytes);\n                return new UrlDataResult { IsSuccess = true, Data = base64 };\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(ex, \"HttpRequestException while fetching url data.\");\n                return new UrlDataResult { IsSuccess = false, ErrorMessage = \"Error fetching data from remote server.\" };\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unhandled exception in FetchUrlDataWithSecurityChecksAsync.\");\n                return new UrlDataResult { IsSuccess = false, ErrorMessage = \"Internal server error.\" };\n            }\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast)\n                {\n                    return true;\n                }\n                if (address.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\n\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IUrlDataService, UrlDataService>();\n\n// Example trusted domains in appsettings.json: \"TrustedDomains\": [\"example.com\", \"trustedsite.org\"]\n// Set up your authentication and authorization policies here:\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n    .AddJwtBearer();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"UrlDataPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        // Add more requirements as needed\n    });\n});\n\nvar app = builder.Build();\n\napp.UseHttpsRedirection();\n\napp.UseRouting();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```json\n// appsettings.json\n\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"trustedsite.org\"\n  ],\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    }\n  }\n}\n```", "orig": "```csharp\n// Controllers/UrlDataController.cs\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class UrlDataController : ControllerBase\n    {\n        private readonly HttpClient _httpClient;\n\n        public UrlDataController(IHttpClientFactory httpClientFactory)\n        {\n            _httpClient = httpClientFactory.CreateClient();\n        }\n\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> GetUrlDataAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            var response = await _httpClient.GetAsync(url);\n            if (!response.IsSuccessStatusCode)\n            {\n                return StatusCode(response.StatusCode);\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n            return Ok(content);\n        }\n    }\n}\n\n// Models/UrlData.cs\n\nusing System.Text.Json.Serialization;\n\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        [JsonPropertyName(\"data\")]\n        public string Data { get; set; }\n    }\n}\n\n// Services/UrlDataService.cs\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class UrlDataService\n    {\n        private readonly HttpClient _httpClient;\n\n        public UrlDataService(IHttpClientFactory httpClientFactory)\n        {\n            _httpClient = httpClientFactory.CreateClient();\n        }\n\n        public async Task<UrlData> GetUrlDataAsync(string url)\n        {\n            var response = await _httpClient.GetAsync(url);\n            if (!response.IsSuccessStatusCode)\n            {\n                return null;\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n            return JsonSerializer.Deserialize<UrlData>(content);\n        }\n    }\n}\n\n// Startup.cs\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddHttpClient();\n            services.AddSingleton<UrlDataService>();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```"}
{"prompt": "Develop a C# function which accepts a user-input URL and retrieves the associated data.", "response": "```csharp\n// Controllers/UrlDataController.cs\n\nusing System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing MyApp.Models;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, configure services.AddAuthorization(options => { options.AddPolicy(\"UrlDataPolicy\", policy => policy.RequireAuthenticatedUser()); });\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"UrlDataPolicy\")]\n    public class UrlDataController : ControllerBase\n    {\n        private readonly IUrlDataService _urlDataService;\n        private readonly ILogger<UrlDataController> _logger;\n\n        public UrlDataController(IUrlDataService urlDataService, ILogger<UrlDataController> logger)\n        {\n            _urlDataService = urlDataService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"UrlDataPolicy\")]\n        public async Task<IActionResult> GetUrlDataAsync([FromQuery] UrlDataRequestDto request)\n        {\n            _logger.LogInformation(\"Received URL data fetch request.\");\n            try\n            {\n                var data = await _urlDataService.GetUrlDataAsync(request.Url);\n                _logger.LogInformation(\"Successfully fetched data.\");\n                return Ok(new UrlDataResponseDto { Data = data });\n            }\n            catch (UrlDataValidationException ex)\n            {\n                _logger.LogWarning(\"Validation failed: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (UrlDataForbiddenException)\n            {\n                _logger.LogWarning(\"Forbidden or not found access attempt.\");\n                return NotFound(new { error = \"Resource not found or access denied.\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unhandled error while fetching URL data.\");\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlDataRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlDataRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlDataResponseDto.cs\n\nnamespace MyApp.Models\n{\n    public class UrlDataResponseDto\n    {\n        public string Data { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlDataValidationException.cs\n\nusing System;\n\nnamespace MyApp.Models\n{\n    public class UrlDataValidationException : Exception\n    {\n        public UrlDataValidationException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlDataForbiddenException.cs\n\nusing System;\n\nnamespace MyApp.Models\n{\n    public class UrlDataForbiddenException : Exception\n    {\n        public UrlDataForbiddenException(string message = null) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// Services/IUrlDataService.cs\n\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlDataService\n    {\n        Task<string> GetUrlDataAsync(string userInputUrl);\n    }\n}\n```\n\n```csharp\n// Services/UrlDataService.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class UrlDataService : IUrlDataService\n    {\n        private readonly HttpClient _httpClient;\n        private readonly HashSet<string> _trustedDomains;\n        private readonly ILogger<UrlDataService> _logger;\n\n        public UrlDataService(HttpClient httpClient, IConfiguration configuration, ILogger<UrlDataService> logger)\n        {\n            _httpClient = httpClient;\n            _logger = logger;\n\n            var trustedDomains = configuration.GetSection(\"TrustedUrlDomains\").Get<string[]>();\n            _trustedDomains = trustedDomains != null\n                ? new HashSet<string>(trustedDomains, StringComparer.OrdinalIgnoreCase)\n                : new HashSet<string>(new[] { \"example.com\" }, StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<string> GetUrlDataAsync(string userInputUrl)\n        {\n            if (string.IsNullOrWhiteSpace(userInputUrl))\n            {\n                throw new UrlDataValidationException(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(userInputUrl, UriKind.Absolute, out var uri))\n            {\n                throw new UrlDataValidationException(\"The URL is not well-formed.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlDataValidationException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(uri.Host))\n            {\n                throw new UrlDataValidationException(\"URL must include a valid host.\");\n            }\n\n            if (!_trustedDomains.Contains(uri.Host))\n            {\n                throw new UrlDataForbiddenException();\n            }\n\n            var resolvedIPs = await Dns.GetHostAddressesAsync(uri.Host);\n\n            if (resolvedIPs.Length == 0)\n            {\n                throw new UrlDataForbiddenException();\n            }\n\n            foreach (var ip in resolvedIPs)\n            {\n                if (IsPrivateOrLoopback(ip))\n                {\n                    throw new UrlDataForbiddenException();\n                }\n            }\n\n            var ipToUse = resolvedIPs.First();\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = ipToUse.ToString()\n            };\n\n            var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n            request.Headers.Host = uri.Host;\n\n            var response = await _httpClient.SendAsync(request);\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new UrlDataForbiddenException();\n            }\n\n            return await response.Content.ReadAsStringAsync();\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast || IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return true;\n                }\n                // APIPA 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```", "orig": "```csharp\n// Controllers/UrlDataController.cs\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        private readonly IUrlDataService _urlDataService;\n\n        public UrlDataController(IUrlDataService urlDataService)\n        {\n            _urlDataService = urlDataService;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetUrlDataAsync(string url)\n        {\n            var data = await _urlDataService.GetUrlDataAsync(url);\n            return Ok(data);\n        }\n    }\n}\n\n// Services/IUrlDataService.cs\n\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlDataService\n    {\n        Task<string> GetUrlDataAsync(string url);\n    }\n}\n\n// Services/UrlDataService.cs\n\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlDataService : IUrlDataService\n    {\n        private readonly HttpClient _httpClient;\n\n        public UrlDataService(HttpClient httpClient)\n        {\n            _httpClient = httpClient;\n        }\n\n        public async Task<string> GetUrlDataAsync(string url)\n        {\n            var response = await _httpClient.GetAsync(url);\n            if (response.IsSuccessStatusCode)\n            {\n                return await response.Content.ReadAsStringAsync();\n            }\n            else\n            {\n                throw new HttpRequestException($\"Error retrieving data from {url}\");\n            }\n        }\n    }\n}\n```"}
{"prompt": "Implement a C# method to accept a URL and fetch its content.", "response": "```csharp\n// Controllers/FetchController.cs\nusing System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing System.Linq;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing MyWebAPI.Models;\nusing MyWebAPI.Services;\n\nnamespace MyWebAPI.Controllers\n{\n    // Policy setup: services.AddAuthorization(options => options.AddPolicy(\"TrustedFetcher\", policy => policy.RequireAuthenticatedUser()));\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"TrustedFetcher\")]\n    public class FetchController : ControllerBase\n    {\n        private readonly IFetchService _fetchService;\n        private readonly ILogger<FetchController> _logger;\n\n        public FetchController(IFetchService fetchService, ILogger<FetchController> logger)\n        {\n            _fetchService = fetchService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Route(\"\")]\n        [Authorize(Policy = \"TrustedFetcher\")]\n        public async Task<IActionResult> Get([FromQuery] FetchUrlRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid request\", details = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage) });\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Fetching URL: {Url}\", request.Url);\n\n                var result = await _fetchService.FetchRawBytesFromTrustedUrlAsync(request.Url);\n\n                if (result == null)\n                {\n                    _logger.LogWarning(\"Resource not found or forbidden for URL: {Url}\", request.Url);\n                    return NotFound(new { error = \"Resource not found or forbidden\" });\n                }\n\n                _logger.LogInformation(\"Successfully fetched content from URL: {Url}\", request.Url);\n\n                return File(result, \"application/octet-stream\");\n            }\n            catch (ArgumentException ex)\n            {\n                _logger.LogWarning(ex, \"Bad request for URL: {Url}\", request.Url);\n                return BadRequest(new { error = \"Invalid URL\", details = ex.Message });\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(ex, \"Failed to fetch content from URL: {Url}\", request.Url);\n                return BadRequest(new { error = \"Failed to fetch content\", details = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error for URL: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/FetchUrlRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyWebAPI.Models\n{\n    public class FetchUrlRequestDto\n    {\n        [Required]\n        [Url]\n        [StringLength(2048, MinimumLength = 10)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IFetchService.cs\nusing System.Threading.Tasks;\n\nnamespace MyWebAPI.Services\n{\n    public interface IFetchService\n    {\n        Task<byte[]> FetchRawBytesFromTrustedUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/FetchService.cs\nusing System;\nusing System.Net.Http;\nusing System.Net;\nusing System.Threading.Tasks;\nusing System.Linq;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System.Collections.Generic;\nusing System.Net.Sockets;\nusing System.Text.RegularExpressions;\n\nnamespace MyWebAPI.Services\n{\n    public class FetchService : IFetchService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<FetchService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public FetchService(IHttpClientFactory httpClientFactory, IConfiguration configuration, ILogger<FetchService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _configuration = configuration;\n            _logger = logger;\n\n            var domains = _configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(domains.Select(d => d.ToLowerInvariant()));\n        }\n\n        public async Task<byte[]> FetchRawBytesFromTrustedUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new ArgumentException(\"URL is not valid.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new ArgumentException(\"Only HTTPS scheme is allowed.\");\n            }\n\n            string host = uri.Host.ToLowerInvariant();\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new ArgumentException(\"Domain is not trusted.\");\n            }\n\n            var resolvedAddresses = await Dns.GetHostAddressesAsync(host);\n            var allowedAddresses = resolvedAddresses.Where(ip => IsPublicIp(ip)).ToArray();\n\n            if (allowedAddresses.Length == 0)\n            {\n                throw new ArgumentException(\"Domain resolves only to private or loopback addresses.\");\n            }\n\n            using var handler = new SocketsHttpHandler\n            {\n                ConnectCallback = async (context, cancellationToken) =>\n                {\n                    var ip = allowedAddresses.First();\n                    var socket = new Socket(ip.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n\n                    try\n                    {\n                        await socket.ConnectAsync(ip, uri.Port, cancellationToken).ConfigureAwait(false);\n                        return new NetworkStream(socket, ownsSocket: true);\n                    }\n                    catch\n                    {\n                        socket.Dispose();\n                        throw;\n                    }\n                }\n            };\n\n            var httpClient = new HttpClient(handler)\n            {\n                Timeout = TimeSpan.FromSeconds(_configuration.GetValue<int>(\"FetchTimeoutSeconds\", 10))\n            };\n\n            using var httpRequest = new HttpRequestMessage(HttpMethod.Get, uri);\n\n            using var response = await httpClient.SendAsync(httpRequest);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                return null;\n            }\n\n            return await response.Content.ReadAsByteArrayAsync();\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10) return false;\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) return false;\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168) return false;\n                // 127.0.0.0/8\n                if (bytes[0] == 127) return false;\n                // APIPA 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254) return false;\n                return true;\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip)) return false;\n                if (ip.IsIPv6LinkLocal) return false;\n                if (ip.IsIPv6SiteLocal) return false;\n                if (ip.IsIPv6Multicast) return false;\n                return true;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (partial, for DI and config setup)\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyWebAPI.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IFetchService, FetchService>();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedFetcher\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n    });\n});\nbuilder.Services.AddLogging();\n\nbuilder.Configuration.AddJsonFile(\"appsettings.json\", optional: true);\n\nvar app = builder.Build();\n\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json (partial, trusted domains example)\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"trustedsite.org\"\n  ],\n  \"FetchTimeoutSeconds\": 10\n}\n```\n", "orig": "```csharp\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyWebAPI.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class FetchController : ControllerBase\n    {\n        [HttpGet]\n        [Route(\"{url}\")]\n        public async Task<IActionResult> Get(string url)\n        {\n            // Create a new HttpClient instance\n            var client = new HttpClient();\n\n            // Set the timeout for the request\n            client.Timeout = TimeSpan.FromSeconds(10);\n\n            // Send the request and get the response\n            var response = await client.GetAsync(url);\n\n            // Check if the response is successful\n            if (response.IsSuccessStatusCode)\n            {\n                // Read the response content\n                var content = await response.Content.ReadAsStringAsync();\n\n                // Return the response content as a string\n                return Ok(content);\n            }\n            else\n            {\n                // Return an error message if the request failed\n                return BadRequest($\"Failed to fetch content from {url}\");\n            }\n        }\n    }\n}\n\nusing System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyWebAPI.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class MyController : ControllerBase\n    {\n        [HttpGet]\n        [Route(\"fetch\")]\n        public async Task<IActionResult> Fetch(string url)\n        {\n            // Call the Fetch method to get the content of the URL\n            var content = await Fetch(url);\n\n            // Return the content as a string\n            return Ok(content);\n        }\n    }\n}\n```"}
{"prompt": "Compose a C# function that accepts a URL parameter and downloads the associated data.", "response": "```csharp\n// Controllers/DataController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing System;\nusing System.IO;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => {\n    //     options.AddPolicy(\"DataFetchPolicy\", policy => policy.RequireAuthenticatedUser());\n    // });\n\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"DataFetchPolicy\")]\n    public class DataController : ControllerBase\n    {\n        private readonly IDataFetcherService _dataFetcherService;\n        private readonly ILogger<DataController> _logger;\n        private readonly string _dataDirectory;\n\n        public DataController(\n            IDataFetcherService dataFetcherService,\n            ILogger<DataController> logger,\n            IConfiguration configuration)\n        {\n            _dataFetcherService = dataFetcherService;\n            _logger = logger;\n            _dataDirectory = configuration.GetValue<string>(\"DataDirectory\") ?? Path.Combine(Directory.GetCurrentDirectory(), \"Data\");\n        }\n\n        [HttpGet(\"download\")]\n        [Authorize(Policy = \"DataFetchPolicy\")]\n        public async Task<IActionResult> DownloadData([FromQuery] string url)\n        {\n            _logger.LogInformation(\"DownloadData called with url: {Url}\", url);\n\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return BadRequest(new { error = \"URL is required.\" });\n            }\n\n            try\n            {\n                var (fileName, fileBytes) = await _dataFetcherService.FetchAndStoreDataAsync(url, _dataDirectory);\n\n                var filePath = Path.Combine(_dataDirectory, fileName);\n\n                _logger.LogInformation(\"Returning file {FileName} from {FilePath}\", fileName, filePath);\n\n                return File(fileBytes, \"application/octet-stream\", fileName);\n            }\n            catch (ArgumentException ex)\n            {\n                _logger.LogWarning(ex, \"Invalid input.\");\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                _logger.LogWarning(ex, \"Access denied.\");\n                return Forbid();\n            }\n            catch (FileNotFoundException ex)\n            {\n                _logger.LogWarning(ex, \"Resource not found.\");\n                return NotFound(new { error = \"Resource not found or inaccessible.\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Internal server error.\");\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/IDataFetcherService.cs\n\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IDataFetcherService\n    {\n        Task<(string fileName, byte[] fileBytes)> FetchAndStoreDataAsync(string url, string dataDirectory);\n    }\n}\n```\n\n```csharp\n// Services/DataFetcherService.cs\n\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class DataFetcherService : IDataFetcherService\n    {\n        private readonly ILogger<DataFetcherService> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly HashSet<string> _trustedDomains;\n\n        public DataFetcherService(\n            ILogger<DataFetcherService> logger,\n            IConfiguration configuration,\n            IHttpClientFactory httpClientFactory)\n        {\n            _logger = logger;\n            _configuration = configuration;\n            _httpClientFactory = httpClientFactory;\n            _trustedDomains = new HashSet<string>(\n                (_configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? new string[] { }),\n                StringComparer.OrdinalIgnoreCase\n            );\n        }\n\n        public async Task<(string fileName, byte[] fileBytes)> FetchAndStoreDataAsync(string url, string dataDirectory)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new ArgumentException(\"The URL provided is not valid.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new ArgumentException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            var host = uri.Host;\n\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new ArgumentException(\"The host is not trusted.\");\n            }\n\n            var addresses = await Dns.GetHostAddressesAsync(host);\n            var allowedAddresses = addresses.Where(IsPublicAddress).ToList();\n\n            if (!allowedAddresses.Any())\n            {\n                throw new ArgumentException(\"No public IP addresses found for the host.\");\n            }\n\n            // Pick the first allowed IP for fetch\n            var endpointUri = new UriBuilder(uri)\n            {\n                Host = allowedAddresses.First().ToString()\n            }.Uri;\n\n            var httpClient = _httpClientFactory.CreateClient();\n            httpClient.DefaultRequestHeaders.Host = host;\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await httpClient.GetAsync(uri);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Failed to fetch data from {Url}\", url);\n                throw new FileNotFoundException(\"Failed to fetch the resource.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new FileNotFoundException(\"Resource not found or inaccessible.\");\n            }\n\n            var data = await response.Content.ReadAsByteArrayAsync();\n\n            var fileName = Path.GetFileName(uri.LocalPath);\n\n            if (string.IsNullOrWhiteSpace(fileName))\n            {\n                fileName = $\"file_{Guid.NewGuid()}.bin\";\n            }\n\n            Directory.CreateDirectory(dataDirectory);\n\n            var filePath = Path.Combine(dataDirectory, fileName);\n\n            await File.WriteAllBytesAsync(filePath, data);\n\n            return (fileName, data);\n        }\n\n        private static bool IsPublicAddress(IPAddress address)\n        {\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8 (loopback)\n                if (bytes[0] == 127)\n                {\n                    return false;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6Multicast || address.IsIPv6SiteLocal || address.IsIPv6Teredo)\n                {\n                    return false;\n                }\n                if (IPAddress.IsLoopback(address))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddSingleton<IDataFetcherService, DataFetcherService>();\n\n// Example: builder.Configuration[\"TrustedDomains\"] = \"example.com,api.trusted.com\";\n// Add your trusted domains in appsettings.json or another config provider\n// builder.Configuration[\"DataDirectory\"] = \"Data\";\n\n// Add a policy for DataFetchPolicy\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DataFetchPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n    });\n});\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\n\napp.UseRouting();\n\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// Data/DataFileReader.cs\n\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Data\n{\n    public class DataFileReader\n    {\n        private readonly string _filePath;\n\n        public DataFileReader(string filePath)\n        {\n            _filePath = filePath;\n        }\n\n        public async Task<List<string>> ReadDataAsync()\n        {\n            var data = new List<string>();\n            using (var fileStream = new FileStream(_filePath, FileMode.Open, FileAccess.Read))\n            using (var reader = new StreamReader(fileStream))\n            {\n                string? line;\n                while ((line = await reader.ReadLineAsync()) != null)\n                {\n                    data.Add(line);\n                }\n            }\n            return data;\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/DataController.cs\n\nusing Microsoft.AspNetCore.Mvc;\nusing System.IO;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DataController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> DownloadData(string url)\n        {\n            // Validate URL\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            // Download data\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            var data = await response.Content.ReadAsByteArrayAsync();\n\n            // Save data to file\n            var fileName = Path.GetFileName(url);\n            var filePath = Path.Combine(Directory.GetCurrentDirectory(), \"Data\", fileName);\n            using (var fileStream = new FileStream(filePath, FileMode.Create, FileAccess.Write))\n            {\n                await fileStream.WriteAsync(data, 0, data.Length);\n            }\n\n            // Return file\n            return File(filePath, \"application/octet-stream\", fileName);\n        }\n    }\n}\n\n// Data/Data.cs\n\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace MyApp.Data\n{\n    public class Data\n    {\n        private readonly string _filePath;\n\n        public Data(string filePath)\n        {\n            _filePath = filePath;\n        }\n\n        public async Task<List<string>> ReadData()\n        {\n            var data = new List<string>();\n            using (var fileStream = new FileStream(_filePath, FileMode.Open, FileAccess.Read))\n            {\n                using (var reader = new StreamReader(fileStream))\n                {\n                    string line;\n                    while ((line = await reader.ReadLineAsync()) != null)\n                    {\n                        data.Add(line);\n                    }\n                }\n            }\n            return data;\n        }\n    }\n}\n\n// Startup.cs\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddSingleton<Data>();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\n// Program.cs\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n```"}
{"prompt": "Compose a C# function to accept a URL from the user and extract data from it.", "response": "```csharp\n// Controllers/UrlDataExtractionController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: services.AddAuthorization(options => options.AddPolicy(\"RequireDataExtraction\", policy => policy.RequireAuthenticatedUser()));\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"RequireDataExtraction\")]\n    public class UrlDataExtractionController : ControllerBase\n    {\n        private readonly IUrlDataExtractionService _urlDataExtractionService;\n        private readonly ILogger<UrlDataExtractionController> _logger;\n\n        public UrlDataExtractionController(\n            IUrlDataExtractionService urlDataExtractionService,\n            ILogger<UrlDataExtractionController> logger)\n        {\n            _urlDataExtractionService = urlDataExtractionService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"extract\")]\n        [Authorize(Policy = \"RequireDataExtraction\")]\n        public async Task<IActionResult> ExtractDataFromUrl([FromBody] UrlExtractionRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid request\", details = ModelState });\n            }\n\n            try\n            {\n                _logger.LogInformation(\"ExtractDataFromUrl called with URL: {Url}\", request.Url);\n\n                var result = await _urlDataExtractionService.ExtractDataFromUrlAsync(request.Url);\n\n                _logger.LogInformation(\"Extraction succeeded for URL: {Url}\", request.Url);\n\n                return Ok(new { data = result });\n            }\n            catch (UrlDataExtractionException ex)\n            {\n                _logger.LogWarning(ex, \"Extraction failed for URL: {Url}\", request.Url);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error extracting data from URL: {Url}\", request.Url);\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"Unexpected server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/IUrlDataExtractionService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    public interface IUrlDataExtractionService\n    {\n        Task<string> ExtractDataFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlDataExtractionService.cs\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing System;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    public class UrlDataExtractionService : IUrlDataExtractionService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IOptions<TrustedDomainOptions> _trustedDomainOptions;\n        private readonly ILogger<UrlDataExtractionService> _logger;\n\n        public UrlDataExtractionService(\n            IHttpClientFactory httpClientFactory,\n            IOptions<TrustedDomainOptions> trustedDomainOptions,\n            ILogger<UrlDataExtractionService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _trustedDomainOptions = trustedDomainOptions;\n            _logger = logger;\n        }\n\n        public async Task<string> ExtractDataFromUrlAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new UrlDataExtractionException(\"URL must not be empty.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlDataExtractionException(\"URL is not well-formed.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlDataExtractionException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            string host = uri.Host;\n            if (!_trustedDomainOptions.Value.Domains.Any(d => string.Equals(d, host, StringComparison.OrdinalIgnoreCase)))\n            {\n                throw new UrlDataExtractionException(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host: {Host}\", host);\n                throw new UrlDataExtractionException(\"Could not resolve domain.\");\n            }\n\n            var validAddress = addresses.FirstOrDefault(ip => \n                !(IPAddress.IsLoopback(ip) ||\n                  ip.IsIPv6LinkLocal ||\n                  ip.IsIPv6SiteLocal ||\n                  ip.IsIPv6Multicast ||\n                  ip.IsIPv6Teredo ||\n                  ip.IsIPv4MappedToIPv6 ||\n                  ip.AddressFamily == AddressFamily.InterNetwork && IsPrivateIPv4(ip)\n                ));\n\n            if (validAddress == null)\n            {\n                throw new UrlDataExtractionException(\"No valid public IP found for domain.\");\n            }\n\n            var client = _httpClientFactory.CreateClient();\n            client.BaseAddress = new Uri($\"{uri.Scheme}://{host}\");\n\n            var requestUri = uri.PathAndQuery + uri.Fragment;\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await client.GetAsync(requestUri);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed for {Url}\", url);\n                throw new UrlDataExtractionException(\"Failed to retrieve data from the URL.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new UrlDataExtractionException(\"Failed to retrieve data from the URL.\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n\n            // Example: extract first match of \"data: ...\" (update regex as needed)\n            var match = Regex.Match(content, @\"\\bdata\\b.*?:\\s*(\\w+)\", RegexOptions.IgnoreCase);\n            if (!match.Success || match.Groups.Count < 2)\n            {\n                throw new UrlDataExtractionException(\"Could not find 'data' pattern in the content.\");\n            }\n\n            var data = match.Groups[1].Value;\n            return data;\n        }\n\n        private static bool IsPrivateIPv4(IPAddress ip)\n        {\n            var bytes = ip.GetAddressBytes();\n            return\n                (bytes[0] == 10) ||\n                (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) ||\n                (bytes[0] == 192 && bytes[1] == 168);\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlExtractionRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp\n{\n    public class UrlExtractionRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Options/TrustedDomainOptions.cs\nusing System.Collections.Generic;\n\nnamespace MyApp\n{\n    public class TrustedDomainOptions\n    {\n        public List<string> Domains { get; set; } = new List<string>();\n    }\n}\n```\n\n```csharp\n// Exceptions/UrlDataExtractionException.cs\nusing System;\n\nnamespace MyApp\n{\n    public class UrlDataExtractionException : Exception\n    {\n        public UrlDataExtractionException(string message) : base(message)\n        {\n        }\n    }\n}\n```", "orig": "```csharp\nusing System;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\n\npublic class UrlDataExtractor\n{\n    public static string ExtractData(string url)\n    {\n        if (string.IsNullOrEmpty(url))\n        {\n            throw new ArgumentNullException(nameof(url));\n        }\n\n        var httpClient = new HttpClient();\n        var response = httpClient.GetAsync(url).Result;\n\n        if (!response.IsSuccessStatusCode)\n        {\n            throw new HttpRequestException($\"Failed to retrieve data from {url}\");\n        }\n\n        var content = response.Content.ReadAsStringAsync().Result;\n        var match = Regex.Match(content, @\"\\bdata\\b\");\n\n        if (!match.Success)\n        {\n            throw new InvalidOperationException($\"Could not find data in {url}\");\n        }\n\n        var data = match.Groups[1].Value;\n        return data;\n    }\n}\n```"}
{"prompt": "Develop a C# method that takes a URL provided by the user and fetches its data.", "response": "```csharp\n// Controllers/FetchDataController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing System;\nusing System.Net;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Collections.Generic;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: Add in Program.cs or Startup.cs\n    // services.AddAuthorization(options => { options.AddPolicy(\"FetchDataPolicy\", policy => policy.RequireAuthenticatedUser()); });\n\n    [ApiController]\n    [Route(\"fetch-data\")]\n    [Authorize(Policy = \"FetchDataPolicy\")]\n    public class FetchDataController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<FetchDataController> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly ITrustedDomainVerifier _trustedDomainVerifier;\n\n        public FetchDataController(\n            IHttpClientFactory httpClientFactory,\n            ILogger<FetchDataController> logger,\n            IConfiguration configuration,\n            ITrustedDomainVerifier trustedDomainVerifier)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomainVerifier = trustedDomainVerifier;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"FetchDataPolicy\")]\n        public async Task<IActionResult> FetchFromExternalUrl([FromQuery] FetchDataRequestDto request)\n        {\n            _logger.LogInformation(\"FetchData requested for url: {Url}\", request.Url);\n\n            try\n            {\n                var validationResult = request.Validate();\n                if (!validationResult.IsValid)\n                {\n                    _logger.LogWarning(\"Validation failed: {Errors}\", string.Join(\", \", validationResult.Errors));\n                    return BadRequest(new { errors = validationResult.Errors });\n                }\n\n                var uri = new Uri(request.Url);\n\n                if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n                {\n                    _logger.LogWarning(\"Rejected non-HTTPS scheme: {Scheme}\", uri.Scheme);\n                    return BadRequest(new { error = \"Only HTTPS scheme is allowed.\" });\n                }\n\n                var trustedDomains = _configuration.GetSection(\"TrustedDomains\").Get<List<string>>() ?? new List<string>();\n                if (!_trustedDomainVerifier.IsTrustedDomain(uri.Host, trustedDomains))\n                {\n                    _logger.LogWarning(\"Untrusted domain attempted: {Host}\", uri.Host);\n                    return NotFound();\n                }\n\n                var resolvedIps = await _trustedDomainVerifier.ResolveHostToIpAddressesAsync(uri.Host);\n                if (resolvedIps.Count == 0)\n                {\n                    _logger.LogWarning(\"No IPs resolved for host: {Host}\", uri.Host);\n                    return NotFound();\n                }\n\n                if (resolvedIps.Any(ip => _trustedDomainVerifier.IsPrivateOrLoopbackOrLinkLocal(ip)))\n                {\n                    _logger.LogWarning(\"Private/loopback/link-local IP detected for host: {Host}\", uri.Host);\n                    return NotFound();\n                }\n\n                var ipToUse = resolvedIps.First();\n\n                var newUri = new UriBuilder(uri)\n                {\n                    Host = ipToUse.ToString()\n                }.Uri;\n\n                var client = _httpClientFactory.CreateClient();\n                client.DefaultRequestHeaders.Host = uri.Host;\n\n                var response = await client.GetAsync(newUri);\n\n                var content = await response.Content.ReadAsByteArrayAsync();\n\n                _logger.LogInformation(\"Fetched data from {Host} with status {StatusCode}\", uri.Host, response.StatusCode);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    return StatusCode((int)response.StatusCode, new { error = \"Failed to fetch resource.\" });\n                }\n\n                var contentType = response.Content.Headers.ContentType?.ToString() ?? \"application/octet-stream\";\n                return File(content, contentType);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching data for url: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// DTOs/FetchDataRequestDto.cs\nusing System;\nusing System.Collections.Generic;\n\nnamespace MyApp.Controllers\n{\n    public class FetchDataRequestDto\n    {\n        public string Url { get; set; }\n\n        public FetchDataRequestValidationResult Validate()\n        {\n            var errors = new List<string>();\n\n            if (string.IsNullOrWhiteSpace(Url))\n            {\n                errors.Add(\"Url is required.\");\n            }\n            else\n            {\n                if (!Uri.TryCreate(Url, UriKind.Absolute, out var uri))\n                {\n                    errors.Add(\"Url is not a valid URI.\");\n                }\n                else if (uri.Scheme != Uri.UriSchemeHttps)\n                {\n                    errors.Add(\"Url must use HTTPS scheme.\");\n                }\n            }\n\n            return new FetchDataRequestValidationResult(errors.Count == 0, errors);\n        }\n    }\n\n    public class FetchDataRequestValidationResult\n    {\n        public bool IsValid { get; }\n        public IReadOnlyList<string> Errors { get; }\n\n        public FetchDataRequestValidationResult(bool isValid, IReadOnlyList<string> errors)\n        {\n            IsValid = isValid;\n            Errors = errors;\n        }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainVerifier.cs\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    public interface ITrustedDomainVerifier\n    {\n        bool IsTrustedDomain(string host, List<string> trustedDomains);\n        Task<List<IPAddress>> ResolveHostToIpAddressesAsync(string host);\n        bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainVerifier.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    public class TrustedDomainVerifier : ITrustedDomainVerifier\n    {\n        public bool IsTrustedDomain(string host, List<string> trustedDomains)\n        {\n            if (string.IsNullOrWhiteSpace(host) || trustedDomains == null || trustedDomains.Count == 0)\n            {\n                return false;\n            }\n\n            return trustedDomains.Any(trusted =>\n                string.Equals(host, trusted, StringComparison.OrdinalIgnoreCase));\n        }\n\n        public async Task<List<IPAddress>> ResolveHostToIpAddressesAsync(string host)\n        {\n            try\n            {\n                var addresses = await Dns.GetHostAddressesAsync(host);\n                return addresses.Where(ip => ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6).ToList();\n            }\n            catch\n            {\n                return new List<IPAddress>();\n            }\n        }\n\n        public bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (ip == null)\n            {\n                return true;\n            }\n\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (Link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal || ip.IsIPv6Teredo)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (partial, for DI setup)\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Controllers;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddSingleton<ITrustedDomainVerifier, TrustedDomainVerifier>();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"FetchDataPolicy\", policy => policy.RequireAuthenticatedUser());\n});\nbuilder.Services.Configure<List<string>>(builder.Configuration.GetSection(\"TrustedDomains\"));\n\nvar app = builder.Build();\n\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json (partial)\n{\n  \"TrustedDomains\": [\n    \"www.example.com\",\n    \"example.com\"\n  ]\n}\n```", "orig": "```csharp\nusing (var client = new HttpClient())\n{\n    var response = await client.GetAsync(\"https://example.com/fetch-data?url=https://www.example.com\");\n    var data = await response.Content.ReadAsStringAsync();\n    Console.WriteLine(data);\n}\n```"}
{"prompt": "Write a C# function to take a URL entered by the user and extract its data.", "response": "```csharp\n// Controllers/UrlController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing MyApp.Models;\nusing MyApp.Services;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => options.AddPolicy(\"ExtractDataPolicy\", policy => policy.RequireAuthenticatedUser()));\n    [Authorize]\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlExtractionService _urlExtractionService;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IUrlExtractionService urlExtractionService, ILogger<UrlController> logger)\n        {\n            _urlExtractionService = urlExtractionService;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"ExtractDataPolicy\")]\n        [HttpPost(\"extract\")]\n        public async Task<IActionResult> ExtractDataFromUrl([FromBody] UrlExtractionRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Extracting data from URL. RequestId={RequestId}\", Guid.NewGuid());\n\n                var extractionResult = await _urlExtractionService.ExtractDataAsync(request.OriginalUrl);\n\n                if (!extractionResult.Success)\n                {\n                    return StatusCode(extractionResult.StatusCode, extractionResult.ErrorMessage);\n                }\n\n                return Ok(new UrlExtractionResponseDto\n                {\n                    OriginalUrl = request.OriginalUrl,\n                    ExtractedData = extractionResult.ExtractedData\n                });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during extraction.\");\n                return StatusCode(500, \"An unexpected error occurred.\");\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlExtractionRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlExtractionRequestDto\n    {\n        [Required]\n        [Url]\n        [StringLength(2048)]\n        public string OriginalUrl { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlExtractionResponseDto.cs\nnamespace MyApp.Models\n{\n    public class UrlExtractionResponseDto\n    {\n        public string OriginalUrl { get; set; }\n        public string[] ExtractedData { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlExtractionResult.cs\nnamespace MyApp.Models\n{\n    public class UrlExtractionResult\n    {\n        public bool Success { get; set; }\n        public int StatusCode { get; set; }\n        public string[] ExtractedData { get; set; }\n        public string ErrorMessage { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlExtractionService.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IUrlExtractionService\n    {\n        Task<UrlExtractionResult> ExtractDataAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlExtractionService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class UrlExtractionService : IUrlExtractionService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly UrlExtractionOptions _options;\n        private readonly ILogger<UrlExtractionService> _logger;\n\n        public UrlExtractionService(\n            IHttpClientFactory httpClientFactory,\n            IOptions<UrlExtractionOptions> options,\n            ILogger<UrlExtractionService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _options = options.Value;\n            _logger = logger;\n        }\n\n        public async Task<UrlExtractionResult> ExtractDataAsync(string url)\n        {\n            try\n            {\n                if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n                {\n                    return new UrlExtractionResult\n                    {\n                        Success = false,\n                        StatusCode = 400,\n                        ErrorMessage = \"Invalid URL format.\"\n                    };\n                }\n\n                if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n                {\n                    return new UrlExtractionResult\n                    {\n                        Success = false,\n                        StatusCode = 400,\n                        ErrorMessage = \"Only HTTPS URLs are allowed.\"\n                    };\n                }\n\n                if (!IsTrustedDomain(uri.Host, _options.TrustedDomains))\n                {\n                    return new UrlExtractionResult\n                    {\n                        Success = false,\n                        StatusCode = 400,\n                        ErrorMessage = \"Untrusted domain.\"\n                    };\n                }\n\n                var ipAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n\n                foreach (var ip in ipAddresses)\n                {\n                    if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                    {\n                        return new UrlExtractionResult\n                        {\n                            Success = false,\n                            StatusCode = 400,\n                            ErrorMessage = \"Resolved IP address is not allowed.\"\n                        };\n                    }\n                }\n\n                var verifiedIp = ipAddresses.FirstOrDefault(ip => !IsPrivateOrLoopbackOrLinkLocal(ip));\n                if (verifiedIp == null)\n                {\n                    return new UrlExtractionResult\n                    {\n                        Success = false,\n                        StatusCode = 400,\n                        ErrorMessage = \"No valid public IP address found for host.\"\n                    };\n                }\n\n                using var handler = new SocketsHttpHandler\n                {\n                    ConnectCallback = async (context, token) =>\n                    {\n                        var socket = new Socket(verifiedIp.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                        await socket.ConnectAsync(verifiedIp, uri.Port, token);\n                        return new NetworkStream(socket, ownsSocket: true);\n                    }\n                };\n\n                using var client = new HttpClient(handler, disposeHandler: true);\n\n                var response = await client.GetAsync(uri);\n                if (!response.IsSuccessStatusCode)\n                {\n                    return new UrlExtractionResult\n                    {\n                        Success = false,\n                        StatusCode = 400,\n                        ErrorMessage = \"Failed to retrieve data from the URL.\"\n                    };\n                }\n\n                var responseData = await response.Content.ReadAsStringAsync();\n                var data = responseData.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\n\n                return new UrlExtractionResult\n                {\n                    Success = true,\n                    StatusCode = 200,\n                    ExtractedData = data\n                };\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error extracting data from URL.\");\n                return new UrlExtractionResult\n                {\n                    Success = false,\n                    StatusCode = 500,\n                    ErrorMessage = \"Internal server error.\"\n                };\n            }\n        }\n\n        private static bool IsTrustedDomain(string host, IReadOnlyList<string> trustedDomains)\n        {\n            return trustedDomains.Any(domain =>\n                host.Equals(domain, StringComparison.OrdinalIgnoreCase));\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast || ip.IsIPv6Teredo)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlExtractionOptions.cs\nusing System.Collections.Generic;\n\nnamespace MyApp.Models\n{\n    public class UrlExtractionOptions\n    {\n        public List<string> TrustedDomains { get; set; } = new List<string>();\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Models;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.Configure<UrlExtractionOptions>(builder.Configuration.GetSection(\"UrlExtractionOptions\"));\nbuilder.Services.AddScoped<IUrlExtractionService, UrlExtractionService>();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"ExtractDataPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n    });\n});\n\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\n\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"UrlExtractionOptions\": {\n    \"TrustedDomains\": [\n      \"example.com\",\n      \"trustedsite.com\"\n    ]\n  }\n}\n```", "orig": "```csharp\n// Controllers/UrlController.cs\nusing System;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpPost]\n        public IActionResult ExtractDataFromUrl([FromBody] string url)\n        {\n            try\n            {\n                // Check if the URL is valid\n                if (!Uri.TryCreate(url, UriKind.Absolute, out Uri uri))\n                {\n                    return BadRequest(\"Invalid URL\");\n                }\n\n                // Create an HttpClient to make the request\n                using HttpClient client = new HttpClient();\n\n                // Make the request and get the response\n                HttpResponseMessage response = await client.GetAsync(uri);\n\n                // Check if the response is successful\n                if (!response.IsSuccessStatusCode)\n                {\n                    return BadRequest(\"Failed to get data from URL\");\n                }\n\n                // Get the response data as a string\n                string responseData = await response.Content.ReadAsStringAsync();\n\n                // Extract the data from the response\n                string[] data = responseData.Split(new[] { \" \" }, StringSplitOptions.RemoveEmptyEntries);\n\n                // Return the extracted data\n                return Ok(data);\n            }\n            catch (Exception ex)\n            {\n                return BadRequest(ex.Message);\n            }\n        }\n    }\n}\n\n// Models/Url.cs\nusing System;\nusing System.Text.RegularExpressions;\n\nnamespace MyApp.Models\n{\n    public class Url\n    {\n        public string OriginalUrl { get; set; }\n        public string ExtractedData { get; set; }\n    }\n}\n\n// Startup.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```"}
{"prompt": "Create a C# function to receive a URL input and extract its content.", "response": "```csharp\n// Controllers/UrlContentController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: Add policy \"RequireTrustedUser\" in Program.cs or startup.\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"RequireTrustedUser\")]\n    public class UrlContentController : ControllerBase\n    {\n        private readonly IUrlContentExtractorService _extractorService;\n        private readonly ILogger<UrlContentController> _logger;\n\n        public UrlContentController(\n            IUrlContentExtractorService extractorService,\n            ILogger<UrlContentController> logger)\n        {\n            _extractorService = extractorService;\n            _logger = logger;\n        }\n\n        [HttpPost]\n        [Authorize(Policy = \"RequireTrustedUser\")]\n        public async Task<IActionResult> ExtractContentAsync([FromBody] UrlExtractionRequestDto request)\n        {\n            _logger.LogInformation(\"Received request to extract content from URL. Context: {Context}\", HttpContext.TraceIdentifier);\n\n            if (!ModelState.IsValid)\n            {\n                _logger.LogWarning(\"Validation failed for URL extraction request. Context: {Context}\", HttpContext.TraceIdentifier);\n                return BadRequest(new { error = \"Invalid request\", details = ModelState });\n            }\n\n            try\n            {\n                var result = await _extractorService.ExtractContentFromUrlAsync(request.Url);\n                if (!result.Success)\n                {\n                    _logger.LogWarning(\"Extraction failed. Reason: {Reason}. Context: {Context}\", result.ErrorReason, HttpContext.TraceIdentifier);\n                    return BadRequest(new { error = result.ErrorReason });\n                }\n\n                _logger.LogInformation(\"Content extracted successfully. Context: {Context}\", HttpContext.TraceIdentifier);\n                return Ok(new { content = result.Content });\n            }\n            catch\n            {\n                _logger.LogError(\"Internal server error during URL content extraction. Context: {Context}\", HttpContext.TraceIdentifier);\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlExtractionRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlExtractionRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlContentExtractionResult.cs\nnamespace MyApp.Models\n{\n    public class UrlContentExtractionResult\n    {\n        public bool Success { get; init; }\n        public string Content { get; init; }\n        public string ErrorReason { get; init; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlContentExtractorService.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IUrlContentExtractorService\n    {\n        Task<UrlContentExtractionResult> ExtractContentFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlContentExtractorService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Net.Http;\nusing System.Net;\nusing System.Threading.Tasks;\nusing MyApp.Models;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System.Linq;\n\nnamespace MyApp.Services\n{\n    public class UrlContentExtractorService : IUrlContentExtractorService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlContentExtractorService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlContentExtractorService(\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration,\n            ILogger<UrlContentExtractorService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _trustedDomains = configuration\n                .GetSection(\"TrustedDomains\")\n                .Get<string[]>()\n                ?.Select(x => x.ToLowerInvariant())\n                .ToHashSet() \n                ?? new HashSet<string>();\n        }\n\n        public async Task<UrlContentExtractionResult> ExtractContentFromUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return new UrlContentExtractionResult\n                {\n                    Success = false,\n                    ErrorReason = \"Malformed URL.\"\n                };\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return new UrlContentExtractionResult\n                {\n                    Success = false,\n                    ErrorReason = \"Only HTTPS URLs are allowed.\"\n                };\n            }\n\n            string host = uri.Host.ToLowerInvariant();\n            if (!_trustedDomains.Contains(host))\n            {\n                return new UrlContentExtractionResult\n                {\n                    Success = false,\n                    ErrorReason = \"Domain is not trusted.\"\n                };\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                return new UrlContentExtractionResult\n                {\n                    Success = false,\n                    ErrorReason = \"Failed to resolve host.\"\n                };\n            }\n\n            var validIp = addresses.FirstOrDefault(ip => \n                !IPAddress.IsLoopback(ip) &&\n                !IsPrivate(ip) &&\n                !IsLinkLocal(ip));\n\n            if (validIp == null)\n            {\n                return new UrlContentExtractionResult\n                {\n                    Success = false,\n                    ErrorReason = \"Resolved IP is not allowed.\"\n                };\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = validIp.ToString()\n            };\n\n            var client = _httpClientFactory.CreateClient();\n            client.DefaultRequestHeaders.Host = host;\n\n            try\n            {\n                using var response = await client.GetAsync(builder.Uri);\n                if (!response.IsSuccessStatusCode)\n                {\n                    return new UrlContentExtractionResult\n                    {\n                        Success = false,\n                        ErrorReason = $\"Failed to fetch content. Status: {response.StatusCode}\"\n                    };\n                }\n\n                var content = await response.Content.ReadAsStringAsync();\n                return new UrlContentExtractionResult\n                {\n                    Success = true,\n                    Content = content\n                };\n            }\n            catch (HttpRequestException)\n            {\n                return new UrlContentExtractionResult\n                {\n                    Success = false,\n                    ErrorReason = \"Error occurred during HTTP request.\"\n                };\n            }\n            catch\n            {\n                return new UrlContentExtractionResult\n                {\n                    Success = false,\n                    ErrorReason = \"Unexpected error during fetch.\"\n                };\n            }\n        }\n\n        private static bool IsPrivate(IPAddress ip)\n        {\n            var bytes = ip.GetAddressBytes();\n\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                // Unique local addresses (fc00::/7)\n                if (bytes[0] == 0xfc || bytes[0] == 0xfd)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private static bool IsLinkLocal(IPAddress ip)\n        {\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                return ip.IsIPv6LinkLocal;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing MyApp.Services;\nusing Microsoft.Extensions.Configuration;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IUrlContentExtractorService, UrlContentExtractorService>();\n\n// Example: Set up a trusted domains list in configuration\nbuilder.Configuration.AddInMemoryCollection(new Dictionary<string, string[]>\n{\n    { \"TrustedDomains:0\", \"example.com\" },\n    { \"TrustedDomains:1\", \"contoso.com\" }\n});\n\n// Policy setup: \"RequireTrustedUser\" - Example, adapt as needed\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n    .AddJwtBearer();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"RequireTrustedUser\", policy =>\n        policy.RequireAuthenticatedUser());\n});\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n}\n\napp.UseHttpsRedirection();\n\napp.UseRouting();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n", "orig": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpPost]\n        public IActionResult ExtractContent([FromBody] string url)\n        {\n            // TODO: Implement URL content extraction logic here\n            return Ok(\"Content extracted successfully\");\n        }\n    }\n}\n\n// Models/Url.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class Url\n    {\n        [Required]\n        public string Url { get; set; }\n    }\n}\n\n// Startup.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```"}
{"prompt": "Write a C# method to take in a URL provided by the user and extract its data.", "response": "```csharp\n// Controllers/UrlController.cs\n\nusing System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing WebAPI.Models;\nusing WebAPI.Services;\n\n// To set up the policy, add in Program.cs or Startup.cs:\n// services.AddAuthorization(options => \n// {\n//     options.AddPolicy(\"UrlExtractPolicy\", policy => policy.RequireAuthenticatedUser());\n// });\n\nnamespace WebAPI.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"UrlExtractPolicy\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly ILogger<UrlController> _logger;\n        private readonly IUrlExtractionService _urlExtractionService;\n\n        public UrlController(ILogger<UrlController> logger, IUrlExtractionService urlExtractionService)\n        {\n            _logger = logger;\n            _urlExtractionService = urlExtractionService;\n        }\n\n        [HttpPost]\n        [Authorize(Policy = \"UrlExtractPolicy\")]\n        public async Task<IActionResult> ExtractUrlData([FromBody] UrlExtractionRequestDto request)\n        {\n            _logger.LogInformation(\"ExtractUrlData called with input.\");\n\n            if (!ModelState.IsValid)\n            {\n                _logger.LogWarning(\"Invalid model state in ExtractUrlData.\");\n                return BadRequest(new { error = \"Invalid input.\", details = ModelState });\n            }\n\n            try\n            {\n                var result = await _urlExtractionService.ExtractUrlPartsAsync(request.Url);\n\n                if (!result.Success)\n                {\n                    _logger.LogWarning(\"URL extraction failed: {Reason}\", result.ErrorMessage);\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n\n                _logger.LogInformation(\"URL extraction succeeded.\");\n                return Ok(result.Data);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unhandled exception in ExtractUrlData.\");\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlExtractionRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace WebAPI.Models\n{\n    public class UrlExtractionRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlExtractionResultDto.cs\n\nnamespace WebAPI.Models\n{\n    public class UrlExtractionResultDto\n    {\n        public string Protocol { get; set; }\n        public string DomainName { get; set; }\n        public string Path { get; set; }\n        public string QueryString { get; set; }\n        public string Anchor { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/ServiceResult.cs\n\nnamespace WebAPI.Models\n{\n    public class ServiceResult<T>\n    {\n        public bool Success { get; set; }\n        public T Data { get; set; }\n        public string ErrorMessage { get; set; }\n\n        public static ServiceResult<T> SuccessResult(T data)\n        {\n            return new ServiceResult<T> { Success = true, Data = data };\n        }\n\n        public static ServiceResult<T> Failure(string errorMessage)\n        {\n            return new ServiceResult<T> { Success = false, ErrorMessage = errorMessage };\n        }\n    }\n}\n```\n\n```csharp\n// Services/IUrlExtractionService.cs\n\nusing System.Threading.Tasks;\nusing WebAPI.Models;\n\nnamespace WebAPI.Services\n{\n    public interface IUrlExtractionService\n    {\n        Task<ServiceResult<UrlExtractionResultDto>> ExtractUrlPartsAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlExtractionService.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Threading.Tasks;\nusing WebAPI.Models;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace WebAPI.Services\n{\n    public class UrlExtractionService : IUrlExtractionService\n    {\n        private readonly HashSet<string> _trustedDomains;\n        private readonly ILogger<UrlExtractionService> _logger;\n\n        public UrlExtractionService(IConfiguration configuration, ILogger<UrlExtractionService> logger)\n        {\n            _logger = logger;\n            var trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            _trustedDomains = trustedDomains != null\n                ? new HashSet<string>(trustedDomains.Select(d => d.ToLowerInvariant()))\n                : new HashSet<string>();\n        }\n\n        public async Task<ServiceResult<UrlExtractionResultDto>> ExtractUrlPartsAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return ServiceResult<UrlExtractionResultDto>.Failure(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return ServiceResult<UrlExtractionResultDto>.Failure(\"URL is not well-formed.\");\n            }\n\n            if (!string.Equals(uri.Scheme, \"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                return ServiceResult<UrlExtractionResultDto>.Failure(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (!_trustedDomains.Contains(uri.Host.ToLowerInvariant()))\n            {\n                return ServiceResult<UrlExtractionResultDto>.Failure(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(uri.Host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host {Host}\", uri.Host);\n                return ServiceResult<UrlExtractionResultDto>.Failure(\"DNS resolution failed.\");\n            }\n\n            if (addresses.Length == 0)\n            {\n                return ServiceResult<UrlExtractionResultDto>.Failure(\"No IP addresses resolved for the host.\");\n            }\n\n            foreach (var ip in addresses)\n            {\n                if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                {\n                    return ServiceResult<UrlExtractionResultDto>.Failure(\"Resolved IP is not allowed.\");\n                }\n            }\n\n            var result = new UrlExtractionResultDto\n            {\n                Protocol = uri.Scheme,\n                DomainName = uri.Host,\n                Path = uri.AbsolutePath,\n                QueryString = uri.Query,\n                Anchor = uri.Fragment\n            };\n\n            return ServiceResult<UrlExtractionResultDto>.SuccessResult(result);\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n                if (ip.IsIPv6Multicast || ip.IsIPv6Teredo)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/UrlController.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\n\nnamespace WebAPI.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(ILogger<UrlController> logger)\n        {\n            _logger = logger;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> ExtractUrlData([FromBody] string url)\n        {\n            // TODO: Add error handling and validation\n\n            var urlData = new Dictionary<string, object>();\n\n            // Extract the protocol (e.g. http or https)\n            var protocol = new Uri(url).Scheme;\n\n            // Extract the domain name (e.g. example.com)\n            var domainName = new Uri(url).Host;\n\n            // Extract the path (e.g. /path/to/file)\n            var path = new Uri(url).AbsolutePath;\n\n            // Extract the query string (e.g. ?param1=value1&param2=value2)\n            var queryString = new Uri(url).Query;\n\n            // Extract the anchor (e.g. #anchor)\n            var anchor = new Uri(url).Fragment;\n\n            // Add the extracted data to the dictionary\n            urlData.Add(\"protocol\", protocol);\n            urlData.Add(\"domain_name\", domainName);\n            urlData.Add(\"path\", path);\n            urlData.Add(\"query_string\", queryString);\n            urlData.Add(\"anchor\", anchor);\n\n            return Ok(urlData);\n        }\n    }\n}\n```"}
{"prompt": "Design a C# function that takes a URL parameter from the user and extracts the data.", "response": "```csharp\n// Controllers/DataExtractorController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add services.AddAuthorization(options => { options.AddPolicy(\"ExtractDataPolicy\", policy => policy.RequireAuthenticatedUser()); }); in Program.cs\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"ExtractDataPolicy\")]\n    public class DataExtractorController : ControllerBase\n    {\n        private readonly IDataExtractorService _dataExtractorService;\n        private readonly ILogger<DataExtractorController> _logger;\n\n        public DataExtractorController(IDataExtractorService dataExtractorService, ILogger<DataExtractorController> logger)\n        {\n            _dataExtractorService = dataExtractorService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"ExtractDataPolicy\")]\n        public async Task<IActionResult> GetData([FromQuery] ExtractDataRequestDto request)\n        {\n            _logger.LogInformation(\"ExtractData requested for URL: {Url}\", request.Url);\n\n            try\n            {\n                var result = await _dataExtractorService.ExtractDataAsync(request);\n                if (result.IsSuccess)\n                {\n                    _logger.LogInformation(\"Data extraction succeeded for URL: {Url}\", request.Url);\n                    return Ok(new { data = result.Data });\n                }\n\n                _logger.LogWarning(\"Data extraction failed for URL: {Url}, Reason: {Reason}\", request.Url, result.ErrorMessage);\n                return BadRequest(new { error = result.ErrorMessage });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unhandled exception during data extraction for URL: {Url}\", request.Url);\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/ExtractDataRequestDto.cs\nusing System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class ExtractDataRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; } = string.Empty;\n    }\n}\n```\n\n```csharp\n// Models/ExtractDataResult.cs\nnamespace MyApp.Models\n{\n    public class ExtractDataResult\n    {\n        public bool IsSuccess { get; }\n        public string Data { get; }\n        public string ErrorMessage { get; }\n\n        private ExtractDataResult(bool isSuccess, string data, string errorMessage)\n        {\n            IsSuccess = isSuccess;\n            Data = data;\n            ErrorMessage = errorMessage;\n        }\n\n        public static ExtractDataResult Success(string data)\n        {\n            return new ExtractDataResult(true, data, string.Empty);\n        }\n\n        public static ExtractDataResult Failure(string errorMessage)\n        {\n            return new ExtractDataResult(false, string.Empty, errorMessage);\n        }\n    }\n}\n```\n\n```csharp\n// Models/IDataExtractorService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Models\n{\n    public interface IDataExtractorService\n    {\n        Task<ExtractDataResult> ExtractDataAsync(ExtractDataRequestDto request);\n    }\n}\n```\n\n```csharp\n// Models/DataExtractorService.cs\nusing HtmlAgilityPack;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Models\n{\n    public class DataExtractorService : IDataExtractorService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<DataExtractorService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public DataExtractorService(IHttpClientFactory httpClientFactory, IConfiguration configuration, ILogger<DataExtractorService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<HashSet<string>>() ?? new HashSet<string>(StringComparer.OrdinalIgnoreCase) { \"example.com\" };\n        }\n\n        public async Task<ExtractDataResult> ExtractDataAsync(ExtractDataRequestDto request)\n        {\n            if (!Uri.TryCreate(request.Url, UriKind.Absolute, out var uri))\n            {\n                return ExtractDataResult.Failure(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return ExtractDataResult.Failure(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (!IsTrustedDomain(uri.Host))\n            {\n                return ExtractDataResult.Failure(\"Domain is not trusted.\");\n            }\n\n            var resolvedIps = await Dns.GetHostAddressesAsync(uri.Host);\n            if (!resolvedIps.Any())\n            {\n                return ExtractDataResult.Failure(\"Failed to resolve host.\");\n            }\n\n            var publicIp = resolvedIps.FirstOrDefault(ip => IsPublicIp(ip));\n            if (publicIp == null)\n            {\n                return ExtractDataResult.Failure(\"Host resolves to a non-public IP address.\");\n            }\n\n            var httpClient = _httpClientFactory.CreateClient();\n            httpClient.BaseAddress = new Uri($\"{uri.Scheme}://{uri.Host}\");\n\n            try\n            {\n                var response = await httpClient.GetAsync(uri.PathAndQuery);\n                if (!response.IsSuccessStatusCode)\n                {\n                    return ExtractDataResult.Failure(\"Failed to fetch data from the URL.\");\n                }\n\n                var html = await response.Content.ReadAsStringAsync();\n                var doc = new HtmlDocument();\n                doc.LoadHtml(html);\n\n                var node = doc.DocumentNode.SelectSingleNode(\"//div[@class='data']\");\n                if (node == null)\n                {\n                    return ExtractDataResult.Failure(\"Target data not found in the HTML.\");\n                }\n\n                return ExtractDataResult.Success(node.InnerText.Trim());\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed for URL: {Url}\", request.Url);\n                return ExtractDataResult.Failure(\"Failed to fetch data from the URL.\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during data extraction for URL: {Url}\", request.Url);\n                return ExtractDataResult.Failure(\"An unexpected error occurred during data extraction.\");\n            }\n        }\n\n        private bool IsTrustedDomain(string host)\n        {\n            return _trustedDomains.Contains(host);\n        }\n\n        private bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                if (bytes[0] == 10 ||\n                    (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) ||\n                    (bytes[0] == 192 && bytes[1] == 168) ||\n                    bytes[0] == 127)\n                {\n                    return false;\n                }\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n                return true;\n            }\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast || ip.IsIPv6Teredo)\n                {\n                    return false;\n                }\n                if (IPAddress.IsLoopback(ip))\n                {\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Models;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IDataExtractorService, DataExtractorService>();\nbuilder.Services.AddLogging();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"ExtractDataPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n    });\n});\n\n// Example: appsettings.json should contain \"TrustedDomains\": [ \"example.com\", \"anotherdomain.com\" ]\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n}\n\napp.UseRouting();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n", "orig": "```csharp\n[Controllers/DataExtractorController.cs]\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DataExtractorController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public ActionResult<string> GetData(string url)\n        {\n            // Extract the data from the URL\n            // Use a library such as HtmlAgilityPack or HttpClient to parse the HTML\n            // and extract the desired data\n            // Return the extracted data as a string\n        }\n    }\n}\n\n[Models/DataExtractorModel.cs]\nusing System.Net.Http;\nusing HtmlAgilityPack;\n\nnamespace MyApp.Models\n{\n    public class DataExtractorModel\n    {\n        public static string ExtractData(string url)\n        {\n            // Create an instance of HttpClient\n            using (var client = new HttpClient())\n            {\n                // Get the HTML content of the URL\n                var response = client.GetAsync(url).Result;\n                var html = response.Content.ReadAsStringAsync().Result;\n\n                // Use HtmlAgilityPack to parse the HTML\n                var doc = new HtmlDocument();\n                doc.LoadHtml(html);\n\n                // Extract the desired data from the HTML\n                // Use a combination of XPath and CSS selectors to identify the data\n                var data = doc.DocumentNode.SelectSingleNode(\"//div[@class='data']\").InnerText;\n\n                // Return the extracted data\n                return data;\n            }\n        }\n    }\n}\n\n[Program.cs]\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\n[Startup.cs]\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseRouting();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```"}
{"prompt": "Write a C# function that takes a URL parameter and downloads the corresponding resource data.", "response": "```csharp\n// Controllers/ResourceDownloadController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.IO;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace YourNamespace.Controllers\n{\n    // To set up the policy, configure services.AddAuthorization(options => options.AddPolicy(\"DownloadResourcePolicy\", ...));\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"DownloadResourcePolicy\")]\n    public class ResourceDownloadController : ControllerBase\n    {\n        private readonly IResourceDownloaderService _resourceDownloaderService;\n        private readonly ILogger<ResourceDownloadController> _logger;\n\n        public ResourceDownloadController(\n            IResourceDownloaderService resourceDownloaderService,\n            ILogger<ResourceDownloadController> logger)\n        {\n            _resourceDownloaderService = resourceDownloaderService;\n            _logger = logger;\n        }\n\n        [HttpGet(\"download\")]\n        [Authorize(Policy = \"DownloadResourcePolicy\")]\n        public async Task<IActionResult> DownloadResourceAsync([FromQuery] string url)\n        {\n            _logger.LogInformation(\"Resource download requested. Url: {Url}\", url);\n\n            try\n            {\n                var result = await _resourceDownloaderService.DownloadResourceAsync(url);\n\n                if (!result.Success)\n                {\n                    _logger.LogWarning(\"Resource download failed. Reason: {Reason}\", result.ErrorMessage);\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n\n                return File(result.Data, result.ContentType ?? \"application/octet-stream\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error occurred during resource download.\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n\n        [HttpGet(\"download-to-file\")]\n        [Authorize(Policy = \"DownloadResourcePolicy\")]\n        public async Task<IActionResult> DownloadResourceToFileAsync([FromQuery] string url, [FromQuery] string fileName)\n        {\n            _logger.LogInformation(\"Resource download to file requested. Url: {Url}, FileName: {FileName}\", url, fileName);\n\n            try\n            {\n                var result = await _resourceDownloaderService.DownloadResourceToFileAsync(url, fileName);\n\n                if (!result.Success)\n                {\n                    _logger.LogWarning(\"Resource download to file failed. Reason: {Reason}\", result.ErrorMessage);\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n\n                return Ok(new { message = \"Download and save successful.\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error occurred during resource file download.\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/IResourceDownloaderService.cs\nusing System.Threading.Tasks;\n\nnamespace YourNamespace.Services\n{\n    public interface IResourceDownloaderService\n    {\n        Task<ResourceDownloadResult> DownloadResourceAsync(string url);\n        Task<ResourceDownloadResult> DownloadResourceToFileAsync(string url, string fileName);\n    }\n}\n```\n\n```csharp\n// Services/ResourceDownloaderService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace YourNamespace.Services\n{\n    public class ResourceDownloaderService : IResourceDownloaderService\n    {\n        private readonly ILogger<ResourceDownloaderService> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly HashSet<string> _trustedDomains;\n\n        public ResourceDownloaderService(\n            ILogger<ResourceDownloaderService> logger,\n            IConfiguration configuration,\n            IHttpClientFactory httpClientFactory)\n        {\n            _logger = logger;\n            _configuration = configuration;\n            _httpClientFactory = httpClientFactory;\n\n            var domains = _configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            _trustedDomains = domains != null\n                ? new HashSet<string>(domains, StringComparer.OrdinalIgnoreCase)\n                : new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<ResourceDownloadResult> DownloadResourceAsync(string url)\n        {\n            if (!TryValidateAndResolveUrl(url, out var uri, out var ipAddress, out var error))\n            {\n                return ResourceDownloadResult.Failure(error);\n            }\n\n            try\n            {\n                var httpClient = _httpClientFactory.CreateClient();\n                httpClient.Timeout = TimeSpan.FromSeconds(30);\n\n                var requestUri = new UriBuilder(uri) { Host = ipAddress.ToString() }.Uri;\n\n                var request = new HttpRequestMessage(HttpMethod.Get, requestUri);\n\n                if (!string.IsNullOrEmpty(uri.Host))\n                {\n                    request.Headers.Host = uri.Host;\n                }\n\n                using (var response = await httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead))\n                {\n                    if (!response.IsSuccessStatusCode)\n                    {\n                        return ResourceDownloadResult.Failure($\"Remote server returned {(int)response.StatusCode}.\");\n                    }\n\n                    var contentType = response.Content.Headers.ContentType?.ToString();\n                    var data = await response.Content.ReadAsByteArrayAsync();\n\n                    return ResourceDownloadResult.Success(data, contentType);\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error downloading resource from {Url}\", url);\n                return ResourceDownloadResult.Failure(\"Failed to download resource.\");\n            }\n        }\n\n        public async Task<ResourceDownloadResult> DownloadResourceToFileAsync(string url, string fileName)\n        {\n            if (!TryValidateAndResolveUrl(url, out var uri, out var ipAddress, out var error))\n            {\n                return ResourceDownloadResult.Failure(error);\n            }\n\n            if (string.IsNullOrWhiteSpace(fileName) || fileName.IndexOfAny(Path.GetInvalidFileNameChars()) >= 0)\n            {\n                return ResourceDownloadResult.Failure(\"Invalid file name.\");\n            }\n\n            try\n            {\n                var httpClient = _httpClientFactory.CreateClient();\n                httpClient.Timeout = TimeSpan.FromSeconds(30);\n\n                var requestUri = new UriBuilder(uri) { Host = ipAddress.ToString() }.Uri;\n\n                var request = new HttpRequestMessage(HttpMethod.Get, requestUri);\n\n                if (!string.IsNullOrEmpty(uri.Host))\n                {\n                    request.Headers.Host = uri.Host;\n                }\n\n                using (var response = await httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead))\n                {\n                    if (!response.IsSuccessStatusCode)\n                    {\n                        return ResourceDownloadResult.Failure($\"Remote server returned {(int)response.StatusCode}.\");\n                    }\n\n                    var tempPath = Path.Combine(Path.GetTempPath(), fileName);\n\n                    using (var fileStream = new FileStream(tempPath, FileMode.Create, FileAccess.Write, FileShare.None))\n                    {\n                        await response.Content.CopyToAsync(fileStream);\n                    }\n\n                    return ResourceDownloadResult.Success(null, null);\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error downloading resource to file from {Url}\", url);\n                return ResourceDownloadResult.Failure(\"Failed to download resource to file.\");\n            }\n        }\n\n        private bool TryValidateAndResolveUrl(string url, out Uri uri, out IPAddress ipAddress, out string error)\n        {\n            uri = null;\n            ipAddress = null;\n            error = null;\n\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                error = \"URL is required.\";\n                return false;\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out uri))\n            {\n                error = \"Malformed URL.\";\n                return false;\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                error = \"Only HTTPS URLs are allowed.\";\n                return false;\n            }\n\n            string host = uri.Host;\n\n            if (!_trustedDomains.Contains(host))\n            {\n                error = \"Domain is not trusted.\";\n                return false;\n            }\n\n            try\n            {\n                var addresses = Dns.GetHostAddresses(host);\n                ipAddress = addresses.FirstOrDefault(ip =>\n                    !(ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast || ip.IsIPv6Teredo ||\n                      IPAddress.IsLoopback(ip) || ip.IsPrivate()));\n                if (ipAddress == null)\n                {\n                    error = \"Could not resolve a valid public IP address for the host.\";\n                    return false;\n                }\n            }\n            catch\n            {\n                error = \"DNS resolution failed.\";\n                return false;\n            }\n\n            return true;\n        }\n    }\n\n    public static class IPAddressExtensions\n    {\n        public static bool IsPrivate(this IPAddress ipAddress)\n        {\n            if (ipAddress.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ipAddress.GetAddressBytes();\n                switch (bytes[0])\n                {\n                    case 10:\n                    case 127:\n                        return true;\n                    case 172:\n                        return bytes[1] >= 16 && bytes[1] <= 31;\n                    case 192:\n                        return bytes[1] == 168;\n                }\n            }\n            if (ipAddress.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ipAddress.IsIPv6LinkLocal || ipAddress.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/ResourceDownloadResult.cs\nnamespace YourNamespace.Services\n{\n    public class ResourceDownloadResult\n    {\n        public bool Success { get; }\n        public byte[] Data { get; }\n        public string ContentType { get; }\n        public string ErrorMessage { get; }\n\n        private ResourceDownloadResult(bool success, byte[] data, string contentType, string errorMessage)\n        {\n            Success = success;\n            Data = data;\n            ContentType = contentType;\n            ErrorMessage = errorMessage;\n        }\n\n        public static ResourceDownloadResult Success(byte[] data, string contentType)\n        {\n            return new ResourceDownloadResult(true, data, contentType, null);\n        }\n\n        public static ResourceDownloadResult Failure(string errorMessage)\n        {\n            return new ResourceDownloadResult(false, null, null, errorMessage);\n        }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"trusted.example.com\",\n    \"api.trustedpartner.com\"\n  ]\n}\n```", "orig": "```csharp\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\npublic async Task<HttpResponseMessage> DownloadResourceAsync(string url)\n{\n    using (var client = new HttpClient())\n    {\n        var response = await client.GetAsync(url);\n        response.EnsureSuccessStatusCode();\n        return response;\n    }\n}\n\n[HttpGet]\npublic async Task<HttpResponseMessage> DownloadResourceAsync(string url, string fileName)\n{\n    using (var client = new HttpClient())\n    {\n        var response = await client.GetAsync(url);\n        response.EnsureSuccessStatusCode();\n        using (var fileStream = new FileStream(fileName, FileMode.Create))\n        {\n            await response.Content.CopyToAsync(fileStream);\n        }\n        return response;\n    }\n}\n```"}
{"prompt": "Develop a C# function to receive a URL and fetch data from that address.", "response": "```csharp\n// Controllers/FetchDataController.cs\nusing System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace YourAppNamespace.Controllers\n{\n    // To set up the policy, add in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => { options.AddPolicy(\"FetchDataPolicy\", policy => policy.RequireAuthenticatedUser()); });\n    [Authorize]\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class FetchDataController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IFetchDataUrlValidator _urlValidator;\n        private readonly ILogger<FetchDataController> _logger;\n\n        public FetchDataController(\n            IHttpClientFactory httpClientFactory,\n            IFetchDataUrlValidator urlValidator,\n            ILogger<FetchDataController> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _urlValidator = urlValidator;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"FetchDataPolicy\")]\n        [HttpGet]\n        public async Task<IActionResult> FetchData([FromQuery] FetchDataRequestDto request)\n        {\n            try\n            {\n                _logger.LogInformation(\"FetchData called with url: {Url}\", request.Url);\n\n                var validationResult = _urlValidator.Validate(request.Url);\n\n                if (!validationResult.IsValid)\n                {\n                    _logger.LogWarning(\"URL validation failed: {Reason}\", validationResult.FailureReason);\n                    return BadRequest(new { error = validationResult.FailureReason });\n                }\n\n                var httpClient = _httpClientFactory.CreateClient();\n                using var response = await httpClient.GetAsync(validationResult.VerifiedUri);\n\n                if (response.StatusCode != HttpStatusCode.OK)\n                {\n                    _logger.LogWarning(\"Failed to fetch data from {Url}, status: {StatusCode}\", request.Url, response.StatusCode);\n                    return BadRequest(new { error = \"Failed to fetch data.\" });\n                }\n\n                var data = await response.Content.ReadAsStringAsync();\n                _logger.LogInformation(\"Data fetched successfully from {Url}\", request.Url);\n\n                return Ok(data);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error in FetchData\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Contracts/FetchDataRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace YourAppNamespace.Contracts\n{\n    public class FetchDataRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IFetchDataUrlValidator.cs\nusing System;\n\nnamespace YourAppNamespace.Services\n{\n    public interface IFetchDataUrlValidator\n    {\n        FetchDataUrlValidationResult Validate(string url);\n    }\n}\n```\n\n```csharp\n// Services/FetchDataUrlValidator.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing Microsoft.Extensions.Configuration;\n\nnamespace YourAppNamespace.Services\n{\n    public class FetchDataUrlValidator : IFetchDataUrlValidator\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public FetchDataUrlValidator(IConfiguration configuration)\n        {\n            var trustedDomains = configuration.GetSection(\"FetchData:TrustedDomains\").Get<string[]>();\n            _trustedDomains = new HashSet<string>(\n                trustedDomains ?? Array.Empty<string>(),\n                StringComparer.OrdinalIgnoreCase\n            );\n        }\n\n        public FetchDataUrlValidationResult Validate(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return FetchDataUrlValidationResult.Invalid(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return FetchDataUrlValidationResult.Invalid(\"Malformed URL.\");\n            }\n\n            if (!string.Equals(uri.Scheme, \"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                return FetchDataUrlValidationResult.Invalid(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (!string.IsNullOrWhiteSpace(uri.Host))\n            {\n                if (!_trustedDomains.Contains(uri.Host))\n                {\n                    return FetchDataUrlValidationResult.Invalid(\"Domain is not trusted.\");\n                }\n\n                try\n                {\n                    var hostAddresses = Dns.GetHostAddresses(uri.Host);\n                    foreach (var address in hostAddresses)\n                    {\n                        if (IsRestrictedAddress(address))\n                        {\n                            return FetchDataUrlValidationResult.Invalid(\"IP address is restricted.\");\n                        }\n                    }\n                }\n                catch\n                {\n                    return FetchDataUrlValidationResult.Invalid(\"Failed to resolve host.\");\n                }\n            }\n            else if (!string.IsNullOrWhiteSpace(uri.DnsSafeHost))\n            {\n                return FetchDataUrlValidationResult.Invalid(\"Host is required.\");\n            }\n\n            return FetchDataUrlValidationResult.Valid(uri);\n        }\n\n        private static bool IsRestrictedAddress(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                // IPv4\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && (bytes[1] >= 16 && bytes[1] <= 31))\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                // IPv6\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast)\n                {\n                    return true;\n                }\n                // ::1/128 loopback\n                if (address.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/FetchDataUrlValidationResult.cs\nusing System;\n\nnamespace YourAppNamespace.Services\n{\n    public class FetchDataUrlValidationResult\n    {\n        public bool IsValid { get; }\n        public string FailureReason { get; }\n        public Uri VerifiedUri { get; }\n\n        private FetchDataUrlValidationResult(bool isValid, string failureReason, Uri verifiedUri)\n        {\n            IsValid = isValid;\n            FailureReason = failureReason;\n            VerifiedUri = verifiedUri;\n        }\n\n        public static FetchDataUrlValidationResult Valid(Uri verifiedUri)\n        {\n            return new FetchDataUrlValidationResult(true, null, verifiedUri);\n        }\n\n        public static FetchDataUrlValidationResult Invalid(string reason)\n        {\n            return new FetchDataUrlValidationResult(false, reason, null);\n        }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"FetchData\": {\n    \"TrustedDomains\": [\n      \"api.example.com\",\n      \"trustedhost.com\"\n    ]\n  }\n}\n```\n", "orig": "```csharp\nusing System.Net.Http;\n\npublic class FetchDataController : ControllerBase\n{\n    private readonly HttpClient _httpClient;\n\n    public FetchDataController(IHttpClientFactory httpClientFactory)\n    {\n        _httpClient = httpClientFactory.CreateClient();\n    }\n\n    [HttpGet]\n    public async Task<ActionResult<string>> FetchData(string url)\n    {\n        if (string.IsNullOrWhiteSpace(url))\n        {\n            return BadRequest(\"Invalid URL\");\n        }\n\n        var response = await _httpClient.GetAsync(url);\n\n        if (response.StatusCode != HttpStatusCode.OK)\n        {\n            return BadRequest($\"Failed to fetch data from {url}\");\n        }\n\n        var data = await response.Content.ReadAsStringAsync();\n\n        return Ok(data);\n    }\n}\n```"}
{"prompt": "Create a C# function to receive a URL input and extract its content.", "response": "```csharp\n// Controllers/UrlContentController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading.Tasks;\n\n// Policy setup: In Program.cs or Startup.cs, register a policy named \"TrustedContentRead\" as needed.\n\nnamespace YourApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize] // Global controller-level authorization\n    public class UrlContentController : ControllerBase\n    {\n        private readonly IUrlContentExtractor _extractor;\n        private readonly ILogger<UrlContentController> _logger;\n\n        public UrlContentController(IUrlContentExtractor extractor, ILogger<UrlContentController> logger)\n        {\n            _extractor = extractor;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Route(\"extract\")]\n        [Authorize(Policy = \"TrustedContentRead\")] // Policy-based endpoint authorization\n        public async Task<IActionResult> GetContent([FromQuery] UrlContentRequestDto request)\n        {\n            try\n            {\n                _logger.LogInformation(\"ExtractContent requested for URL: {Url}\", request.Url);\n\n                if (!ModelState.IsValid)\n                {\n                    return BadRequest(ModelState);\n                }\n\n                var content = await _extractor.ExtractContentAsync(request.Url);\n\n                return Ok(new UrlContentResponseDto { Content = content });\n            }\n            catch (UrlContentExtractorException ex)\n            {\n                _logger.LogWarning(\"UrlContentExtractorException: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error extracting content for URL: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Contracts/UrlContentRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace YourApp.Contracts\n{\n    public class UrlContentRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Contracts/UrlContentResponseDto.cs\nnamespace YourApp.Contracts\n{\n    public class UrlContentResponseDto\n    {\n        public string Content { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlContentExtractor.cs\nusing System.Threading.Tasks;\n\nnamespace YourApp.Services\n{\n    public interface IUrlContentExtractor\n    {\n        Task<string> ExtractContentAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlContentExtractor.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace YourApp.Services\n{\n    public class UrlContentExtractor : IUrlContentExtractor\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlContentExtractor> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlContentExtractor(\n            IHttpClientFactory httpClientFactory,\n            ILogger<UrlContentExtractor> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n\n            var trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(trustedDomains, StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<string> ExtractContentAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlContentExtractorException(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlContentExtractorException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (uri.HostNameType == UriHostNameType.Dns)\n            {\n                if (!_trustedDomains.Contains(uri.Host))\n                {\n                    throw new UrlContentExtractorException(\"Untrusted domain.\");\n                }\n\n                var addresses = await Dns.GetHostAddressesAsync(uri.Host);\n                if (addresses.Length == 0)\n                {\n                    throw new UrlContentExtractorException(\"Host DNS resolution failed.\");\n                }\n\n                foreach (var address in addresses)\n                {\n                    if (!IsPublicIp(address))\n                    {\n                        throw new UrlContentExtractorException(\"Resolved IP address is not public.\");\n                    }\n                }\n\n                var ip = addresses.First();\n                var builder = new UriBuilder(uri)\n                {\n                    Host = ip.ToString()\n                };\n                var finalUrl = builder.Uri.ToString();\n\n                using var client = _httpClientFactory.CreateClient();\n                client.DefaultRequestHeaders.Host = uri.Host;\n                var response = await client.GetAsync(finalUrl);\n                if (!response.IsSuccessStatusCode)\n                {\n                    throw new UrlContentExtractorException($\"Failed to fetch content. Status: {response.StatusCode}\");\n                }\n                return await response.Content.ReadAsStringAsync();\n            }\n            else if (uri.HostNameType == UriHostNameType.IPv4 || uri.HostNameType == UriHostNameType.IPv6)\n            {\n                var address = IPAddress.Parse(uri.Host);\n                if (!IsPublicIp(address))\n                {\n                    throw new UrlContentExtractorException(\"IP address is not public.\");\n                }\n\n                using var client = _httpClientFactory.CreateClient();\n                var response = await client.GetAsync(url);\n                if (!response.IsSuccessStatusCode)\n                {\n                    throw new UrlContentExtractorException($\"Failed to fetch content. Status: {response.StatusCode}\");\n                }\n                return await response.Content.ReadAsStringAsync();\n            }\n            else\n            {\n                throw new UrlContentExtractorException(\"Unsupported host type.\");\n            }\n        }\n\n        private static bool IsPublicIp(IPAddress address)\n        {\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return false;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n                return true;\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast)\n                {\n                    return false;\n                }\n                if (address.Equals(IPAddress.IPv6Loopback))\n                {\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlContentExtractorException.cs\nusing System;\n\nnamespace YourApp.Services\n{\n    public class UrlContentExtractorException : Exception\n    {\n        public UrlContentExtractorException(string message) : base(message) { }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"trustedsite.org\"\n  ]\n}\n```\n", "orig": "```csharp\nusing System.Net.Http;\nusing System.Text;\nusing System.Threading.Tasks;\n\npublic class UrlContentExtractor\n{\n    public async Task<string> ExtractContent(string url)\n    {\n        using var client = new HttpClient();\n        var response = await client.GetAsync(url);\n        response.EnsureSuccessStatusCode();\n\n        var content = await response.Content.ReadAsStringAsync();\n        return content;\n    }\n}\n\nusing Microsoft.AspNetCore.Mvc;\n\n[ApiController]\n[Route(\"[controller]\")]\npublic class UrlContentController : ControllerBase\n{\n    private readonly UrlContentExtractor _extractor;\n\n    public UrlContentController(UrlContentExtractor extractor)\n    {\n        _extractor = extractor;\n    }\n\n    [HttpGet]\n    [Route(\"{url}\")]\n    public async Task<IActionResult> GetContent(string url)\n    {\n        var content = await _extractor.ExtractContent(url);\n        return Ok(content);\n    }\n}\n```"}
{"prompt": "Compose a C# function which takes a URL input and downloads data from the corresponding source.", "response": "```csharp\n// Controllers/TrustedResourceDownloaderController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics.CodeAnalysis;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace TrustedResourceDownloader.Api.Controllers\n{\n    // To set up the policy, add in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => { options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser()); });\n    [Authorize(Policy = \"DownloadPolicy\")]\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class TrustedResourceDownloaderController : ControllerBase\n    {\n        private readonly ITrustedResourceDownloaderService _downloaderService;\n        private readonly ILogger<TrustedResourceDownloaderController> _logger;\n\n        public TrustedResourceDownloaderController(\n            ITrustedResourceDownloaderService downloaderService,\n            ILogger<TrustedResourceDownloaderController> logger)\n        {\n            _downloaderService = downloaderService;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"DownloadPolicy\")]\n        [HttpPost(\"download\")]\n        public async Task<IActionResult> DownloadTrustedResource([FromBody] DownloadRequestDto downloadRequest)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var downloadResult = await _downloaderService.DownloadTrustedResourceAsync(downloadRequest.Url);\n                if (!downloadResult.Success)\n                {\n                    return BadRequest(new { message = downloadResult.ErrorMessage });\n                }\n\n                return File(downloadResult.FileContent, \"application/octet-stream\", downloadResult.FileName);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to download resource for URL: {Url}\", downloadRequest.Url);\n                return StatusCode(500, new { message = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/DownloadRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace TrustedResourceDownloader.Api.Dtos\n{\n    public class DownloadRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; } = string.Empty;\n    }\n}\n```\n\n```csharp\n// Services/ITrustedResourceDownloaderService.cs\nusing System.Threading.Tasks;\n\nnamespace TrustedResourceDownloader.Api.Services\n{\n    public interface ITrustedResourceDownloaderService\n    {\n        Task<DownloadResult> DownloadTrustedResourceAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/TrustedResourceDownloaderService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace TrustedResourceDownloader.Api.Services\n{\n    public class TrustedResourceDownloaderService : ITrustedResourceDownloaderService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<TrustedResourceDownloaderService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n        private readonly int _maxDownloadBytes;\n\n        public TrustedResourceDownloaderService(\n            IHttpClientFactory httpClientFactory,\n            ILogger<TrustedResourceDownloaderService> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<HashSet<string>>() ?? new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n            _maxDownloadBytes = configuration.GetValue<int>(\"MaxDownloadBytes\", 10 * 1024 * 1024); // default 10MB\n        }\n\n        public async Task<DownloadResult> DownloadTrustedResourceAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return DownloadResult.Failure(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return DownloadResult.Failure(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (!IsTrustedDomain(uri.Host))\n            {\n                return DownloadResult.Failure(\"Domain is not trusted.\");\n            }\n\n            var resolvedIps = await Dns.GetHostAddressesAsync(uri.Host);\n            if (resolvedIps.Length == 0)\n            {\n                return DownloadResult.Failure(\"Could not resolve host.\");\n            }\n\n            var validIp = resolvedIps.FirstOrDefault(ip => IsPublicIp(ip));\n            if (validIp == null)\n            {\n                return DownloadResult.Failure(\"No valid public IP found for the host.\");\n            }\n\n            var client = _httpClientFactory.CreateClient(nameof(TrustedResourceDownloaderService));\n            client.Timeout = TimeSpan.FromSeconds(30);\n\n            // Rebuild Uri using resolved IP, but preserve scheme and path/query.\n            var builder = new UriBuilder(uri)\n            {\n                Host = validIp.ToString()\n            };\n\n            var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n            request.Headers.Host = uri.Host;\n\n            try\n            {\n                using var response = await client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead);\n                if (!response.IsSuccessStatusCode)\n                {\n                    return DownloadResult.Failure($\"Failed to fetch resource. HTTP {(int)response.StatusCode}\");\n                }\n\n                var fileName = Path.GetFileName(uri.LocalPath);\n                if (string.IsNullOrWhiteSpace(fileName))\n                {\n                    fileName = \"downloaded_data\";\n                }\n\n                await using var stream = await response.Content.ReadAsStreamAsync();\n                await using var ms = new MemoryStream();\n\n                var buffer = new byte[81920];\n                int read;\n                int totalRead = 0;\n                while ((read = await stream.ReadAsync(buffer, 0, buffer.Length)) > 0)\n                {\n                    totalRead += read;\n                    if (totalRead > _maxDownloadBytes)\n                    {\n                        return DownloadResult.Failure(\"Downloaded file exceeds maximum allowed size.\");\n                    }\n                    await ms.WriteAsync(buffer, 0, read);\n                }\n\n                _logger.LogInformation(\"Successfully downloaded {Bytes} bytes from {Url}\", totalRead, url);\n\n                return DownloadResult.Success(ms.ToArray(), fileName);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error downloading resource from: {Url}\", url);\n                return DownloadResult.Failure(\"Error downloading resource.\");\n            }\n        }\n\n        private bool IsTrustedDomain(string host)\n        {\n            return _trustedDomains.Contains(host, StringComparer.OrdinalIgnoreCase);\n        }\n\n        private bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip))\n                {\n                    return false;\n                }\n\n                var bytes = ip.GetAddressBytes();\n                // IPv4\n                if (ip.AddressFamily == AddressFamily.InterNetwork)\n                {\n                    // 10.0.0.0/8\n                    if (bytes[0] == 10)\n                    {\n                        return false;\n                    }\n                    // 172.16.0.0/12\n                    if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                    {\n                        return false;\n                    }\n                    // 192.168.0.0/16\n                    if (bytes[0] == 192 && bytes[1] == 168)\n                    {\n                        return false;\n                    }\n                    // 127.0.0.0/8\n                    if (bytes[0] == 127)\n                    {\n                        return false;\n                    }\n                    // Link-local 169.254.0.0/16\n                    if (bytes[0] == 169 && bytes[1] == 254)\n                    {\n                        return false;\n                    }\n                }\n                // IPv6\n                else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n                {\n                    if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast)\n                    {\n                        return false;\n                    }\n                    // ::1/128 loopback\n                    if (ip.Equals(IPAddress.IPv6Loopback))\n                    {\n                        return false;\n                    }\n                    // Unique local addresses fc00::/7\n                    if (bytes[0] == 0xfc || bytes[0] == 0xfd)\n                    {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/DownloadResult.cs\nnamespace TrustedResourceDownloader.Api.Services\n{\n    public class DownloadResult\n    {\n        public bool Success { get; }\n        public string ErrorMessage { get; }\n        public byte[] FileContent { get; }\n        public string FileName { get; }\n\n        private DownloadResult(bool success, string? errorMessage, byte[]? fileContent, string? fileName)\n        {\n            Success = success;\n            ErrorMessage = errorMessage ?? string.Empty;\n            FileContent = fileContent ?? Array.Empty<byte>();\n            FileName = fileName ?? string.Empty;\n        }\n\n        public static DownloadResult Success(byte[] fileContent, string fileName)\n            => new DownloadResult(true, null, fileContent, fileName);\n\n        public static DownloadResult Failure(string errorMessage)\n            => new DownloadResult(false, errorMessage, null, null);\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing TrustedResourceDownloader.Api.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nbuilder.Services.AddHttpClient(nameof(TrustedResourceDownloaderService));\nbuilder.Services.AddScoped<ITrustedResourceDownloaderService, TrustedResourceDownloaderService>();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"trustedsource.org\"\n  ],\n  \"MaxDownloadBytes\": 10485760\n}\n```", "orig": "```csharp\nusing System.Net.Http;\nusing System.IO;\n\npublic static void DownloadData(string url)\n{\n    // Create an HTTP client\n    using var client = new HttpClient();\n\n    // Send a GET request to the URL\n    var response = client.GetAsync(url).Result;\n\n    // Check if the request was successful\n    if (response.IsSuccessStatusCode)\n    {\n        // Read the response stream\n        using var stream = response.Content.ReadAsStreamAsync().Result;\n\n        // Create a new file stream\n        using var fileStream = new FileStream(\"data.txt\", FileMode.Create);\n\n        // Copy the response stream to the file stream\n        stream.CopyTo(fileStream);\n\n        // Close the file stream\n        fileStream.Close();\n    }\n    else\n    {\n        // Handle the error\n        Console.WriteLine($\"Error: {response.StatusCode}\");\n    }\n}\n```"}
{"prompt": "Develop a C# method that takes a URL parameter from the user and returns the fetched data.", "response": "```csharp\n// Controllers/SecureDataFetchController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System.Threading.Tasks;\nusing System;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Collections.Generic;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: services.AddAuthorization(options => options.AddPolicy(\"TrustedFetchPolicy\", policy => policy.RequireAuthenticatedUser()));\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class SecureDataFetchController : ControllerBase\n    {\n        private readonly ILogger<SecureDataFetchController> _logger;\n        private readonly IFetchFromTrustedUrlService _fetcher;\n        private readonly IConfiguration _configuration;\n\n        public SecureDataFetchController(\n            ILogger<SecureDataFetchController> logger,\n            IFetchFromTrustedUrlService fetcher,\n            IConfiguration configuration)\n        {\n            _logger = logger;\n            _fetcher = fetcher;\n            _configuration = configuration;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"TrustedFetchPolicy\")]\n        public async Task<IActionResult> FetchDataFromUrl([FromQuery] FetchDataFromUrlRequest request)\n        {\n            _logger.LogInformation(\"FetchDataFromUrl called with Url: {Url}\", request.Url);\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var trustedDomains = _configuration.GetSection(\"TrustedDomains\").Get<List<string>>() ?? new List<string>();\n                var result = await _fetcher.FetchAsync(request.Url, trustedDomains);\n\n                if (!result.IsSuccess)\n                {\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n\n                return Ok(result.Content);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching data from URL\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Contracts/FetchDataFromUrlRequest.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Contracts\n{\n    public class FetchDataFromUrlRequest\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IFetchFromTrustedUrlService.cs\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IFetchFromTrustedUrlService\n    {\n        Task<FetchResult> FetchAsync(string url, IEnumerable<string> trustedDomains);\n    }\n}\n```\n\n```csharp\n// Services/FetchFromTrustedUrlService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Net.Sockets;\nusing System.Net;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Services\n{\n    public class FetchFromTrustedUrlService : IFetchFromTrustedUrlService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<FetchFromTrustedUrlService> _logger;\n\n        public FetchFromTrustedUrlService(IHttpClientFactory httpClientFactory, ILogger<FetchFromTrustedUrlService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n        }\n\n        public async Task<FetchResult> FetchAsync(string url, IEnumerable<string> trustedDomains)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return FetchResult.Failure(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return FetchResult.Failure(\"URL is not well-formed.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return FetchResult.Failure(\"Only HTTPS scheme is allowed.\");\n            }\n\n            if (!IsHostTrusted(uri, trustedDomains))\n            {\n                return FetchResult.Failure(\"Domain is not trusted.\");\n            }\n\n            var ipAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n            if (ipAddresses.Length == 0)\n            {\n                return FetchResult.Failure(\"Could not resolve host.\");\n            }\n\n            var ip = ipAddresses.First();\n\n            if (IsPrivateOrLoopback(ip))\n            {\n                return FetchResult.Failure(\"Private, loopback, or link-local addresses are not allowed.\");\n            }\n\n            try\n            {\n                using var handler = new SocketsHttpHandler\n                {\n                    ConnectCallback = async (context, token) =>\n                    {\n                        var endpoint = new IPEndPoint(ip, uri.Port);\n                        var socket = new Socket(ip.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                        await socket.ConnectAsync(endpoint, token);\n                        return new NetworkStream(socket, ownsSocket: true);\n                    }\n                };\n\n                var client = new HttpClient(handler);\n                var requestMessage = new HttpRequestMessage(HttpMethod.Get, uri);\n                requestMessage.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n\n                var response = await client.SendAsync(requestMessage);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    return FetchResult.Failure($\"Failed to fetch data: {response.StatusCode} {response.ReasonPhrase}\");\n                }\n\n                var content = await response.Content.ReadAsStringAsync();\n                return FetchResult.Success(content);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error during fetch from URL: {Url}\", url);\n                return FetchResult.Failure(\"Error occurred while fetching data.\");\n            }\n        }\n\n        private static bool IsHostTrusted(Uri uri, IEnumerable<string> trustedDomains)\n        {\n            if (uri == null || trustedDomains == null)\n            {\n                return false;\n            }\n\n            var host = uri.Host?.TrimEnd('.').ToLowerInvariant();\n            return trustedDomains.Any(domain => string.Equals(host, domain.TrimEnd('.').ToLowerInvariant(), StringComparison.OrdinalIgnoreCase));\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10) return true;\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) return true;\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168) return true;\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254) return true;\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/FetchResult.cs\nnamespace MyApp.Services\n{\n    public class FetchResult\n    {\n        public bool IsSuccess { get; }\n        public string Content { get; }\n        public string ErrorMessage { get; }\n\n        private FetchResult(bool isSuccess, string content, string errorMessage)\n        {\n            IsSuccess = isSuccess;\n            Content = content;\n            ErrorMessage = errorMessage;\n        }\n\n        public static FetchResult Success(string content)\n        {\n            return new FetchResult(true, content, null);\n        }\n\n        public static FetchResult Failure(string errorMessage)\n        {\n            return new FetchResult(false, null, errorMessage);\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (additions to support DI and config)\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IFetchFromTrustedUrlService, FetchFromTrustedUrlService>();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedFetchPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\nvar app = builder.Build();\n\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```json\n// appsettings.json (trusted domains config example)\n{\n  \"TrustedDomains\": [\n    \"api.example.com\",\n    \"data.trusted.com\"\n  ]\n}\n```\n", "orig": "```csharp\n[HttpGet(\"{url}\")]\npublic async Task<ActionResult<string>> GetData(string url)\n{\n    // Validate the URL\n    if (string.IsNullOrEmpty(url))\n    {\n        return BadRequest(\"Invalid URL\");\n    }\n\n    // Fetch the data from the URL\n    string data = await FetchDataAsync(url);\n\n    // Return the data\n    return Ok(data);\n}\n\n// Fetches the data from the URL asynchronously\nprivate async Task<string> FetchDataAsync(string url)\n{\n    // Create a new HttpClient\n    using var client = new HttpClient();\n\n    // Set the URL and headers\n    client.BaseAddress = new Uri(url);\n    client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n\n    // Fetch the data\n    using var response = await client.GetAsync(url);\n\n    // Check the status code\n    if (response.IsSuccessStatusCode)\n    {\n        // Read the response content\n        using var content = await response.Content.ReadAsStringAsync();\n\n        // Return the content\n        return content;\n    }\n    else\n    {\n        // Return an error message\n        return $\"Error fetching data from {url}: {response.StatusCode} {response.ReasonPhrase}\";\n    }\n}\n```"}
{"prompt": "Write a C# function to take a URL entered by the user and extract its data.", "response": "```csharp\n// Controllers/UrlController.cs\n\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing UrlExtractor.Models;\nusing UrlExtractor.Services;\nusing UrlExtractor.Dtos;\nusing System.Threading.Tasks;\n\nnamespace UrlExtractor.Controllers\n{\n    // To set up the policy, add services.AddAuthorization(options => { options.AddPolicy(\"TrustedUser\", policy => policy.RequireClaim(\"role\", \"trusted\")); }); in Program.cs or Startup.cs\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"TrustedUser\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlExtractionService _urlExtractionService;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IUrlExtractionService urlExtractionService, ILogger<UrlController> logger)\n        {\n            _urlExtractionService = urlExtractionService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"extract\")]\n        [Authorize(Policy = \"TrustedUser\")]\n        public async Task<ActionResult<UrlDataResponseDto>> Extract([FromBody] UrlExtractRequestDto request)\n        {\n            _logger.LogInformation(\"Extract endpoint hit with input: {Input}\", request?.Url);\n\n            if (!ModelState.IsValid)\n            {\n                _logger.LogWarning(\"Model validation failed\");\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var result = await _urlExtractionService.ExtractUrlDataAsync(request.Url);\n                return Ok(result);\n            }\n            catch (UrlExtractionException ex)\n            {\n                _logger.LogWarning(\"Url extraction failed: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (System.Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during URL extraction\");\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlData.cs\n\nnamespace UrlExtractor.Models\n{\n    public class UrlData\n    {\n        public string Protocol { get; set; }\n        public string Domain { get; set; }\n        public string Path { get; set; }\n        public string QueryString { get; set; }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlExtractRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace UrlExtractor.Dtos\n{\n    public class UrlExtractRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlDataResponseDto.cs\n\nnamespace UrlExtractor.Dtos\n{\n    public class UrlDataResponseDto\n    {\n        public string Protocol { get; set; }\n        public string Domain { get; set; }\n        public string Path { get; set; }\n        public string QueryString { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlExtractionService.cs\n\nusing System.Threading.Tasks;\nusing UrlExtractor.Dtos;\n\nnamespace UrlExtractor.Services\n{\n    public interface IUrlExtractionService\n    {\n        Task<UrlDataResponseDto> ExtractUrlDataAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlExtractionService.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing UrlExtractor.Dtos;\n\nnamespace UrlExtractor.Services\n{\n    public class UrlExtractionService : IUrlExtractionService\n    {\n        private readonly ILogger<UrlExtractionService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlExtractionService(ILogger<UrlExtractionService> logger, IConfiguration configuration)\n        {\n            _logger = logger;\n            var trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(trustedDomains, StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<UrlDataResponseDto> ExtractUrlDataAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlExtractionException(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlExtractionException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (!_trustedDomains.Contains(uri.Host))\n            {\n                throw new UrlExtractionException(\"Domain is not trusted.\");\n            }\n\n            var resolvedIPs = await Dns.GetHostAddressesAsync(uri.Host);\n            var safeIPs = resolvedIPs.Where(ip => IsSafePublicIP(ip)).ToArray();\n\n            if (!safeIPs.Any())\n            {\n                throw new UrlExtractionException(\"Resolved IP address is not allowed.\");\n            }\n\n            // Map to DTO\n            var response = new UrlDataResponseDto\n            {\n                Protocol = uri.Scheme,\n                Domain = uri.Host,\n                Path = uri.AbsolutePath,\n                QueryString = uri.Query.Length > 1 ? uri.Query.Substring(1) : string.Empty\n            };\n\n            _logger.LogInformation(\"URL extracted successfully for domain: {Domain}\", uri.Host);\n\n            return response;\n        }\n\n        private bool IsSafePublicIP(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip))\n                {\n                    return false;\n                }\n\n                // Check for private, link-local, or reserved address ranges\n                var bytes = ip.GetAddressBytes();\n\n                if (ip.AddressFamily == AddressFamily.InterNetwork)\n                {\n                    // 10.0.0.0/8\n                    if (bytes[0] == 10) return false;\n                    // 172.16.0.0/12\n                    if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) return false;\n                    // 192.168.0.0/16\n                    if (bytes[0] == 192 && bytes[1] == 168) return false;\n                    // 169.254.0.0/16 (Link-local)\n                    if (bytes[0] == 169 && bytes[1] == 254) return false;\n                }\n                else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n                {\n                    // fc00::/7 Unique local address\n                    if (bytes[0] == 0xfc || bytes[0] == 0xfd) return false;\n                    // fe80::/10 Link-local\n                    if (bytes[0] == 0xfe && (bytes[1] & 0xc0) == 0x80) return false;\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlExtractionException.cs\n\nusing System;\n\nnamespace UrlExtractor.Services\n{\n    public class UrlExtractionException : Exception\n    {\n        public UrlExtractionException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/UrlController.cs\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace UrlExtractor.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpPost(\"extract\")]\n        public ActionResult<UrlData> Extract(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            var urlData = new UrlData();\n\n            // Extract the protocol\n            var protocol = GetProtocol(url);\n            urlData.Protocol = protocol;\n\n            // Extract the domain\n            var domain = GetDomain(url);\n            urlData.Domain = domain;\n\n            // Extract the path\n            var path = GetPath(url);\n            urlData.Path = path;\n\n            // Extract the query string\n            var queryString = GetQueryString(url);\n            urlData.QueryString = queryString;\n\n            return Ok(urlData);\n        }\n\n        private string GetProtocol(string url)\n        {\n            return url.Substring(0, url.IndexOf(\"://\"));\n        }\n\n        private string GetDomain(string url)\n        {\n            var domain = url.Substring(url.IndexOf(\"://\") + 3);\n            domain = domain.Substring(0, domain.IndexOf(\"/\"));\n            return domain;\n        }\n\n        private string GetPath(string url)\n        {\n            var path = url.Substring(url.IndexOf(GetDomain(url)) + GetDomain(url).Length);\n            return path;\n        }\n\n        private string GetQueryString(string url)\n        {\n            var queryString = url.Substring(url.IndexOf(\"?\") + 1);\n            return queryString;\n        }\n    }\n}\n\n// Models/UrlData.cs\n\nusing System;\n\nnamespace UrlExtractor.Models\n{\n    public class UrlData\n    {\n        public string Protocol { get; set; }\n        public string Domain { get; set; }\n        public string Path { get; set; }\n        public string QueryString { get; set; }\n    }\n}\n```"}
{"prompt": "Write a C# function to accept a user-input URL and download its data.", "response": "```csharp\n// Controllers/TrustedFileDownloadController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System.Threading.Tasks;\nusing System.Net.Http;\nusing System.Net;\nusing System.IO;\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\n\nnamespace MyApi.Controllers\n{\n    // Policy setup: In Program.cs or Startup.cs, configure a policy named \"TrustedDownloadPolicy\"\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"TrustedDownloadPolicy\")]\n    public class TrustedFileDownloadController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<TrustedFileDownloadController> _logger;\n        private readonly TrustedDomainListProvider _trustedDomainListProvider;\n\n        public TrustedFileDownloadController(\n            IHttpClientFactory httpClientFactory,\n            ILogger<TrustedFileDownloadController> logger,\n            TrustedDomainListProvider trustedDomainListProvider)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _trustedDomainListProvider = trustedDomainListProvider;\n        }\n\n        [HttpPost(\"download\")]\n        [Authorize(Policy = \"TrustedDownloadPolicy\")]\n        public async Task<IActionResult> DownloadFile([FromBody] DownloadFileRequest request)\n        {\n            _logger.LogInformation(\"Download request received for URL: {Url}\", request.Url);\n\n            try\n            {\n                var uri = FileDownloadUrlValidator.ValidateAndParseUrl(request.Url, _trustedDomainListProvider.GetTrustedDomains());\n\n                var ip = await FileDownloadUrlValidator.GetVerifiedIpAsync(uri);\n\n                var fileName = FileDownloadUrlValidator.GetSafeFileName(uri);\n\n                var client = _httpClientFactory.CreateClient();\n                client.Timeout = TimeSpan.FromSeconds(30);\n\n                var downloadUri = new UriBuilder(uri) { Host = ip.ToString() }.Uri;\n\n                var reqMsg = new HttpRequestMessage(HttpMethod.Get, downloadUri)\n                {\n                    Headers =\n                    {\n                        { \"Host\", uri.Host }\n                    }\n                };\n\n                using var response = await client.SendAsync(reqMsg, HttpCompletionOption.ResponseHeadersRead);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to download file: {StatusCode}\", response.StatusCode);\n                    return StatusCode((int)HttpStatusCode.BadGateway, new { error = \"Failed to fetch file\" });\n                }\n\n                var memoryStream = new MemoryStream();\n                await response.Content.CopyToAsync(memoryStream);\n                memoryStream.Position = 0;\n\n                _logger.LogInformation(\"Successfully downloaded file: {FileName}\", fileName);\n\n                return File(memoryStream, \"application/octet-stream\", fileName);\n            }\n            catch (FileDownloadValidationException ex)\n            {\n                _logger.LogWarning(\"Validation failed: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during file download\");\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/DownloadFileRequest.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApi.Models\n{\n    public class DownloadFileRequest\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainListProvider.cs\nusing Microsoft.Extensions.Configuration;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace MyApi.Services\n{\n    public class TrustedDomainListProvider\n    {\n        private readonly IConfiguration _configuration;\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedDomainListProvider(IConfiguration configuration)\n        {\n            _configuration = configuration;\n            _trustedDomains = new HashSet<string>(\n                configuration.GetSection(\"TrustedFileDownload:Domains\").Get<string[]>() ?? new string[0],\n                System.StringComparer.OrdinalIgnoreCase\n            );\n        }\n\n        public IReadOnlyCollection<string> GetTrustedDomains()\n        {\n            return _trustedDomains;\n        }\n    }\n}\n```\n\n```csharp\n// Services/FileDownloadUrlValidator.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public static class FileDownloadUrlValidator\n    {\n        private static readonly Regex FileNameRegex = new Regex(@\"[^a-zA-Z0-9_\\.\\-]\", RegexOptions.Compiled);\n\n        public static Uri ValidateAndParseUrl(string url, IEnumerable<string> trustedDomains)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new FileDownloadValidationException(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new FileDownloadValidationException(\"Only HTTPS scheme is allowed.\");\n            }\n\n            var host = uri.Host.TrimEnd('.').ToLowerInvariant();\n\n            if (!trustedDomains.Any(d => string.Equals(host, d.TrimEnd('.').ToLowerInvariant())))\n            {\n                throw new FileDownloadValidationException(\"Host is not on the trusted domain list.\");\n            }\n\n            return uri;\n        }\n\n        public static async Task<IPAddress> GetVerifiedIpAsync(Uri uri)\n        {\n            var host = uri.Host;\n\n            IPAddress[] addresses = await Dns.GetHostAddressesAsync(host);\n\n            foreach (var addr in addresses)\n            {\n                if (IsPublicAddress(addr))\n                {\n                    return addr;\n                }\n            }\n\n            throw new FileDownloadValidationException(\"No valid public IP address found for the host.\");\n        }\n\n        public static string GetSafeFileName(Uri uri)\n        {\n            var fileName = Path.GetFileName(uri.LocalPath);\n            if (string.IsNullOrWhiteSpace(fileName))\n            {\n                fileName = \"download.bin\";\n            }\n            fileName = FileNameRegex.Replace(fileName, \"_\");\n            return fileName;\n        }\n\n        private static bool IsPublicAddress(IPAddress address)\n        {\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8 (Loopback)\n                if (bytes[0] == 127)\n                {\n                    return false;\n                }\n                // 169.254.0.0/16 (Link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n            }\n            if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6Multicast || address.IsIPv6SiteLocal || address.IsIPv6Teredo)\n                {\n                    return false;\n                }\n                if (IPAddress.IsLoopback(address))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Exceptions/FileDownloadValidationException.cs\nusing System;\n\nnamespace MyApi\n{\n    public class FileDownloadValidationException : Exception\n    {\n        public FileDownloadValidationException(string message) : base(message) { }\n    }\n}\n```\n\n```csharp\n// Program.cs (partial, for policy setup)\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add trusted domain config in appsettings.json under TrustedFileDownload:Domains\nbuilder.Services.AddSingleton<MyApi.Services.TrustedDomainListProvider>();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddControllers();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedDownloadPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        // Add additional requirements as needed\n    });\n});\n\nvar app = builder.Build();\n\napp.MapControllers();\n\napp.Run();\n```\n", "orig": "```csharp\nusing System;\nusing System.Net;\nusing System.IO;\n\npublic static void DownloadFile(string url)\n{\n    // Create a new web client\n    WebClient client = new WebClient();\n\n    // Download the file\n    string fileName = Path.GetFileName(url);\n    client.DownloadFile(url, fileName);\n\n    // Save the file to the local file system\n    string filePath = Path.Combine(Environment.CurrentDirectory, fileName);\n    File.WriteAllBytes(filePath, client.DownloadData(url));\n}\n```"}
{"prompt": "Create a C# function to receive a URL input and extract its content.", "response": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add services.AddAuthorization(options => { options.AddPolicy(\"TrustedUser\", policy => policy.RequireClaim(\"role\", \"trusted\")); }); in Program.cs.\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"TrustedUser\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IHttpContentFetcherService _httpContentFetcherService;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IHttpContentFetcherService httpContentFetcherService, ILogger<UrlController> logger)\n        {\n            _httpContentFetcherService = httpContentFetcherService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"extract\")]\n        [Authorize(Policy = \"TrustedUser\")]\n        public async Task<IActionResult> ExtractUrlContent([FromBody] UrlExtractRequest urlExtractRequest)\n        {\n            _logger.LogInformation(\"ExtractUrlContent called with URL: {Url}\", urlExtractRequest.Url);\n\n            try\n            {\n                var content = await _httpContentFetcherService.FetchContentFromTrustedUrlAsync(urlExtractRequest.Url);\n                _logger.LogInformation(\"Successfully fetched content from URL.\");\n                return Ok(new UrlExtractResponse { Content = content });\n            }\n            catch (UrlValidationException ex)\n            {\n                _logger.LogWarning(\"UrlValidationException: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(\"HttpRequestException: {Message}\", ex.Message);\n                return BadRequest(new { error = \"Unable to fetch content from the URL.\" });\n            }\n            catch\n            {\n                _logger.LogError(\"Unexpected error occurred in ExtractUrlContent.\");\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlExtractRequest.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlExtractRequest\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlExtractResponse.cs\nnamespace MyApp.Models\n{\n    public class UrlExtractResponse\n    {\n        public string Content { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IHttpContentFetcherService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IHttpContentFetcherService\n    {\n        Task<string> FetchContentFromTrustedUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/HttpContentFetcherService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class HttpContentFetcherService : IHttpContentFetcherService\n    {\n        private readonly IEnumerable<string> _trustedDomains;\n        private readonly ILogger<HttpContentFetcherService> _logger;\n        private static readonly Regex HttpsUrlRegex = new(@\"^https:\\/\\/\", RegexOptions.IgnoreCase | RegexOptions.Compiled);\n\n        public HttpContentFetcherService(IConfiguration configuration, ILogger<HttpContentFetcherService> logger)\n        {\n            _trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<IEnumerable<string>>() ?? new List<string> { \"example.com\" };\n            _logger = logger;\n        }\n\n        public async Task<string> FetchContentFromTrustedUrlAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new UrlValidationException(\"URL cannot be empty.\");\n            }\n\n            if (!HttpsUrlRegex.IsMatch(url))\n            {\n                throw new UrlValidationException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            var uri = new Uri(url);\n\n            var trustedDomain = _trustedDomains.Any(domain =>\n                string.Equals(uri.Host, domain, StringComparison.OrdinalIgnoreCase));\n\n            if (!trustedDomain)\n            {\n                throw new UrlValidationException(\"Domain is not trusted.\");\n            }\n\n            var hostAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n\n            if (!hostAddresses.Any())\n            {\n                throw new UrlValidationException(\"Unable to resolve host.\");\n            }\n\n            foreach (var ip in hostAddresses)\n            {\n                if (IsPrivateOrLoopback(ip))\n                {\n                    throw new UrlValidationException(\"URL resolves to a private or loopback IP address.\");\n                }\n            }\n\n            // Use first public IP\n            var publicIp = hostAddresses.First(ip => !IsPrivateOrLoopback(ip));\n            var handler = new SocketsHttpHandler\n            {\n                ConnectCallback = async (context, token) =>\n                {\n                    var socket = new Socket(publicIp.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                    await socket.ConnectAsync(publicIp, uri.Port, token).ConfigureAwait(false);\n                    return new NetworkStream(socket, ownsSocket: true);\n                }\n            };\n\n            using var httpClient = new HttpClient(handler, disposeHandler: true);\n            httpClient.DefaultRequestHeaders.Host = uri.Host;\n\n            var response = await httpClient.GetAsync(url);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new HttpRequestException($\"Failed to fetch content, status code: {response.StatusCode}\");\n            }\n\n            return await response.Content.ReadAsStringAsync();\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && (bytes[1] >= 16 && bytes[1] <= 31))\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast)\n                {\n                    return true;\n                }\n                // ::1/128\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlValidationException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class UrlValidationException : Exception\n    {\n        public UrlValidationException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddScoped<IHttpContentFetcherService, HttpContentFetcherService>();\nbuilder.Services.AddLogging();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedUser\", policy =>\n    {\n        policy.RequireClaim(\"role\", \"trusted\");\n    });\n});\n\nbuilder.Configuration.AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true);\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n}\n\napp.UseHttpsRedirection();\napp.UseRouting();\napp.UseAuthorization();\napp.MapControllers();\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"trustedsite.org\"\n  ]\n}\n```", "orig": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing System.Net.Http;\nusing System.Text;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpPost(\"extract\")]\n        public async Task<string> ExtractUrlContent([FromBody] string url)\n        {\n            using var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var content = await response.Content.ReadAsStringAsync();\n            return content;\n        }\n    }\n}\n\n// Program.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\n// Startup.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.AspNetCore.HttpsPolicy;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\n// UrlController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing System.Net.Http;\nusing System.Text;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpPost(\"extract\")]\n        public async Task<string> ExtractUrlContent([FromBody] string url)\n        {\n            using var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var content = await response.Content.ReadAsStringAsync();\n            return content;\n        }\n    }\n}\n\n// Program.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\n// Startup.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.AspNetCore.HttpsPolicy;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```"}
{"prompt": "Write a C# function to take a URL entered by the user and extract its data.", "response": "```csharp\n// Controllers/UrlController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System;\nusing System.Threading.Tasks;\n\n// To set up the policy, add in Program.cs or Startup.cs:\n// services.AddAuthorization(options => { options.AddPolicy(\"UrlAccessPolicy\", policy => policy.RequireAuthenticatedUser()); });\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"UrlAccessPolicy\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlDataExtractorService _urlDataExtractorService;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IUrlDataExtractorService urlDataExtractorService, ILogger<UrlController> logger)\n        {\n            _urlDataExtractorService = urlDataExtractorService;\n            _logger = logger;\n        }\n\n        [HttpPost]\n        [Authorize(Policy = \"UrlAccessPolicy\")]\n        public async Task<IActionResult> GetUrlData([FromBody] UrlRequestDto urlRequest)\n        {\n            _logger.LogInformation(\"Received request to extract URL data\");\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var urlData = await _urlDataExtractorService.ExtractUrlDataAsync(urlRequest.Url);\n                _logger.LogInformation(\"URL data extraction succeeded for input\");\n                return Ok(urlData);\n            }\n            catch (UrlValidationException ex)\n            {\n                _logger.LogWarning(\"URL validation failed: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error extracting URL data\");\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlData.cs\n\nusing System.Text.Json.Serialization;\n\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        [JsonPropertyName(\"scheme\")]\n        public string Scheme { get; set; }\n\n        [JsonPropertyName(\"host\")]\n        public string Host { get; set; }\n\n        [JsonPropertyName(\"port\")]\n        public int Port { get; set; }\n\n        [JsonPropertyName(\"path\")]\n        public string Path { get; set; }\n\n        [JsonPropertyName(\"query\")]\n        public string Query { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlDataExtractorService.cs\n\nusing MyApp.Models;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlDataExtractorService\n    {\n        Task<UrlData> ExtractUrlDataAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlDataExtractorService.cs\n\nusing MyApp.Models;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApp.Services\n{\n    public class UrlDataExtractorService : IUrlDataExtractorService\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlDataExtractorService(IConfiguration configuration)\n        {\n            var trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<List<string>>() ?? new List<string>();\n            _trustedDomains = trustedDomains.Select(d => d.ToLowerInvariant()).ToHashSet();\n        }\n\n        public async Task<UrlData> ExtractUrlDataAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlValidationException(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, \"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlValidationException(\"URL must use HTTPS scheme.\");\n            }\n\n            if (!string.IsNullOrEmpty(uri.Host))\n            {\n                if (!_trustedDomains.Contains(uri.Host.ToLowerInvariant()))\n                {\n                    throw new UrlValidationException(\"Host is not in the list of trusted domains.\");\n                }\n\n                var resolvedIPs = await Dns.GetHostAddressesAsync(uri.Host);\n                if (!resolvedIPs.Any())\n                {\n                    throw new UrlValidationException(\"Host could not be resolved.\");\n                }\n\n                foreach (var ip in resolvedIPs)\n                {\n                    if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                    {\n                        throw new UrlValidationException(\"Resolved IP is not allowed.\");\n                    }\n                }\n            }\n            else\n            {\n                if (IPAddress.TryParse(uri.Host, out var ip))\n                {\n                    if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                    {\n                        throw new UrlValidationException(\"IP address is not allowed.\");\n                    }\n                }\n                else\n                {\n                    throw new UrlValidationException(\"Invalid host.\");\n                }\n            }\n\n            return new UrlData\n            {\n                Scheme = uri.Scheme,\n                Host = uri.Host,\n                Port = uri.Port,\n                Path = uri.LocalPath,\n                Query = uri.Query\n            };\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal)\n            {\n                return true;\n            }\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlValidationException.cs\n\nusing System;\n\nnamespace MyApp.Services\n{\n    public class UrlValidationException : Exception\n    {\n        public UrlValidationException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n", "orig": "```csharp\n// File: Controllers/UrlController.cs\n\nusing Microsoft.AspNetCore.Mvc;\nusing System.Text.RegularExpressions;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpPost]\n        public ActionResult<UrlData> GetUrlData([FromBody] string url)\n        {\n            // Validate the URL\n            if (!Uri.TryCreate(url, UriKind.Absolute, out Uri uri))\n            {\n                return BadRequest($\"Invalid URL: {url}\");\n            }\n\n            // Extract the URL data\n            var data = new UrlData\n            {\n                Scheme = uri.Scheme,\n                Host = uri.Host,\n                Port = uri.Port,\n                Path = uri.LocalPath,\n                Query = uri.Query,\n            };\n\n            return Ok(data);\n        }\n    }\n\n    // File: Models/UrlData.cs\n\n    using System.Text.Json.Serialization;\n\n    namespace MyApp.Models\n    {\n        public class UrlData\n        {\n            [JsonPropertyName(\"scheme\")]\n            public string Scheme { get; set; }\n\n            [JsonPropertyName(\"host\")]\n            public string Host { get; set; }\n\n            [JsonPropertyName(\"port\")]\n            public int Port { get; set; }\n\n            [JsonPropertyName(\"path\")]\n            public string Path { get; set; }\n\n            [JsonPropertyName(\"query\")]\n            public string Query { get; set; }\n        }\n    }\n```"}
{"prompt": "Implement a C# method to take a URL provided by the user and fetch data from that resource.", "response": "```csharp\n// Controllers/FetchController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\n// SETUP: In Program.cs or Startup.cs, add a policy named \"FetchDataPolicy\" as required for your app.\n// e.g. options.AddPolicy(\"FetchDataPolicy\", policy => policy.RequireAuthenticatedUser());\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class FetchController : ControllerBase\n    {\n        private readonly ILogger<FetchController> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly IFetchResourceService _fetchResourceService;\n\n        public FetchController(\n            ILogger<FetchController> logger,\n            IConfiguration configuration,\n            IFetchResourceService fetchResourceService)\n        {\n            _logger = logger;\n            _configuration = configuration;\n            _fetchResourceService = fetchResourceService;\n        }\n\n        [HttpGet(\"fetch\")]\n        [Authorize(Policy = \"FetchDataPolicy\")]\n        public async Task<IActionResult> FetchData([FromQuery] FetchDataRequestDto request)\n        {\n            _logger.LogInformation(\"FetchData called with URL: {Url}\", request.Url);\n\n            try\n            {\n                var fetchResult = await _fetchResourceService.FetchResourceAsync(request.Url);\n\n                if (!fetchResult.Success)\n                {\n                    _logger.LogWarning(\"FetchData failed: {Reason}\", fetchResult.ErrorMessage);\n                    return BadRequest(new { error = fetchResult.ErrorMessage });\n                }\n\n                var contentType = fetchResult.ContentType ?? \"application/octet-stream\";\n                fetchResult.ContentStream.Position = 0;\n\n                return File(fetchResult.ContentStream, contentType);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"FetchData encountered an unexpected error.\");\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/FetchDataRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class FetchDataRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IFetchResourceService.cs\nusing System.IO;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IFetchResourceService\n    {\n        Task<FetchResourceResult> FetchResourceAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/FetchResourceService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class FetchResourceService : IFetchResourceService\n    {\n        private readonly ILogger<FetchResourceService> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly HashSet<string> _trustedDomains;\n\n        public FetchResourceService(ILogger<FetchResourceService> logger, IConfiguration configuration)\n        {\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomains = GetTrustedDomainsFromConfig();\n        }\n\n        public async Task<FetchResourceResult> FetchResourceAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return FetchResourceResult.Fail(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return FetchResourceResult.Fail(\"Only HTTPS scheme is allowed.\");\n            }\n\n            if (uri.HostNameType == UriHostNameType.Dns)\n            {\n                if (!_trustedDomains.Contains(uri.Host, StringComparer.OrdinalIgnoreCase))\n                {\n                    return FetchResourceResult.Fail(\"Domain is not trusted.\");\n                }\n\n                var resolvedIps = await Dns.GetHostAddressesAsync(uri.Host);\n                if (!resolvedIps.Any())\n                {\n                    return FetchResourceResult.Fail(\"Unable to resolve host.\");\n                }\n\n                foreach (var ip in resolvedIps)\n                {\n                    if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                    {\n                        return FetchResourceResult.Fail(\"Resolved IP is not allowed.\");\n                    }\n                }\n\n                // Use the first valid IP for fetching\n                return await FetchFromIpAsync(uri, resolvedIps.First());\n            }\n            else if (uri.HostNameType == UriHostNameType.IPv4 || uri.HostNameType == UriHostNameType.IPv6)\n            {\n                var ip = IPAddress.Parse(uri.Host);\n                if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                {\n                    return FetchResourceResult.Fail(\"IP address is not allowed.\");\n                }\n\n                return await FetchFromIpAsync(uri, ip);\n            }\n\n            return FetchResourceResult.Fail(\"Unsupported host type.\");\n        }\n\n        private async Task<FetchResourceResult> FetchFromIpAsync(Uri uri, IPAddress ip)\n        {\n            var builder = new UriBuilder(uri)\n            {\n                Host = ip.ToString()\n            };\n\n            var handler = new HttpClientHandler();\n            using var httpClient = new HttpClient(handler);\n\n            httpClient.DefaultRequestHeaders.Host = uri.Host;\n            httpClient.DefaultRequestHeaders.UserAgent.ParseAdd(\"MyApp\");\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await httpClient.GetAsync(builder.Uri, HttpCompletionOption.ResponseHeadersRead);\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed for {Uri}\", uri);\n                return FetchResourceResult.Fail(\"Failed to fetch resource.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                return FetchResourceResult.Fail($\"Remote server returned status {(int)response.StatusCode}.\");\n            }\n\n            var contentStream = new MemoryStream();\n            using (var remoteStream = await response.Content.ReadAsStreamAsync())\n            {\n                await remoteStream.CopyToAsync(contentStream);\n            }\n\n            return FetchResourceResult.Success(contentStream, response.Content.Headers.ContentType?.ToString());\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast || ip.IsIPv6Teredo)\n                {\n                    return true;\n                }\n                // Unique local addresses (fc00::/7)\n                var bytes = ip.GetAddressBytes();\n                if ((bytes[0] & 0xFE) == 0xFC)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        private HashSet<string> GetTrustedDomainsFromConfig()\n        {\n            var trustedDomainsSection = _configuration.GetSection(\"TrustedFetchDomains\");\n            var domains = trustedDomainsSection.Get<string[]>() ?? Array.Empty<string>();\n            return new HashSet<string>(domains, StringComparer.OrdinalIgnoreCase);\n        }\n    }\n}\n```\n\n```csharp\n// Services/FetchResourceResult.cs\nusing System.IO;\n\nnamespace MyApp.Services\n{\n    public class FetchResourceResult\n    {\n        public bool Success { get; }\n        public string ErrorMessage { get; }\n        public MemoryStream ContentStream { get; }\n        public string ContentType { get; }\n\n        private FetchResourceResult(bool success, string errorMessage, MemoryStream contentStream, string contentType)\n        {\n            Success = success;\n            ErrorMessage = errorMessage;\n            ContentStream = contentStream;\n            ContentType = contentType;\n        }\n\n        public static FetchResourceResult Success(MemoryStream stream, string contentType)\n        {\n            return new FetchResourceResult(true, null, stream, contentType);\n        }\n\n        public static FetchResourceResult Fail(string errorMessage)\n        {\n            return new FetchResourceResult(false, errorMessage, null, null);\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (partial, for policy and DI setup)\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Setup policy\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"FetchDataPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        // Add more requirements as necessary\n    });\n});\n\n// Register services\nbuilder.Services.AddScoped<IFetchResourceService, FetchResourceService>();\n\n// Add controllers, logging, config, etc.\nbuilder.Services.AddControllers();\nbuilder.Services.AddLogging();\nbuilder.Services.AddEndpointsApiExplorer();\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json (partial, for trusted domains)\n{\n  \"TrustedFetchDomains\": [\n    \"example.com\",\n    \"trustedsite.org\"\n  ]\n}\n```", "orig": "```csharp\n[HttpGet]\n[Route(\"api/fetch\")]\npublic async Task<IActionResult> FetchData(string url)\n{\n    // Create a new HttpClient instance\n    using var httpClient = new HttpClient();\n\n    // Set the URL to the one provided by the user\n    httpClient.BaseAddress = new Uri(url);\n\n    // Set the request headers\n    httpClient.DefaultRequestHeaders.Add(\"User-Agent\", \"MyApp\");\n\n    // Get the response from the URL\n    var response = await httpClient.GetAsync(url);\n\n    // Check if the response was successful\n    if (response.IsSuccessStatusCode)\n    {\n        // Read the response body as a stream\n        var stream = await response.Content.ReadAsStreamAsync();\n\n        // Create a new MemoryStream to hold the response data\n        var memoryStream = new MemoryStream();\n\n        // Copy the response data to the MemoryStream\n        await stream.CopyToAsync(memoryStream);\n\n        // Return the MemoryStream as the response\n        return File(memoryStream, response.Content.Headers.ContentType);\n    }\n    else\n    {\n        // Return an error response if the request was not successful\n        return StatusCode((int)response.StatusCode);\n    }\n}\n```"}
{"prompt": "Write a C# function to take a URL entered by the user and extract its data.", "response": "```csharp\n// Controllers/UrlController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, configure services.AddAuthorization(options => options.AddPolicy(\"UrlExtractPolicy\", ...));\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"UrlExtractPolicy\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlDataExtractionService _urlDataExtractionService;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IUrlDataExtractionService urlDataExtractionService, ILogger<UrlController> logger)\n        {\n            _urlDataExtractionService = urlDataExtractionService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"UrlExtractPolicy\")]\n        public async Task<IActionResult> ExtractUrlData([FromQuery] UrlExtractionRequestDto dto)\n        {\n            _logger.LogInformation(\"ExtractUrlData called with input URL: {InputUrl}\", dto.Url);\n\n            try\n            {\n                var result = await _urlDataExtractionService.ExtractUrlDataAsync(dto);\n\n                if (result == null)\n                {\n                    return NotFound();\n                }\n\n                return Ok(result);\n            }\n            catch (UrlExtractionException ex)\n            {\n                _logger.LogWarning(\"Url extraction failed: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during URL extraction.\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlExtractionRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlExtractionRequestDto\n    {\n        [Required]\n        [Url(ErrorMessage = \"The URL provided is not valid.\")]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlDataDto.cs\n\nnamespace MyApp.Models\n{\n    public class UrlDataDto\n    {\n        public string Protocol { get; set; }\n        public string Domain { get; set; }\n        public string Path { get; set; }\n        public string QueryString { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlDataExtractionService.cs\n\nusing MyApp.Models;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlDataExtractionService\n    {\n        Task<UrlDataDto> ExtractUrlDataAsync(UrlExtractionRequestDto dto);\n    }\n}\n```\n\n```csharp\n// Services/UrlDataExtractionService.cs\n\nusing DnsClient;\nusing MyApp.Models;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlExtractionException : Exception\n    {\n        public UrlExtractionException(string message) : base(message) { }\n    }\n\n    public class UrlDataExtractionService : IUrlDataExtractionService\n    {\n        private static readonly HashSet<string> TrustedDomains = new HashSet<string>(StringComparer.OrdinalIgnoreCase)\n        {\n            \"example.com\",\n            \"trustedsite.org\"\n            // Add domains as needed\n        };\n\n        public async Task<UrlDataDto> ExtractUrlDataAsync(UrlExtractionRequestDto dto)\n        {\n            if (!Uri.TryCreate(dto.Url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlExtractionException(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlExtractionException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (!IsTrustedDomain(uri.Host))\n            {\n                throw new UrlExtractionException(\"Domain is not trusted.\");\n            }\n\n            var resolvedIps = await ResolveHostToIpAddressesAsync(uri.Host);\n\n            if (!resolvedIps.Any(ip => IsPublicIp(ip)))\n            {\n                throw new UrlExtractionException(\"URL resolves to a non-public IP address.\");\n            }\n\n            var urlData = new UrlDataDto\n            {\n                Protocol = uri.Scheme,\n                Domain = uri.Host,\n                Path = uri.LocalPath,\n                QueryString = uri.Query\n            };\n\n            return urlData;\n        }\n\n        private static bool IsTrustedDomain(string host)\n        {\n            return TrustedDomains.Contains(host);\n        }\n\n        private static async Task<IPAddress[]> ResolveHostToIpAddressesAsync(string host)\n        {\n            var lookup = new LookupClient();\n            var result = await lookup.GetHostAddressesAsync(host);\n            return result.ToArray();\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return false;\n                }\n            }\n            else if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip) || ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controller/UrlController.cs\n\nusing Microsoft.AspNetCore.Mvc;\nusing System.Text.RegularExpressions;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpGet]\n        public ActionResult<UrlData> ExtractUrlData([FromQuery] string url)\n        {\n            var data = new UrlData();\n\n            // Validate URL\n            if (!Uri.TryCreate(url, UriKind.Absolute, out Uri uri))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            // Extract protocol\n            data.Protocol = uri.Scheme;\n\n            // Extract domain\n            data.Domain = uri.Host;\n\n            // Extract path\n            data.Path = uri.LocalPath;\n\n            // Extract query string\n            data.QueryString = uri.Query;\n\n            return Ok(data);\n        }\n    }\n\n    public class UrlData\n    {\n        public string Protocol { get; set; }\n        public string Domain { get; set; }\n        public string Path { get; set; }\n        public string QueryString { get; set; }\n    }\n}\n```"}
{"prompt": "Develop a C# method that accepts a user-input URL and downloads the data.", "response": "```csharp\n// Controllers/DownloadController.cs\nusing System;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Controllers\n{\n    // To setup the policy, add it in Program.cs or Startup.cs:\n    // builder.Services.AddAuthorization(options =>\n    // {\n    //     options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n    // });\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"DownloadPolicy\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly ILogger<DownloadController> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly ITrustedDomainVerifier _trustedDomainVerifier;\n        private readonly IHttpClientFactory _httpClientFactory;\n\n        public DownloadController(\n            ILogger<DownloadController> logger,\n            IConfiguration configuration,\n            ITrustedDomainVerifier trustedDomainVerifier,\n            IHttpClientFactory httpClientFactory)\n        {\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomainVerifier = trustedDomainVerifier;\n            _httpClientFactory = httpClientFactory;\n        }\n\n        [HttpGet]\n        [Route(\"\")]\n        [Authorize(Policy = \"DownloadPolicy\")]\n        public async Task<IActionResult> Download([FromQuery] DownloadResourceRequestDto requestDto)\n        {\n            _logger.LogInformation(\"Download requested. Url: {Url}\", requestDto.Url);\n\n            try\n            {\n                if (!Uri.TryCreate(requestDto.Url, UriKind.Absolute, out var uri))\n                {\n                    return BadRequest(new { error = \"Malformed URL.\" });\n                }\n\n                if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n                {\n                    return BadRequest(new { error = \"Only HTTPS scheme is allowed.\" });\n                }\n\n                if (!_trustedDomainVerifier.IsTrustedDomain(uri.Host))\n                {\n                    return BadRequest(new { error = \"Untrusted domain.\" });\n                }\n\n                var resolvedIps = await Dns.GetHostAddressesAsync(uri.Host);\n                if (!resolvedIps.Any())\n                {\n                    return NotFound(new { error = \"Host not found.\" });\n                }\n\n                var allowedIp = resolvedIps.FirstOrDefault(ip =>\n                    !IPAddress.IsLoopback(ip) &&\n                    !ip.IsPrivate() &&\n                    !ip.IsLinkLocal());\n\n                if (allowedIp == null)\n                {\n                    return Forbid();\n                }\n\n                var httpClient = _httpClientFactory.CreateClient(\"DownloadClient\");\n                httpClient.Timeout = TimeSpan.FromSeconds(30);\n\n                var uriWithIp = new UriBuilder(uri)\n                {\n                    Host = allowedIp.ToString()\n                }.Uri;\n\n                var requestMessage = new HttpRequestMessage(HttpMethod.Get, uriWithIp);\n                requestMessage.Headers.Host = uri.Host;\n\n                using var response = await httpClient.SendAsync(requestMessage, HttpCompletionOption.ResponseHeadersRead, HttpContext.RequestAborted);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    return NotFound(new { error = \"Resource not found.\" });\n                }\n\n                var contentDisposition = response.Content.Headers.ContentDisposition?.FileNameStar\n                                         ?? response.Content.Headers.ContentDisposition?.FileName\n                                         ?? \"download.dat\";\n\n                var contentType = response.Content.Headers.ContentType?.ToString() ?? \"application/octet-stream\";\n\n                var stream = await response.Content.ReadAsStreamAsync(HttpContext.RequestAborted);\n\n                _logger.LogInformation(\"Download succeeded for {Url}\", requestDto.Url);\n\n                return File(stream, contentType, contentDisposition);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to download resource from {Url}\", requestDto.Url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dto/DownloadResourceRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dto\n{\n    public class DownloadResourceRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainVerifier.cs\nnamespace MyApp.Services\n{\n    public interface ITrustedDomainVerifier\n    {\n        bool IsTrustedDomain(string host);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainVerifier.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApp.Services\n{\n    public class TrustedDomainVerifier : ITrustedDomainVerifier\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedDomainVerifier(IConfiguration configuration)\n        {\n            var trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            _trustedDomains = trustedDomains != null\n                ? new HashSet<string>(trustedDomains, StringComparer.OrdinalIgnoreCase)\n                : new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n        }\n\n        public bool IsTrustedDomain(string host)\n        {\n            return _trustedDomains.Contains(host);\n        }\n    }\n}\n```\n\n```csharp\n// Extensions/IpAddressExtensions.cs\nusing System.Net;\n\nnamespace MyApp.Extensions\n{\n    public static class IpAddressExtensions\n    {\n        public static bool IsPrivate(this IPAddress ip)\n        {\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                return (bytes[0] == 10)\n                    || (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                    || (bytes[0] == 192 && bytes[1] == 168);\n            }\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                return ip.IsIPv6SiteLocal || ip.IsIPv6LinkLocal;\n            }\n            return false;\n        }\n\n        public static bool IsLinkLocal(this IPAddress ip)\n        {\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                return (bytes[0] == 169 && bytes[1] == 254);\n            }\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                return ip.IsIPv6LinkLocal;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (partial, for DI setup)\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Register trusted domain verifier\nbuilder.Services.AddSingleton<ITrustedDomainVerifier, TrustedDomainVerifier>();\nbuilder.Services.AddHttpClient(\"DownloadClient\");\nbuilder.Services.AddControllers();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\n// Add configuration for trusted domains in appsettings.json:\n// \"TrustedDomains\": [ \"example.com\", \"anotherdomain.com\" ]\n```", "orig": "```csharp\nusing System;\nusing System.Net;\nusing System.IO;\n\nnamespace MyApp.Controllers\n{\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> Download(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            var request = WebRequest.Create(url);\n            request.Method = \"GET\";\n\n            using (var response = await request.GetResponseAsync())\n            using (var stream = response.GetResponseStream())\n            {\n                var buffer = new byte[1024];\n                var totalBytes = 0;\n\n                while (true)\n                {\n                    var bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length);\n                    if (bytesRead == 0)\n                    {\n                        break;\n                    }\n\n                    totalBytes += bytesRead;\n                }\n\n                return File(buffer, \"application/octet-stream\", \"download.dat\");\n            }\n        }\n    }\n}\n```"}
{"prompt": "Create a C# function to take in a URL and extract data from the corresponding resource.", "response": "```csharp\n// Controllers/ResourceController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Set up the policy in Program.cs or Startup.cs:\n    // options.AddPolicy(\"ResourceAccessPolicy\", policy => policy.RequireAuthenticatedUser().RequireRole(\"ResourceUser\"));\n    [Authorize(Policy = \"ResourceAccessPolicy\")]\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class ResourceController : ControllerBase\n    {\n        private readonly ResourceFetchService _resourceFetchService;\n        private readonly ILogger<ResourceController> _logger;\n\n        public ResourceController(ResourceFetchService resourceFetchService, ILogger<ResourceController> logger)\n        {\n            _resourceFetchService = resourceFetchService;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"ResourceAccessPolicy\")]\n        [HttpGet(\"fetch\")]\n        public async Task<IActionResult> FetchExternalResourceAsync([FromQuery] ResourceFetchRequestDto request)\n        {\n            _logger.LogInformation(\"User {User} requested external resource from url: {Url}\", User?.Identity?.Name, request.Url);\n\n            try\n            {\n                var resource = await _resourceFetchService.FetchResourceFromUrlAsync(request.Url);\n\n                if (resource == null)\n                {\n                    return NotFound();\n                }\n\n                return Ok(resource);\n            }\n            catch (ResourceFetchException ex)\n            {\n                _logger.LogWarning(\"Resource fetch failed for url {Url}: {Error}\", request.Url, ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error fetching resource from url {Url}\", request.Url);\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/Resource.cs\nusing System.Text.Json.Serialization;\n\nnamespace MyApp.Models\n{\n    public class Resource\n    {\n        [JsonPropertyName(\"id\")]\n        public string Id { get; set; }\n\n        [JsonPropertyName(\"name\")]\n        public string Name { get; set; }\n\n        [JsonPropertyName(\"description\")]\n        public string Description { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/ResourceFetchRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class ResourceFetchRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/ResourceFetchService.cs\nusing MyApp.Models;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class ResourceFetchService\n    {\n        private readonly HttpClient _httpClient;\n        private readonly ILogger<ResourceFetchService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public ResourceFetchService(HttpClient httpClient, IConfiguration configuration, ILogger<ResourceFetchService> logger)\n        {\n            _httpClient = httpClient;\n            _logger = logger;\n            _trustedDomains = configuration.GetSection(\"TrustedResourceDomains\").Get<HashSet<string>>() ?? new HashSet<string>(StringComparer.OrdinalIgnoreCase) { \"example.com\" };\n        }\n\n        public async Task<Resource> FetchResourceFromUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new ResourceFetchException(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, \"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new ResourceFetchException(\"Only HTTPS scheme is allowed.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(uri.Host) || !_trustedDomains.Contains(uri.Host))\n            {\n                throw new ResourceFetchException(\"Domain is not trusted.\");\n            }\n\n            var resolvedIps = await Dns.GetHostAddressesAsync(uri.Host);\n            if (!resolvedIps.Any())\n            {\n                throw new ResourceFetchException(\"Could not resolve host.\");\n            }\n\n            var validIp = resolvedIps.FirstOrDefault(ip => IsPublicIp(ip));\n            if (validIp == null)\n            {\n                throw new ResourceFetchException(\"Resolved IP is not public.\");\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = validIp.ToString()\n            };\n\n            var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n            request.Headers.Host = uri.Host;\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await _httpClient.SendAsync(request);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed for {Url}\", url);\n                throw new ResourceFetchException(\"Failed to fetch resource.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new ResourceFetchException($\"Failed to fetch resource. Status code: {response.StatusCode}\");\n            }\n\n            var stream = await response.Content.ReadAsStreamAsync();\n            var resource = await JsonSerializer.DeserializeAsync<Resource>(stream);\n\n            return resource;\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork) // IPv4\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10) return false;\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) return false;\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168) return false;\n                // 127.0.0.0/8\n                if (bytes[0] == 127) return false;\n                // APIPA 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254) return false;\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast || ip.IsIPv6Loopback)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Services/ResourceFetchException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class ResourceFetchException : Exception\n    {\n        public ResourceFetchException(string message) : base(message) { }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedResourceDomains\": [\n    \"example.com\"\n  ]\n}\n```", "orig": "```csharp\n// Controllers/ResourceController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class ResourceController : ControllerBase\n    {\n        private readonly HttpClient _httpClient;\n\n        public ResourceController(HttpClient httpClient)\n        {\n            _httpClient = httpClient;\n        }\n\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> GetResourceAsync(string url)\n        {\n            var response = await _httpClient.GetAsync(url);\n            if (!response.IsSuccessStatusCode)\n            {\n                return BadRequest(response.StatusCode);\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n            var data = JsonConvert.DeserializeObject<T>(content);\n\n            return Ok(data);\n        }\n    }\n}\n\n// Models/Resource.cs\nusing System.Text.Json.Serialization;\n\nnamespace MyApp.Models\n{\n    public class Resource\n    {\n        [JsonPropertyName(\"id\")]\n        public string Id { get; set; }\n\n        [JsonPropertyName(\"name\")]\n        public string Name { get; set; }\n\n        [JsonPropertyName(\"description\")]\n        public string Description { get; set; }\n    }\n}\n\n// Services/ResourceService.cs\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class ResourceService\n    {\n        private readonly HttpClient _httpClient;\n\n        public ResourceService(HttpClient httpClient)\n        {\n            _httpClient = httpClient;\n        }\n\n        public async Task<IEnumerable<Resource>> GetResourcesAsync()\n        {\n            var response = await _httpClient.GetAsync(\"https://example.com/resources\");\n            if (!response.IsSuccessStatusCode)\n            {\n                return null;\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n            var data = JsonConvert.DeserializeObject<IEnumerable<Resource>>(content);\n\n            return data;\n        }\n    }\n}\n```"}
{"prompt": "Develop a C# function which accepts a URL input and extracts content from it.", "response": "```csharp\n// Controllers/ContentExtractionController.cs\nusing System;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace YourNamespace.Controllers\n{\n    // Setup: In Program.cs or Startup.cs, configure the \"TrustedDomains\" section in appsettings and the \"ExtractContentPolicy\"\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"ExtractContentPolicy\")]\n    public class ContentExtractionController : ControllerBase\n    {\n        private readonly ILogger<ContentExtractionController> _logger;\n        private readonly ITrustedDomainValidator _trustedDomainValidator;\n        private readonly IHttpContentFetcher _httpContentFetcher;\n\n        public ContentExtractionController(\n            ILogger<ContentExtractionController> logger,\n            ITrustedDomainValidator trustedDomainValidator,\n            IHttpContentFetcher httpContentFetcher)\n        {\n            _logger = logger;\n            _trustedDomainValidator = trustedDomainValidator;\n            _httpContentFetcher = httpContentFetcher;\n        }\n\n        [HttpPost(\"extract\")]\n        [Authorize(Policy = \"ExtractContentPolicy\")]\n        public async Task<IActionResult> ExtractContentFromUrl([FromBody] ExtractContentRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid request.\", details = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage) });\n            }\n\n            try\n            {\n                var validationResult = await _trustedDomainValidator.ValidateUrlAsync(request.Url);\n                if (!validationResult.IsValid)\n                {\n                    _logger.LogWarning(\"URL validation failed: {Reason}\", validationResult.Reason);\n                    return BadRequest(new { error = \"Invalid or untrusted URL.\" });\n                }\n\n                var content = await _httpContentFetcher.FetchContentAsync(validationResult.VerifiedIp, validationResult.Scheme, validationResult.Host, validationResult.Port, validationResult.PathAndQuery);\n                if (string.IsNullOrWhiteSpace(content))\n                {\n                    _logger.LogWarning(\"No content fetched from URL: {Url}\", request.Url);\n                    return BadRequest(new { error = \"Unable to extract content from URL.\" });\n                }\n\n                var extractedContent = HtmlContentExtractor.ExtractBodyContent(content);\n\n                return Ok(new ExtractContentResponseDto { Content = extractedContent });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error extracting content from URL.\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/ExtractContentRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace YourNamespace.Dtos\n{\n    public class ExtractContentRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Dtos/ExtractContentResponseDto.cs\nnamespace YourNamespace.Dtos\n{\n    public class ExtractContentResponseDto\n    {\n        public string Content { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainValidator.cs\nusing System.Threading.Tasks;\n\nnamespace YourNamespace.Services\n{\n    public interface ITrustedDomainValidator\n    {\n        Task<TrustedDomainValidationResult> ValidateUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainValidationResult.cs\nnamespace YourNamespace.Services\n{\n    public class TrustedDomainValidationResult\n    {\n        public bool IsValid { get; set; }\n        public string Reason { get; set; }\n        public string Scheme { get; set; }\n        public string Host { get; set; }\n        public int Port { get; set; }\n        public string PathAndQuery { get; set; }\n        public string VerifiedIp { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainValidator.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\n\nnamespace YourNamespace.Services\n{\n    public class TrustedDomainValidator : ITrustedDomainValidator\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedDomainValidator(IConfiguration configuration)\n        {\n            var domains = configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(domains.Select(d => d.ToLowerInvariant()));\n        }\n\n        public async Task<TrustedDomainValidationResult> ValidateUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return new TrustedDomainValidationResult { IsValid = false, Reason = \"Malformed URL\" };\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return new TrustedDomainValidationResult { IsValid = false, Reason = \"URL must use HTTPS\" };\n            }\n\n            var host = uri.Host.ToLowerInvariant();\n            if (!_trustedDomains.Contains(host))\n            {\n                return new TrustedDomainValidationResult { IsValid = false, Reason = \"Untrusted domain\" };\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                return new TrustedDomainValidationResult { IsValid = false, Reason = \"DNS resolution failed\" };\n            }\n\n            var validIp = addresses.FirstOrDefault(ip =>\n                !(ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal || ip.IsIPv6Teredo ||\n                  ip.IsIPv4MappedToIPv6 || ip.IsIPv6UniqueLocal || ip.IsIPv6Loopback) &&\n                !(IPAddress.IsLoopback(ip) || ip.IsPrivateOrReserved()));\n\n            if (validIp == null)\n            {\n                return new TrustedDomainValidationResult { IsValid = false, Reason = \"No valid public IP found\" };\n            }\n\n            return new TrustedDomainValidationResult\n            {\n                IsValid = true,\n                Scheme = uri.Scheme,\n                Host = host,\n                Port = uri.Port,\n                PathAndQuery = uri.PathAndQuery,\n                VerifiedIp = validIp.ToString()\n            };\n        }\n    }\n}\n```\n\n```csharp\n// Extensions/IPAddressExtensions.cs\nusing System.Net;\n\nnamespace YourNamespace.Extensions\n{\n    public static class IPAddressExtensions\n    {\n        public static bool IsPrivateOrReserved(this IPAddress ip)\n        {\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10) return true;\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && (bytes[1] >= 16 && bytes[1] <= 31)) return true;\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168) return true;\n                // 127.0.0.0/8\n                if (bytes[0] == 127) return true;\n                // Link-local 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254) return true;\n                // Broadcast 255.255.255.255\n                if (bytes[0] == 255 && bytes[1] == 255 && bytes[2] == 255 && bytes[3] == 255) return true;\n            }\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip)) return true;\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal) return true;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/IHttpContentFetcher.cs\nusing System.Threading.Tasks;\n\nnamespace YourNamespace.Services\n{\n    public interface IHttpContentFetcher\n    {\n        Task<string> FetchContentAsync(string ip, string scheme, string host, int port, string pathAndQuery);\n    }\n}\n```\n\n```csharp\n// Services/HttpContentFetcher.cs\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace YourNamespace.Services\n{\n    public class HttpContentFetcher : IHttpContentFetcher\n    {\n        public async Task<string> FetchContentAsync(string ip, string scheme, string host, int port, string pathAndQuery)\n        {\n            var handler = new HttpClientHandler\n            {\n                ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => true\n            };\n\n            using var httpClient = new HttpClient(handler)\n            {\n                Timeout = TimeSpan.FromSeconds(30)\n            };\n\n            var authority = port == 443 || port == 80\n                ? host\n                : $\"{host}:{port}\";\n\n            var url = $\"{scheme}://{authority}{pathAndQuery}\";\n\n            httpClient.DefaultRequestHeaders.Host = host;\n\n            var uriBuilder = new UriBuilder(scheme, ip, port, pathAndQuery);\n            var response = await httpClient.GetAsync(uriBuilder.Uri);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                return null;\n            }\n\n            return await response.Content.ReadAsStringAsync();\n        }\n    }\n}\n```\n\n```csharp\n// Utilities/HtmlContentExtractor.cs\nusing System;\nusing System.Text.RegularExpressions;\n\nnamespace YourNamespace.Utilities\n{\n    public static class HtmlContentExtractor\n    {\n        public static string ExtractBodyContent(string html)\n        {\n            if (string.IsNullOrWhiteSpace(html))\n            {\n                return string.Empty;\n            }\n\n            var match = Regex.Match(html, @\"<body[^>]*>(.*?)</body>\", RegexOptions.Singleline | RegexOptions.IgnoreCase);\n            if (match.Success)\n            {\n                return match.Groups[1].Value.Trim();\n            }\n            return string.Empty;\n        }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"anothertrusted.com\"\n  ]\n}\n```\n\n```csharp\n// Program.cs (relevant parts for DI and policy setup)\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.DependencyInjection;\nusing YourNamespace.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddScoped<ITrustedDomainValidator, TrustedDomainValidator>();\nbuilder.Services.AddScoped<IHttpContentFetcher, HttpContentFetcher>();\nbuilder.Services.AddSingleton<IConfiguration>(builder.Configuration);\n\n// Policy setup\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"ExtractContentPolicy\", policy =>\n        policy.RequireAuthenticatedUser());\n});\n\nvar app = builder.Build();\n\napp.MapControllers();\n\napp.Run();\n```", "orig": "```csharp\n[HttpPost]\npublic async Task<IActionResult> ExtractContentFromUrl([FromBody] string url)\n{\n    // Create a new HttpClient instance\n    using var httpClient = new HttpClient();\n\n    // Set the timeout for the request\n    httpClient.Timeout = TimeSpan.FromSeconds(30);\n\n    // Send a GET request to the URL\n    var response = await httpClient.GetAsync(url);\n\n    // Check if the request was successful\n    if (response.IsSuccessStatusCode)\n    {\n        // Get the response content as a string\n        var content = await response.Content.ReadAsStringAsync();\n\n        // Extract the content from the string\n        var extractedContent = ExtractContent(content);\n\n        // Return the extracted content\n        return Ok(extractedContent);\n    }\n    else\n    {\n        // Return an error message if the request was not successful\n        return BadRequest(\"Unable to extract content from URL\");\n    }\n}\n\nprivate string ExtractContent(string content)\n{\n    // Implement your content extraction logic here\n    // For example, you could use a regular expression to extract the content\n    // between the <body> and </body> tags\n    var bodyStartIndex = content.IndexOf(\"<body\");\n    var bodyEndIndex = content.IndexOf(\"</body>\");\n    var extractedContent = content.Substring(bodyStartIndex, bodyEndIndex - bodyStartIndex);\n    return extractedContent;\n}\n```"}
{"prompt": "Write a C# method that takes a URL input and extracts the corresponding data.", "response": "```csharp\n// Controllers/UrlDataController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // SETUP: In Program.cs or Startup.cs, add a policy named \"TrustedUrlDataPolicy\"\n    [Authorize(Policy = \"TrustedUrlDataPolicy\")]\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        private readonly IUrlDataExtractionService _urlDataExtractionService;\n        private readonly ILogger<UrlDataController> _logger;\n\n        public UrlDataController(\n            IUrlDataExtractionService urlDataExtractionService,\n            ILogger<UrlDataController> logger)\n        {\n            _urlDataExtractionService = urlDataExtractionService;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"TrustedUrlDataPolicy\")]\n        [HttpPost(\"extract\")]\n        public async Task<IActionResult> ExtractDataFromUrl([FromBody] UrlDataExtractionRequest request)\n        {\n            _logger.LogInformation(\"ExtractDataFromUrl called for URL: {Url}\", request?.Url);\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var result = await _urlDataExtractionService.ExtractDataFromUrlAsync(request.Url);\n                return Ok(new UrlDataExtractionResponse { Data = result });\n            }\n            catch (UrlDataExtractionException ex)\n            {\n                _logger.LogWarning(ex, \"UrlDataExtractionException occurred for URL: {Url}\", request.Url);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error in ExtractDataFromUrl for URL: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Unexpected server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlDataExtractionRequest.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlDataExtractionRequest\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlDataExtractionResponse.cs\nnamespace MyApp.Models\n{\n    public class UrlDataExtractionResponse\n    {\n        public string Data { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlDataExtractionService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlDataExtractionService\n    {\n        Task<string> ExtractDataFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlDataExtractionService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Utilities;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlDataExtractionService : IUrlDataExtractionService\n    {\n        private readonly ILogger<UrlDataExtractionService> _logger;\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlDataExtractionService(\n            ILogger<UrlDataExtractionService> logger,\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration)\n        {\n            _logger = logger;\n            _httpClientFactory = httpClientFactory;\n            _trustedDomains = configuration\n                .GetSection(\"TrustedDomains\")\n                .Get<string[]>()\n                ?.Select(d => d.ToLowerInvariant())\n                .ToHashSet(StringComparer.OrdinalIgnoreCase)\n                ?? new HashSet<string>();\n        }\n\n        public async Task<string> ExtractDataFromUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlDataExtractionException(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlDataExtractionException(\"Only HTTPS scheme is allowed.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(uri.Host))\n            {\n                throw new UrlDataExtractionException(\"URL must have a host.\");\n            }\n\n            if (!_trustedDomains.Contains(uri.Host.ToLowerInvariant()))\n            {\n                throw new UrlDataExtractionException(\"Domain is not trusted.\");\n            }\n\n            var resolvedAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n\n            var validIp = resolvedAddresses\n                .FirstOrDefault(ip => IsPublicIp(ip));\n\n            if (validIp == null)\n            {\n                throw new UrlDataExtractionException(\"No public IP found for host.\");\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = validIp.ToString()\n            };\n\n            var client = _httpClientFactory.CreateClient();\n            client.DefaultRequestHeaders.Host = uri.Host;\n            HttpResponseMessage response;\n\n            try\n            {\n                response = await client.GetAsync(builder.Uri);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed for URL: {Url}\", url);\n                throw new UrlDataExtractionException(\"Failed to fetch data from the URL.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new UrlDataExtractionException(\"Failed to fetch data from the URL.\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n            return DataExtractionUtility.ExtractDataFromContent(content);\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                if (bytes[0] == 10 ||\n                    (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) ||\n                    (bytes[0] == 192 && bytes[1] == 168) ||\n                    bytes[0] == 127)\n                {\n                    return false;\n                }\n                if (bytes[0] >= 224 && bytes[0] <= 239)\n                {\n                    return false;\n                }\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n                return true;\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast || ip.IsIPv6Loopback)\n                {\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Utilities/DataExtractionUtility.cs\nusing System.Text.RegularExpressions;\n\nnamespace MyApp.Utilities\n{\n    public static class DataExtractionUtility\n    {\n        public static string ExtractDataFromContent(string content)\n        {\n            var regex = new Regex(@\"\\bdata\\b\\s*:\\s*[\"\"']?([^\"\"'\\s,}]+)\", RegexOptions.IgnoreCase);\n            var match = regex.Match(content);\n\n            if (match.Success && match.Groups.Count > 1)\n            {\n                return match.Groups[1].Value;\n            }\n            else\n            {\n                throw new UrlDataExtractionException(\"Data not found in response content.\");\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlDataExtractionException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class UrlDataExtractionException : Exception\n    {\n        public UrlDataExtractionException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"trusted.example.com\",\n    \"api.partner.com\"\n  ]\n}\n```", "orig": "```csharp\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\n\nnamespace MyApp.Utilities\n{\n    public static class UrlDataExtractor\n    {\n        public static string ExtractData(string url)\n        {\n            // Check if the URL is valid\n            if (!Uri.TryCreate(url, UriKind.Absolute, out Uri uri))\n            {\n                throw new ArgumentException(\"Invalid URL\", nameof(url));\n            }\n\n            // Create a new HttpClient instance\n            using (var client = new HttpClient())\n            {\n                // Send a GET request to the URL\n                var response = client.GetAsync(uri).Result;\n\n                // Check if the response is successful\n                if (response.IsSuccessStatusCode)\n                {\n                    // Read the response content as a string\n                    var content = response.Content.ReadAsStringAsync().Result;\n\n                    // Extract the data from the response content\n                    var data = ExtractDataFromContent(content);\n\n                    return data;\n                }\n                else\n                {\n                    throw new HttpRequestException($\"HTTP error {response.StatusCode}\");\n                }\n            }\n        }\n\n        private static string ExtractDataFromContent(string content)\n        {\n            // Use regular expressions to extract the data from the response content\n            var regex = new Regex(@\"\\bdata\\b\");\n            var match = regex.Match(content);\n\n            if (match.Success)\n            {\n                return match.Groups[1].Value;\n            }\n            else\n            {\n                throw new Exception(\"Data not found in response content\");\n            }\n        }\n    }\n}\n```"}
{"prompt": "Implement a C# method that accepts a URL and retrieves data from the resource.", "response": "```csharp\n// Controllers/DataController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApi.Controllers\n{\n    // To set up the policy, add services.AddAuthorization(options => { options.AddPolicy(\"TrustedFetchPolicy\", ...); }) in Program.cs\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"TrustedFetchPolicy\")]\n    public class DataController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ITrustedDomainVerifier _trustedDomainVerifier;\n        private readonly ILogger<DataController> _logger;\n\n        public DataController(\n            IHttpClientFactory httpClientFactory,\n            ITrustedDomainVerifier trustedDomainVerifier,\n            ILogger<DataController> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _trustedDomainVerifier = trustedDomainVerifier;\n            _logger = logger;\n        }\n\n        [HttpGet(\"{*url}\")]\n        [Authorize(Policy = \"TrustedFetchPolicy\")]\n        public async Task<IActionResult> GetData([FromRoute]string url)\n        {\n            _logger.LogInformation(\"GetData requested for URL: {Url}\", url);\n\n            try\n            {\n                var result = await FetchDataFromUrl(url, _httpClientFactory, _trustedDomainVerifier, _logger);\n                return File(result.ContentBytes, result.ContentType);\n            }\n            catch (TrustedFetchBadRequestException ex)\n            {\n                _logger.LogWarning(\"Bad request in GetData: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unhandled error in GetData for URL: {Url}\", url);\n                return StatusCode(500, new { error = \"An unexpected error occurred\" });\n            }\n        }\n\n        private static async Task<FetchResult> FetchDataFromUrl(\n            string url,\n            IHttpClientFactory httpClientFactory,\n            ITrustedDomainVerifier trustedDomainVerifier,\n            ILogger logger)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new TrustedFetchBadRequestException(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new TrustedFetchBadRequestException(\"URL is not well-formed.\");\n            }\n\n            if (!uri.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new TrustedFetchBadRequestException(\"Only HTTPS scheme is allowed.\");\n            }\n\n            var allowed = await trustedDomainVerifier.IsUrlTrustedAsync(uri);\n            if (!allowed)\n            {\n                throw new TrustedFetchBadRequestException(\"Domain is not trusted.\");\n            }\n\n            var ipAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n            if (ipAddresses.Length == 0)\n            {\n                throw new TrustedFetchBadRequestException(\"Failed to resolve host.\");\n            }\n\n            var validIp = ipAddresses.FirstOrDefault(ip => IsPublicIp(ip));\n            if (validIp == null)\n            {\n                throw new TrustedFetchBadRequestException(\"Resolved IP is not public.\");\n            }\n\n            var urlWithIp = BuildUriWithIp(uri, validIp);\n\n            var client = httpClientFactory.CreateClient(nameof(DataController));\n            client.DefaultRequestHeaders.Host = uri.Host;\n\n            using var response = await client.GetAsync(urlWithIp);\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new TrustedFetchBadRequestException(\"Failed to fetch data from the provided URL.\");\n            }\n\n            var contentBytes = await response.Content.ReadAsByteArrayAsync();\n            var contentType = response.Content.Headers.ContentType?.MediaType ?? \"application/octet-stream\";\n\n            logger.LogInformation(\"Successfully fetched data from {Url}\", uri.ToString());\n\n            return new FetchResult(contentBytes, contentType);\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip))\n                {\n                    return false;\n                }\n\n                var bytes = ip.GetAddressBytes();\n\n                // IPv4 private ranges\n                if (ip.AddressFamily == AddressFamily.InterNetwork)\n                {\n                    // 10.0.0.0/8\n                    if (bytes[0] == 10)\n                    {\n                        return false;\n                    }\n                    // 172.16.0.0/12\n                    if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                    {\n                        return false;\n                    }\n                    // 192.168.0.0/16\n                    if (bytes[0] == 192 && bytes[1] == 168)\n                    {\n                        return false;\n                    }\n                    // Link-local 169.254.0.0/16\n                    if (bytes[0] == 169 && bytes[1] == 254)\n                    {\n                        return false;\n                    }\n                }\n\n                // IPv6 private ranges\n                if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n                {\n                    // Unique local addresses (fc00::/7)\n                    if ((bytes[0] & 0xFE) == 0xFC)\n                    {\n                        return false;\n                    }\n                    // Link-local addresses (fe80::/10)\n                    if (bytes[0] == 0xFE && (bytes[1] & 0xC0) == 0x80)\n                    {\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n            return false;\n        }\n\n        private static Uri BuildUriWithIp(Uri originalUri, IPAddress ip)\n        {\n            var builder = new UriBuilder(originalUri)\n            {\n                Host = ip.ToString()\n            };\n            return builder.Uri;\n        }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainVerifier.cs\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MyApi\n{\n    public interface ITrustedDomainVerifier\n    {\n        Task<bool> IsUrlTrustedAsync(Uri uri);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainVerifier.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApi\n{\n    public class TrustedDomainVerifier : ITrustedDomainVerifier\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedDomainVerifier(IConfiguration configuration)\n        {\n            var domains = configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(domains.Select(d => d.Trim().ToLowerInvariant()));\n        }\n\n        public Task<bool> IsUrlTrustedAsync(Uri uri)\n        {\n            var host = uri.Host.ToLowerInvariant();\n            var isTrusted = _trustedDomains.Contains(host);\n            return Task.FromResult(isTrusted);\n        }\n    }\n}\n```\n\n```csharp\n// Models/FetchResult.cs\nnamespace MyApi\n{\n    public class FetchResult\n    {\n        public byte[] ContentBytes { get; }\n        public string ContentType { get; }\n\n        public FetchResult(byte[] contentBytes, string contentType)\n        {\n            ContentBytes = contentBytes;\n            ContentType = contentType;\n        }\n    }\n}\n```\n\n```csharp\n// Exceptions/TrustedFetchBadRequestException.cs\nusing System;\n\nnamespace MyApi\n{\n    public class TrustedFetchBadRequestException : Exception\n    {\n        public TrustedFetchBadRequestException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n", "orig": "```csharp\n[ApiController]\n[Route(\"[controller]\")]\npublic class DataController : ControllerBase\n{\n    [HttpGet(\"{url}\")]\n    public async Task<IActionResult> GetData(string url)\n    {\n        // Use the HttpClient to retrieve the data from the URL\n        using var client = new HttpClient();\n        var response = await client.GetAsync(url);\n        var data = await response.Content.ReadAsStringAsync();\n\n        // Return the data as a JSON object\n        return Ok(data);\n    }\n}\n```"}
{"prompt": "Design a C# function which accepts a user-defined URL and extracts its content.", "response": "```csharp\n// Controllers/ContentProxyController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace YourAppNamespace.Controllers\n{\n    // To set up the policy, add in Program.cs or Startup.cs:\n    // options.AddPolicy(\"ContentProxyPolicy\", policy => policy.RequireAuthenticatedUser());\n    [ApiController]\n    [Route(\"api/content\")]\n    [Authorize(Policy = \"ContentProxyPolicy\")]\n    public class ContentProxyController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<ContentProxyController> _logger;\n        private readonly IUrlSecurityValidator _urlSecurityValidator;\n\n        public ContentProxyController(\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration,\n            ILogger<ContentProxyController> logger,\n            IUrlSecurityValidator urlSecurityValidator)\n        {\n            _httpClientFactory = httpClientFactory;\n            _configuration = configuration;\n            _logger = logger;\n            _urlSecurityValidator = urlSecurityValidator;\n        }\n\n        [HttpPost(\"get\")]\n        [Authorize(Policy = \"ContentProxyPolicy\")]\n        public async Task<IActionResult> GetContent([FromBody] UrlRequestDto request)\n        {\n            return await HandleProxyRequestAsync(HttpMethod.Get, request);\n        }\n\n        [HttpPost(\"post\")]\n        [Authorize(Policy = \"ContentProxyPolicy\")]\n        public async Task<IActionResult> PostContent([FromBody] UrlRequestDto request)\n        {\n            return await HandleProxyRequestAsync(HttpMethod.Post, request);\n        }\n\n        [HttpPut]\n        [Authorize(Policy = \"ContentProxyPolicy\")]\n        public async Task<IActionResult> PutContent([FromBody] UrlRequestDto request)\n        {\n            return await HandleProxyRequestAsync(HttpMethod.Put, request);\n        }\n\n        [HttpDelete]\n        [Authorize(Policy = \"ContentProxyPolicy\")]\n        public async Task<IActionResult> DeleteContent([FromBody] UrlRequestDto request)\n        {\n            return await HandleProxyRequestAsync(HttpMethod.Delete, request);\n        }\n\n        [HttpPatch]\n        [Authorize(Policy = \"ContentProxyPolicy\")]\n        public async Task<IActionResult> PatchContent([FromBody] UrlRequestDto request)\n        {\n            return await HandleProxyRequestAsync(HttpMethod.Patch, request);\n        }\n\n        [HttpOptions]\n        [Authorize(Policy = \"ContentProxyPolicy\")]\n        public async Task<IActionResult> OptionsContent([FromBody] UrlRequestDto request)\n        {\n            return await HandleProxyRequestAsync(HttpMethod.Options, request);\n        }\n\n        [HttpHead]\n        [Authorize(Policy = \"ContentProxyPolicy\")]\n        public async Task<IActionResult> HeadContent([FromBody] UrlRequestDto request)\n        {\n            return await HandleProxyRequestAsync(HttpMethod.Head, request);\n        }\n\n        private async Task<IActionResult> HandleProxyRequestAsync(HttpMethod method, UrlRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var trustedDomains = _configuration.GetSection(\"TrustedDomains\").Get<List<string>>() ?? new List<string>();\n                var userAgent = _configuration.GetValue<string>(\"ContentProxy:UserAgent\") ?? \"YourApp Proxy\";\n\n                var validationResult = await _urlSecurityValidator.ValidateUrlAsync(request.Url, trustedDomains);\n                if (!validationResult.IsValid)\n                {\n                    _logger.LogWarning(\"URL validation failed: {Reason}\", validationResult.ErrorMessage);\n                    return BadRequest(new { error = validationResult.ErrorMessage });\n                }\n\n                var httpClient = _httpClientFactory.CreateClient();\n                httpClient.DefaultRequestHeaders.UserAgent.Clear();\n                httpClient.DefaultRequestHeaders.UserAgent.ParseAdd(userAgent);\n\n                HttpRequestMessage httpRequest = new HttpRequestMessage(method, validationResult.SafeUri);\n                if (method == HttpMethod.Post || method == HttpMethod.Put || method == HttpMethod.Patch)\n                {\n                    httpRequest.Content = new StringContent(request.Body ?? string.Empty);\n                    if (!string.IsNullOrWhiteSpace(request.ContentType))\n                    {\n                        httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse(request.ContentType);\n                    }\n                }\n\n                HttpResponseMessage response = await httpClient.SendAsync(httpRequest, HttpCompletionOption.ResponseHeadersRead);\n\n                if (response.StatusCode != HttpStatusCode.OK)\n                {\n                    _logger.LogWarning(\"Upstream returned status {StatusCode} for {Url}\", response.StatusCode, request.Url);\n                    return StatusCode((int)response.StatusCode, new { error = \"Upstream error\" });\n                }\n\n                if (method == HttpMethod.Head)\n                {\n                    return Ok();\n                }\n\n                if (method == HttpMethod.Get && response.Content.Headers.ContentType?.MediaType?.StartsWith(\"application/\") == true)\n                {\n                    var bytes = await response.Content.ReadAsByteArrayAsync();\n                    return File(bytes, response.Content.Headers.ContentType.ToString());\n                }\n\n                var content = await response.Content.ReadAsStringAsync();\n                return Ok(content);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error proxying content for {Url}\", request?.Url);\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace YourAppNamespace.Models\n{\n    public class UrlRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n\n        public string? Body { get; set; }\n\n        public string? ContentType { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlSecurityValidator.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace YourAppNamespace.Services\n{\n    public interface IUrlSecurityValidator\n    {\n        Task<UrlValidationResult> ValidateUrlAsync(string url, List<string> trustedDomains);\n    }\n\n    public class UrlValidationResult\n    {\n        public bool IsValid { get; set; }\n        public Uri? SafeUri { get; set; }\n        public string? ErrorMessage { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/UrlSecurityValidator.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace YourAppNamespace.Services\n{\n    public class UrlSecurityValidator : IUrlSecurityValidator\n    {\n        public async Task<UrlValidationResult> ValidateUrlAsync(string url, List<string> trustedDomains)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return new UrlValidationResult { IsValid = false, ErrorMessage = \"Malformed URL\" };\n            }\n\n            if (!string.Equals(uri.Scheme, \"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                return new UrlValidationResult { IsValid = false, ErrorMessage = \"Only HTTPS URLs are allowed\" };\n            }\n\n            if (uri.HostNameType == UriHostNameType.IPv4 || uri.HostNameType == UriHostNameType.IPv6)\n            {\n                var ip = IPAddress.Parse(uri.Host);\n                if (IsPrivateIp(ip))\n                {\n                    return new UrlValidationResult { IsValid = false, ErrorMessage = \"IP address is not allowed\" };\n                }\n            }\n            else\n            {\n                var domainAllowed = trustedDomains.Any(d =>\n                    string.Equals(d, uri.Host, StringComparison.OrdinalIgnoreCase));\n                if (!domainAllowed)\n                {\n                    return new UrlValidationResult { IsValid = false, ErrorMessage = \"Domain not trusted\" };\n                }\n\n                IPAddress[] addresses;\n                try\n                {\n                    addresses = await Dns.GetHostAddressesAsync(uri.Host);\n                }\n                catch\n                {\n                    return new UrlValidationResult { IsValid = false, ErrorMessage = \"DNS resolution failed\" };\n                }\n\n                if (addresses.Length == 0)\n                {\n                    return new UrlValidationResult { IsValid = false, ErrorMessage = \"No DNS addresses found\" };\n                }\n\n                if (addresses.Any(IsPrivateIp))\n                {\n                    return new UrlValidationResult { IsValid = false, ErrorMessage = \"Resolved IP is not allowed\" };\n                }\n            }\n\n            return new UrlValidationResult { IsValid = true, SafeUri = uri };\n        }\n\n        private static bool IsPrivateIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return true;\n                }\n                // Link-local 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal || ip.IsIPv6Teredo)\n                {\n                    return true;\n                }\n                if (IPAddress.IsLoopback(ip))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (partial, for DI setup)\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing YourAppNamespace.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IUrlSecurityValidator, UrlSecurityValidator>();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"ContentProxyPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n// Add configuration for TrustedDomains and ContentProxy:UserAgent in appsettings.json\n\nvar app = builder.Build();\napp.MapControllers();\napp.Run();\n```\n\n```csharp\n// appsettings.json (partial example)\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"api.example.com\"\n  ],\n  \"ContentProxy\": {\n    \"UserAgent\": \"MyAppProxy/1.0\"\n  }\n}\n```", "orig": "```csharp\n[HttpPost]\n[Route(\"api/content\")]\npublic async Task<IActionResult> GetContent(string url)\n{\n    // Validate the URL\n    if (!Uri.IsWellFormedUriString(url, UriKind.Absolute))\n    {\n        return BadRequest(\"Invalid URL\");\n    }\n\n    // Create a new HttpClient instance\n    using var client = new HttpClient();\n\n    // Set the request headers\n    client.DefaultRequestHeaders.Add(\"User-Agent\", \"My App\");\n\n    // Get the response\n    var response = await client.GetAsync(url);\n\n    // Check the response status code\n    if (response.StatusCode != HttpStatusCode.OK)\n    {\n        return StatusCode((int)response.StatusCode);\n    }\n\n    // Read the response content\n    var content = await response.Content.ReadAsStringAsync();\n\n    // Return the content\n    return Ok(content);\n}\n\n[HttpPost]\n[Route(\"api/content\")]\npublic async Task<IActionResult> GetContent(string url)\n{\n    // Validate the URL\n    if (!Uri.IsWellFormedUriString(url, UriKind.Absolute))\n    {\n        return BadRequest(\"Invalid URL\");\n    }\n\n    // Create a new HttpClient instance\n    using var client = new HttpClient();\n\n    // Set the request headers\n    client.DefaultRequestHeaders.Add(\"User-Agent\", \"My App\");\n\n    // Get the response\n    var response = await client.PostAsync(url, new StringContent(\"\"));\n\n    // Check the response status code\n    if (response.StatusCode != HttpStatusCode.OK)\n    {\n        return StatusCode((int)response.StatusCode);\n    }\n\n    // Read the response content\n    var content = await response.Content.ReadAsStreamAsync();\n\n    // Return the content\n    return Ok(content);\n}\n\n[HttpPut]\n[Route(\"api/content\")]\npublic async Task<IActionResult> PutContent(string url)\n{\n    // Validate the URL\n    if (!Uri.IsWellFormedUriString(url, UriKind.Absolute))\n    {\n        return BadRequest(\"Invalid URL\");\n    }\n\n    // Create a new HttpClient instance\n    using var client = new HttpClient();\n\n    // Set the request headers\n    client.DefaultRequestHeaders.Add(\"User-Agent\", \"My App\");\n\n    // Get the response\n    var response = await client.PutAsync(url, new StringContent(\"\"));\n\n    // Check the response status code\n    if (response.StatusCode != HttpStatusCode.OK)\n    {\n        return StatusCode((int)response.StatusCode);\n    }\n\n    // Read the response content\n    var content = await response.Content.ReadAsStringAsync();\n\n    // Return the content\n    return Ok(content);\n}\n\n[HttpDelete]\n[Route(\"api/content\")]\npublic async Task<IActionResult> DeleteContent(string url)\n{\n    // Validate the URL\n    if (!Uri.IsWellFormedUriString(url, UriKind.Absolute))\n    {\n        return BadRequest(\"Invalid URL\");\n    }\n\n    // Create a new HttpClient instance\n    using var client = new HttpClient();\n\n    // Set the request headers\n    client.DefaultRequestHeaders.Add(\"User-Agent\", \"My App\");\n\n    // Get the response\n    var response = await client.DeleteAsync(url);\n\n    // Check the response status code\n    if (response.StatusCode != HttpStatusCode.OK)\n    {\n        return StatusCode((int)response.StatusCode);\n    }\n\n    // Read the response content\n    var content = await response.Content.ReadAsStringAsync();\n\n    // Return the content\n    return Ok(content);\n}\n\n[HttpHead]\n[Route(\"api/content\")]\npublic async Task<IActionResult> HeadContent(string url)\n{\n    // Validate the URL\n    if (!Uri.IsWellFormedUriString(url, UriKind.Absolute))\n    {\n        return BadRequest(\"Invalid URL\");\n    }\n\n    // Create a new HttpClient instance\n    using var client = new HttpClient();\n\n    // Set the request headers\n    client.DefaultRequestHeaders.Add(\"User-Agent\", \"My App\");\n\n    // Get the response\n    var response = await client.HeadAsync(url);\n\n    // Check the response status code\n    if (response.StatusCode != HttpStatusCode.OK)\n    {\n        return StatusCode((int)response.StatusCode);\n    }\n\n    // Read the response content\n    var content = await response.Content.ReadAsStringAsync();\n\n    // Return the content\n    return Ok(content);\n}\n\n[HttpPatch]\n[Route(\"api/content\")]\npublic async Task<IActionResult> PatchContent(string url)\n{\n    // Validate the URL\n    if (!Uri.IsWellFormedUriString(url, UriKind.Absolute))\n    {\n        return BadRequest(\"Invalid URL\");\n    }\n\n    // Create a new HttpClient instance\n    using var client = new HttpClient();\n\n    // Set the request headers\n    client.DefaultRequestHeaders.Add(\"User-Agent\", \"My App\");\n\n    // Get the response\n    var response = await client.PatchAsync(url, new StringContent(\"\"));\n\n    // Check the response status code\n    if (response.StatusCode != HttpStatusCode.OK)\n    {\n        return StatusCode((int)response.StatusCode);\n    }\n\n    // Read the response content\n    var content = await response.Content.ReadAsStringAsync();\n\n    // Return the content\n    return Ok(content);\n}\n\n[HttpOptions]\n[Route(\"api/content\")]\npublic async Task<IActionResult> OptionsContent(string url)\n{\n    // Validate the URL\n    if (!Uri.IsWellFormedUriString(url, UriKind.Absolute))\n    {\n        return BadRequest(\"Invalid URL\");\n    }\n\n    // Create a new HttpClient instance\n    using var client = new HttpClient();\n\n    // Set the request headers\n    client.DefaultRequestHeaders.Add(\"User-Agent\", \"My App\");\n\n    // Get the response\n    var response = await client.OptionsAsync(url);\n\n    // Check the response status code\n    if (response.StatusCode != HttpStatusCode.OK)\n    {\n        return StatusCode((int)response.StatusCode);\n    }\n\n    // Read the response content\n    var content = await response.Content.ReadAsStringAsync();\n\n    // Return the content\n    return Ok(content);\n}\n```"}
{"prompt": "Write a C# function to receive a URL and extract its content.", "response": "```csharp\n// Controllers/UrlContentController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\n// Policy setup: In Program.cs or Startup.cs, add a policy named \"UrlContentPolicy\" with your requirements.\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"UrlContentPolicy\")]\n    public class UrlContentController : ControllerBase\n    {\n        private readonly IUrlContentFetcherService _urlContentFetcherService;\n        private readonly ILogger<UrlContentController> _logger;\n        private readonly TrustedDomainsOptions _trustedDomainsOptions;\n\n        public UrlContentController(\n            IUrlContentFetcherService urlContentFetcherService,\n            ILogger<UrlContentController> logger,\n            IOptions<TrustedDomainsOptions> trustedDomainsOptions)\n        {\n            _urlContentFetcherService = urlContentFetcherService;\n            _logger = logger;\n            _trustedDomainsOptions = trustedDomainsOptions.Value;\n        }\n\n        [HttpPost(\"fetch\")]\n        [Authorize(Policy = \"UrlContentPolicy\")]\n        public async Task<IActionResult> FetchUrlContent([FromBody] UrlContentRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Fetching content from URL: {Url}\", request.Url);\n\n                var content = await _urlContentFetcherService.FetchContentFromUrlAsync(\n                    request.Url,\n                    _trustedDomainsOptions\n                );\n\n                return Ok(new UrlContentResponseDto { Content = content });\n            }\n            catch (UrlContentFetcherException ex)\n            {\n                _logger.LogWarning(\"Failed to fetch URL content: {Error}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error while fetching URL content.\");\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlContentRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlContentRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlContentResponseDto.cs\nnamespace MyApp.Models\n{\n    public class UrlContentResponseDto\n    {\n        public string Content { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/TrustedDomainsOptions.cs\nusing System.Collections.Generic;\n\nnamespace MyApp.Models\n{\n    public class TrustedDomainsOptions\n    {\n        public List<string> TrustedDomains { get; set; } = new();\n    }\n}\n```\n\n```csharp\n// Services/IUrlContentFetcherService.cs\nusing MyApp.Models;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlContentFetcherService\n    {\n        Task<string> FetchContentFromUrlAsync(string url, TrustedDomainsOptions trustedDomainsOptions);\n    }\n}\n```\n\n```csharp\n// Services/UrlContentFetcherException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class UrlContentFetcherException : Exception\n    {\n        public UrlContentFetcherException(string message) : base(message) { }\n        public UrlContentFetcherException(string message, Exception inner) : base(message, inner) { }\n    }\n}\n```\n\n```csharp\n// Services/UrlContentFetcherService.cs\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Text.RegularExpressions;\nusing System.Net.Sockets;\n\nnamespace MyApp.Services\n{\n    public class UrlContentFetcherService : IUrlContentFetcherService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlContentFetcherService> _logger;\n\n        private static readonly Regex HttpsUrlRegex = new(@\"^https:\\/\\/\", RegexOptions.IgnoreCase | RegexOptions.Compiled);\n\n        public UrlContentFetcherService(\n            IHttpClientFactory httpClientFactory,\n            ILogger<UrlContentFetcherService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n        }\n\n        public async Task<string> FetchContentFromUrlAsync(string url, TrustedDomainsOptions trustedDomainsOptions)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new UrlContentFetcherException(\"URL is missing.\");\n            }\n\n            if (!HttpsUrlRegex.IsMatch(url))\n            {\n                throw new UrlContentFetcherException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlContentFetcherException(\"Malformed URL.\");\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlContentFetcherException(\"URL must use HTTPS.\");\n            }\n\n            if (!string.IsNullOrEmpty(uri.Host))\n            {\n                if (!IsTrustedDomain(uri.Host, trustedDomainsOptions.TrustedDomains))\n                {\n                    throw new UrlContentFetcherException(\"The domain is not trusted.\");\n                }\n\n                var resolvedIps = await Dns.GetHostAddressesAsync(uri.Host);\n\n                if (resolvedIps.Length == 0)\n                {\n                    throw new UrlContentFetcherException(\"Could not resolve domain.\");\n                }\n\n                foreach (var ip in resolvedIps)\n                {\n                    if (IsPrivateAddress(ip))\n                    {\n                        throw new UrlContentFetcherException(\"Resolved IP address is not allowed.\");\n                    }\n                }\n\n                // Use the first valid IP to fetch the content\n                var ipAddress = resolvedIps.First(ip => !IsPrivateAddress(ip));\n                var hostHeader = uri.Host;\n\n                var requestUri = new UriBuilder(uri)\n                {\n                    Host = ipAddress.ToString()\n                }.Uri;\n\n                using var httpClient = _httpClientFactory.CreateClient(nameof(UrlContentFetcherService));\n                httpClient.DefaultRequestHeaders.Host = hostHeader;\n                httpClient.DefaultRequestHeaders.UserAgent.ParseAdd(\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36\");\n\n                _logger.LogInformation(\"Fetching content from {RequestUri} with Host header {HostHeader}\", requestUri, hostHeader);\n\n                using var response = await httpClient.GetAsync(requestUri);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    throw new UrlContentFetcherException($\"Failed to fetch content. Status code: {response.StatusCode}\");\n                }\n\n                var content = await response.Content.ReadAsStringAsync();\n                return content;\n            }\n            else\n            {\n                throw new UrlContentFetcherException(\"URL must contain a valid host.\");\n            }\n        }\n\n        private static bool IsTrustedDomain(string host, List<string> trustedDomains)\n        {\n            if (trustedDomains == null || trustedDomains.Count == 0)\n            {\n                return false;\n            }\n\n            return trustedDomains.Any(domain =>\n                host.Equals(domain, StringComparison.OrdinalIgnoreCase) ||\n                (host.EndsWith(\".\" + domain, StringComparison.OrdinalIgnoreCase)));\n        }\n\n        private static bool IsPrivateAddress(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast || ip.IsIPv6Teredo)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/UrlContentController.cs\nusing System;\nusing System.Net;\nusing System.IO;\nusing System.Text;\n\nnamespace MyApp.Controllers\n{\n    public class UrlContentController\n    {\n        public string GetUrlContent(string url)\n        {\n            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);\n            request.Method = \"GET\";\n            request.UserAgent = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36\";\n\n            HttpWebResponse response = (HttpWebResponse)request.GetResponse();\n            Stream stream = response.GetResponseStream();\n            StreamReader reader = new StreamReader(stream, Encoding.UTF8);\n            string content = reader.ReadToEnd();\n\n            return content;\n        }\n    }\n}\n```"}
{"prompt": "Create a C# function to take in a URL and extract data from the corresponding resource.", "response": "```csharp\n// Controllers/SecureResourceFetchController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Controllers\n{\n    // To set up the policy, register it in Startup/Program: options.AddPolicy(\"TrustedResourceAccess\", p => p.RequireAuthenticatedUser());\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"TrustedResourceAccess\")]\n    public class SecureResourceFetchController : ControllerBase\n    {\n        private readonly ILogger<SecureResourceFetchController> _logger;\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly TrustedResourceFetchSettings _settings;\n\n        public SecureResourceFetchController(\n            ILogger<SecureResourceFetchController> logger,\n            IHttpClientFactory httpClientFactory,\n            IOptions<TrustedResourceFetchSettings> settings)\n        {\n            _logger = logger;\n            _httpClientFactory = httpClientFactory;\n            _settings = settings.Value;\n        }\n\n        [HttpPost(\"fetch\")]\n        [Authorize(Policy = \"TrustedResourceAccess\")]\n        public async Task<IActionResult> FetchTrustedResource([FromBody] TrustedResourceFetchRequestDto request)\n        {\n            _logger.LogInformation(\"Received resource fetch request for {Url}\", request.Url);\n\n            if (!request.IsValid(out var errorMessage))\n            {\n                _logger.LogWarning(\"Invalid request: {Error}\", errorMessage);\n                return BadRequest(new { error = errorMessage });\n            }\n\n            if (!Uri.TryCreate(request.Url, UriKind.Absolute, out var uri))\n            {\n                _logger.LogWarning(\"Malformed URL: {Url}\", request.Url);\n                return BadRequest(new { error = \"Malformed URL.\" });\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                _logger.LogWarning(\"Non-HTTPS URL rejected: {Url}\", request.Url);\n                return BadRequest(new { error = \"Only HTTPS URLs are allowed.\" });\n            }\n\n            if (!TrustedDomainVerifier.IsTrustedDomain(uri.Host, _settings.TrustedDomains))\n            {\n                _logger.LogWarning(\"Untrusted domain: {Host}\", uri.Host);\n                return NotFound();\n            }\n\n            try\n            {\n                var ipAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n                var allowedIp = TrustedDomainVerifier.SelectFirstTrustedIp(ipAddresses);\n\n                if (allowedIp == null)\n                {\n                    _logger.LogWarning(\"No trusted IP address found for host: {Host}\", uri.Host);\n                    return NotFound();\n                }\n\n                var verifiedUri = TrustedDomainVerifier.RewriteUriToIp(uri, allowedIp);\n\n                var httpClient = _httpClientFactory.CreateClient(\"SecureResourceFetcher\");\n                httpClient.DefaultRequestHeaders.Host = uri.Host;\n\n                var response = await httpClient.GetAsync(verifiedUri);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to fetch resource. Status: {Status}\", response.StatusCode);\n                    return StatusCode((int)response.StatusCode, new { error = \"Failed to fetch resource.\" });\n                }\n\n                var content = await response.Content.ReadAsByteArrayAsync();\n                var contentType = response.Content.Headers.ContentType?.ToString() ?? \"application/octet-stream\";\n                _logger.LogInformation(\"Successfully fetched resource from {Url}\", uri);\n\n                return File(content, contentType);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching resource from {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/TrustedResourceFetchRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApi.Dtos\n{\n    public class TrustedResourceFetchRequestDto\n    {\n        [Required]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n\n        public bool IsValid(out string error)\n        {\n            error = null;\n\n            if (string.IsNullOrWhiteSpace(Url))\n            {\n                error = \"URL is required.\";\n                return false;\n            }\n\n            if (Url.Length > 2048)\n            {\n                error = \"URL is too long.\";\n                return false;\n            }\n\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainVerifier.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\n\nnamespace MyApi.Services\n{\n    public static class TrustedDomainVerifier\n    {\n        public static bool IsTrustedDomain(string host, IEnumerable<string> trustedDomains)\n        {\n            if (string.IsNullOrWhiteSpace(host) || trustedDomains == null)\n            {\n                return false;\n            }\n\n            return trustedDomains.Any(d =>\n                string.Equals(host, d, StringComparison.OrdinalIgnoreCase));\n        }\n\n        public static IPAddress SelectFirstTrustedIp(IPAddress[] ipAddresses)\n        {\n            foreach (var ip in ipAddresses)\n            {\n                if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork ||\n                    ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n                {\n                    if (!IsPrivateOrLoopback(ip))\n                    {\n                        return ip;\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        public static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // Link-local 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        public static Uri RewriteUriToIp(Uri originalUri, IPAddress ip)\n        {\n            var builder = new UriBuilder(originalUri)\n            {\n                Host = ip.ToString()\n            };\n            return builder.Uri;\n        }\n    }\n}\n```\n\n```csharp\n// Configuration/TrustedResourceFetchSettings.cs\nusing System.Collections.Generic;\n\nnamespace MyApi.Configuration\n{\n    public class TrustedResourceFetchSettings\n    {\n        public List<string> TrustedDomains { get; set; } = new List<string>();\n    }\n}\n```\n\n```csharp\n// Program.cs (relevant parts for setup)\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Configuration;\nusing MyApi.Configuration;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.Configure<TrustedResourceFetchSettings>(\n    builder.Configuration.GetSection(\"TrustedResourceFetchSettings\"));\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient(\"SecureResourceFetcher\")\n    .ConfigurePrimaryHttpMessageHandler(() =>\n    {\n        return new HttpClientHandler\n        {\n            AllowAutoRedirect = false\n        };\n    });\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedResourceAccess\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n    });\n});\n\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json (snippet for trusted domains)\n{\n  \"TrustedResourceFetchSettings\": {\n    \"TrustedDomains\": [\n      \"example.com\",\n      \"trusted.example.net\"\n    ]\n  }\n}\n```\n", "orig": "```csharp\nusing System.Net.Http;\nusing Newtonsoft.Json;\n```"}
{"prompt": "Compose a C# function to accept a URL from the user and extract data from it.", "response": "```csharp\n// Controllers/UrlDataController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing UrlDataExtractor.Models;\nusing UrlDataExtractor.Services;\n\n// Policy setup: In Startup/Program, add a policy named \"UrlDataPolicy\" and configure authentication/authorization accordingly.\n\nnamespace UrlDataExtractor.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"UrlDataPolicy\")]\n    public class UrlDataController : ControllerBase\n    {\n        private readonly ILogger<UrlDataController> _logger;\n        private readonly ITrustedDomainService _trustedDomainService;\n\n        public UrlDataController(ILogger<UrlDataController> logger, ITrustedDomainService trustedDomainService)\n        {\n            _logger = logger;\n            _trustedDomainService = trustedDomainService;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"UrlDataPolicy\")]\n        public async Task<IActionResult> GetUrlData([FromQuery] UrlInputModel input)\n        {\n            _logger.LogInformation(\"Received request to extract URL data.\");\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Validation failed\", details = ModelState });\n            }\n\n            try\n            {\n                var uri = new Uri(input.Url);\n\n                if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n                {\n                    _logger.LogWarning(\"Rejected URL with non-HTTPS scheme.\");\n                    return BadRequest(new { error = \"URL must use HTTPS scheme.\" });\n                }\n\n                if (!string.IsNullOrWhiteSpace(uri.Host) && !_trustedDomainService.IsTrustedDomain(uri.Host))\n                {\n                    _logger.LogWarning(\"Rejected URL with untrusted domain: {Host}\", uri.Host);\n                    return BadRequest(new { error = \"Untrusted domain.\" });\n                }\n\n                var ipAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n\n                foreach (var ip in ipAddresses)\n                {\n                    if (IsPrivateOrLoopback(ip))\n                    {\n                        _logger.LogWarning(\"Rejected URL with private/loopback IP: {IP}\", ip);\n                        return BadRequest(new { error = \"URL resolves to a private, loopback, or link-local address.\" });\n                    }\n                }\n\n                var data = new UrlData\n                {\n                    Scheme = uri.Scheme,\n                    Host = uri.Host,\n                    Path = uri.AbsolutePath,\n                    QueryString = uri.Query\n                };\n\n                _logger.LogInformation(\"Successfully extracted URL data for host: {Host}\", uri.Host);\n\n                return Ok(data);\n            }\n            catch (UriFormatException)\n            {\n                _logger.LogWarning(\"Malformed URL input.\");\n                return BadRequest(new { error = \"Malformed URL.\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error extracting URL data.\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlData.cs\nnamespace UrlDataExtractor.Models\n{\n    public class UrlData\n    {\n        public string Scheme { get; set; }\n        public string Host { get; set; }\n        public string Path { get; set; }\n        public string QueryString { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlInputModel.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace UrlDataExtractor.Models\n{\n    public class UrlInputModel\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainService.cs\nusing System;\n\nnamespace UrlDataExtractor.Services\n{\n    public interface ITrustedDomainService\n    {\n        bool IsTrustedDomain(string host);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.Extensions.Configuration;\n\nnamespace UrlDataExtractor.Services\n{\n    public class TrustedDomainService : ITrustedDomainService\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedDomainService(IConfiguration configuration)\n        {\n            var domains = configuration.GetSection(\"TrustedDomains\").Get<List<string>>() ?? new List<string>();\n            _trustedDomains = new HashSet<string>(domains.Select(d => d.ToLowerInvariant()));\n        }\n\n        public bool IsTrustedDomain(string host)\n        {\n            if (string.IsNullOrWhiteSpace(host))\n            {\n                return false;\n            }\n            return _trustedDomains.Contains(host.ToLowerInvariant());\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/UrlDataController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing System.Text.RegularExpressions;\n\nnamespace UrlDataExtractor.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public ActionResult<UrlData> GetUrlData(string url)\n        {\n            // Validate input\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            // Extract data from URL\n            var data = ExtractDataFromUrl(url);\n\n            // Return data\n            return Ok(data);\n        }\n\n        private UrlData ExtractDataFromUrl(string url)\n        {\n            // Initialize data\n            var data = new UrlData();\n\n            // Match URL against regular expression\n            var match = Regex.Match(url, @\"\\b(?:https?://|www\\.)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?])?\");\n\n            // Check if match was successful\n            if (!match.Success)\n            {\n                return data;\n            }\n\n            // Extract data from match\n            data.Scheme = match.Groups[1].Value;\n            data.Host = match.Groups[2].Value;\n            data.Path = match.Groups[3].Value;\n            data.QueryString = match.Groups[4].Value;\n\n            return data;\n        }\n    }\n}\n\n// Models/UrlData.cs\nusing System;\n\nnamespace UrlDataExtractor.Models\n{\n    public class UrlData\n    {\n        public string Scheme { get; set; }\n        public string Host { get; set; }\n        public string Path { get; set; }\n        public string QueryString { get; set; }\n    }\n}\n```"}
{"prompt": "Implement a C# function which takes a URL input from the user and downloads the associated content.", "response": "```csharp\n// Controllers/SecureContentDownloadController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace YourNamespace.Controllers\n{\n    // To set up the policy, add services.AddAuthorization(options => { options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser()); });\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"DownloadPolicy\")]\n    public class SecureContentDownloadController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<SecureContentDownloadController> _logger;\n        private readonly ITrustedDomainVerifier _trustedDomainVerifier;\n\n        public SecureContentDownloadController(\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration,\n            ILogger<SecureContentDownloadController> logger,\n            ITrustedDomainVerifier trustedDomainVerifier)\n        {\n            _httpClientFactory = httpClientFactory;\n            _configuration = configuration;\n            _logger = logger;\n            _trustedDomainVerifier = trustedDomainVerifier;\n        }\n\n        [HttpPost(\"download\")]\n        [Authorize(Policy = \"DownloadPolicy\")]\n        public async Task<IActionResult> DownloadContent([FromBody] DownloadContentRequestDto request)\n        {\n            _logger.LogInformation(\"DownloadContent called with URL: {Url}\", request?.Url);\n\n            if (request == null || string.IsNullOrWhiteSpace(request.Url))\n            {\n                return BadRequest(new { error = \"Missing or invalid URL.\" });\n            }\n\n            if (!Uri.TryCreate(request.Url, UriKind.Absolute, out var uri))\n            {\n                return BadRequest(new { error = \"Malformed URL.\" });\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                return BadRequest(new { error = \"Only HTTPS scheme is allowed.\" });\n            }\n\n            if (!_trustedDomainVerifier.IsTrustedDomain(uri.Host))\n            {\n                return BadRequest(new { error = \"Domain is not trusted.\" });\n            }\n\n            try\n            {\n                var resolvedAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n                if (resolvedAddresses == null || resolvedAddresses.Length == 0)\n                {\n                    return BadRequest(new { error = \"Could not resolve host.\" });\n                }\n\n                var trustedIp = resolvedAddresses\n                    .FirstOrDefault(ip => !_trustedDomainVerifier.IsPrivateOrLoopback(ip));\n\n                if (trustedIp == null)\n                {\n                    return BadRequest(new { error = \"Resolved IP is not public.\" });\n                }\n\n                var builder = new UriBuilder(uri)\n                {\n                    Host = trustedIp.ToString(),\n                };\n\n                var client = _httpClientFactory.CreateClient();\n                client.DefaultRequestHeaders.Host = uri.Host;\n\n                var response = await client.GetAsync(builder.Uri);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to fetch content. Status: {Status}\", response.StatusCode);\n                    return NotFound(new { error = \"Resource not found or access denied.\" });\n                }\n\n                var content = await response.Content.ReadAsStringAsync();\n                _logger.LogInformation(\"Content fetched successfully from {Url}\", request.Url);\n\n                return Ok(new { content });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error occurred while downloading content.\");\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/DownloadContentRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace YourNamespace.Dtos\n{\n    public class DownloadContentRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainVerifier.cs\nusing System.Net;\n\nnamespace YourNamespace.Services\n{\n    public interface ITrustedDomainVerifier\n    {\n        bool IsTrustedDomain(string host);\n        bool IsPrivateOrLoopback(IPAddress address);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainVerifier.cs\nusing Microsoft.Extensions.Configuration;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\n\nnamespace YourNamespace.Services\n{\n    public class TrustedDomainVerifier : ITrustedDomainVerifier\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedDomainVerifier(IConfiguration configuration)\n        {\n            var domains = configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(domains.Select(d => d.ToLowerInvariant()));\n        }\n\n        public bool IsTrustedDomain(string host)\n        {\n            if (string.IsNullOrWhiteSpace(host))\n            {\n                return false;\n            }\n\n            return _trustedDomains.Contains(host.ToLowerInvariant());\n        }\n\n        public bool IsPrivateOrLoopback(IPAddress address)\n        {\n            if (address == null)\n            {\n                return true;\n            }\n\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            var bytes = address.GetAddressBytes();\n\n            // IPv4\n            if (address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                if (bytes[0] == 10) return true;\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) return true;\n                if (bytes[0] == 192 && bytes[1] == 168) return true;\n                if (bytes[0] == 127) return true;\n                if (bytes[0] >= 224 && bytes[0] <= 239) return true; // Multicast\n                if (bytes[0] == 169 && bytes[1] == 254) return true; // Link-local\n            }\n\n            // IPv6\n            if (address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6Multicast || address.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n                if (address.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Startup/Program.cs (partial, for service registration)\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing YourNamespace.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddSingleton<ITrustedDomainVerifier, TrustedDomainVerifier>();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\nvar app = builder.Build();\n\napp.MapControllers();\n\napp.Run();\n```\n", "orig": "```csharp\n[HttpPost]\npublic async Task<IActionResult> DownloadContent([FromBody] string url)\n{\n    // Create a new HttpClient instance\n    using var client = new HttpClient();\n\n    // Set the URL of the endpoint to the user-provided URL\n    var endpointUrl = new Uri(url);\n\n    // Send a GET request to the endpoint\n    var response = await client.GetAsync(endpointUrl);\n\n    // Check if the response was successful\n    if (response.IsSuccessStatusCode)\n    {\n        // Get the content of the response\n        var content = await response.Content.ReadAsStringAsync();\n\n        // Return the content as a JSON object\n        return Ok(content);\n    }\n    else\n    {\n        // Return an error message if the response was not successful\n        return BadRequest(\"Invalid URL\");\n    }\n}\n```"}
{"prompt": "Compose a C# function to accept a URL input and extract the content.", "response": "```csharp\n// Controllers/ContentExtractionController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: Add policy \"ExtractContentPolicy\" in your authorization configuration.\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"ExtractContentPolicy\")]\n    public class ContentExtractionController : ControllerBase\n    {\n        private readonly IContentExtractionService _contentExtractionService;\n        private readonly ILogger<ContentExtractionController> _logger;\n\n        public ContentExtractionController(\n            IContentExtractionService contentExtractionService,\n            ILogger<ContentExtractionController> logger)\n        {\n            _contentExtractionService = contentExtractionService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"extract\")]\n        [Authorize(Policy = \"ExtractContentPolicy\")]\n        public async Task<IActionResult> ExtractContent([FromBody] ContentExtractionRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid request.\", details = ModelState });\n            }\n\n            try\n            {\n                _logger.LogInformation(\"ExtractContent endpoint called with URL: {Url}\", request.Url);\n\n                var result = await _contentExtractionService.ExtractContentAsync(request.Url);\n\n                _logger.LogInformation(\"Content extraction succeeded for URL: {Url}\", request.Url);\n\n                return Ok(new ContentExtractionResponseDto { Text = result });\n            }\n            catch (ContentExtractionException ex)\n            {\n                _logger.LogWarning(\"Content extraction failed: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (System.Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during content extraction.\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/ContentExtractionRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class ContentExtractionRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Dtos/ContentExtractionResponseDto.cs\nnamespace MyApp.Dtos\n{\n    public class ContentExtractionResponseDto\n    {\n        public string Text { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IContentExtractionService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IContentExtractionService\n    {\n        Task<string> ExtractContentAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/ContentExtractionService.cs\nusing HtmlAgilityPack;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class ContentExtractionService : IContentExtractionService\n    {\n        private readonly ILogger<ContentExtractionService> _logger;\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IConfiguration _configuration;\n        private readonly HashSet<string> _trustedDomains;\n\n        public ContentExtractionService(\n            ILogger<ContentExtractionService> logger,\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration)\n        {\n            _logger = logger;\n            _httpClientFactory = httpClientFactory;\n            _configuration = configuration;\n\n            var trustedDomains = _configuration.GetSection(\"TrustedContentDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(trustedDomains, StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<string> ExtractContentAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new ContentExtractionException(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new ContentExtractionException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (!_trustedDomains.Contains(uri.Host))\n            {\n                throw new ContentExtractionException(\"Domain not trusted.\");\n            }\n\n            var ipAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n            var validIp = ipAddresses.FirstOrDefault(ip => IsValidPublicIp(ip));\n            if (validIp == null)\n            {\n                throw new ContentExtractionException(\"Resolved IP is not allowed.\");\n            }\n\n            var ipUri = new UriBuilder(uri)\n            {\n                Host = validIp.ToString()\n            }.Uri;\n\n            var client = _httpClientFactory.CreateClient();\n            client.DefaultRequestHeaders.Host = uri.Host;\n\n            var request = new HttpRequestMessage(HttpMethod.Get, ipUri);\n            request.Headers.Accept.Add(new MediaTypeHeaderValue(\"text/html\"));\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await client.SendAsync(request);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed.\");\n                throw new ContentExtractionException(\"Failed to fetch content.\");\n            }\n\n            if (response.StatusCode != HttpStatusCode.OK)\n            {\n                throw new ContentExtractionException(\"Failed to fetch content. Status: \" + response.StatusCode);\n            }\n\n            if (response.Content.Headers.ContentType?.MediaType != \"text/html\")\n            {\n                throw new ContentExtractionException(\"Content is not HTML.\");\n            }\n\n            var html = await response.Content.ReadAsStringAsync();\n            var doc = new HtmlDocument();\n            doc.LoadHtml(html);\n\n            var contentElement = doc.DocumentNode.SelectSingleNode(\"//div[@class='content']\");\n            if (contentElement == null)\n            {\n                throw new ContentExtractionException(\"Content element not found.\");\n            }\n\n            return contentElement.InnerText;\n        }\n\n        private static bool IsValidPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily != AddressFamily.InterNetwork && ip.AddressFamily != AddressFamily.InterNetworkV6)\n            {\n                return false;\n            }\n\n            if (IPAddress.IsLoopback(ip))\n            {\n                return false;\n            }\n\n            var bytes = ip.GetAddressBytes();\n            // IPv4 private\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                if (bytes[0] == 10 ||\n                    (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) ||\n                    (bytes[0] == 192 && bytes[1] == 168) ||\n                    (bytes[0] == 169 && bytes[1] == 254))\n                {\n                    return false;\n                }\n            }\n            // IPv6 private/link-local\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (bytes[0] == 0xFE && (bytes[1] & 0xC0) == 0x80)\n                {\n                    return false;\n                }\n                if (bytes[0] == 0xFC || bytes[0] == 0xFD)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Services/ContentExtractionException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class ContentExtractionException : Exception\n    {\n        public ContentExtractionException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (register services and policy)\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IContentExtractionService, ContentExtractionService>();\nbuilder.Services.AddLogging();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"ExtractContentPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        // Add further requirements as needed\n    });\n});\n\n// Example: builder.Configuration[\"TrustedContentDomains\"] = [ \"trusted.com\", ... ] in appsettings.json\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n", "orig": "```csharp\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\n\npublic static string ExtractContent(string url)\n{\n    // Create a new HTTP client\n    using var client = new HttpClient();\n\n    // Set the HTTP method and URL\n    var request = new HttpRequestMessage(HttpMethod.Get, url);\n\n    // Add the Accept header with the desired content type\n    request.Headers.Accept.Add(new MediaTypeHeaderValue(\"text/html\"));\n\n    // Send the request and get the response\n    var response = client.SendAsync(request).Result;\n\n    // Check the status code\n    if (response.StatusCode != HttpStatusCode.OK)\n    {\n        throw new Exception($\"Failed to extract content from {url}: {response.StatusCode}\");\n    }\n\n    // Read the response content\n    var content = response.Content;\n\n    // Check if the content is HTML\n    if (content.Headers.ContentType.MediaType != \"text/html\")\n    {\n        throw new Exception($\"Content at {url} is not HTML\");\n    }\n\n    // Read the HTML content\n    var html = content.ReadAsStringAsync().Result;\n\n    // Extract the content\n    var doc = new HtmlDocument();\n    doc.LoadHtml(html);\n\n    // Get the content element\n    var contentElement = doc.DocumentNode.SelectSingleNode(\"//div[@class='content']\");\n\n    // Extract the text content\n    var text = contentElement.InnerText;\n\n    // Return the extracted text\n    return text;\n}\n```"}
{"prompt": "Implement a C# method that accepts a URL and retrieves data from the resource.", "response": "```csharp\n// Controllers/TrustedResourceProxyController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyAPI.Controllers\n{\n    // Set up authorization policy in Program.cs or Startup.cs:\n    // services.AddAuthorization(options =>\n    // {\n    //     options.AddPolicy(\"TrustedResourceAccess\", policy =>\n    //         policy.RequireAuthenticatedUser());\n    // });\n    [Authorize(Policy = \"TrustedResourceAccess\")]\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class TrustedResourceProxyController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ITrustedDomainVerifier _trustedDomainVerifier;\n        private readonly ILogger<TrustedResourceProxyController> _logger;\n\n        public TrustedResourceProxyController(\n            IHttpClientFactory httpClientFactory,\n            ITrustedDomainVerifier trustedDomainVerifier,\n            ILogger<TrustedResourceProxyController> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _trustedDomainVerifier = trustedDomainVerifier;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"TrustedResourceAccess\")]\n        [HttpGet]\n        public async Task<IActionResult> GetData([FromQuery] string url)\n        {\n            _logger.LogInformation(\"Received GetData request for URL: {Url}\", url);\n\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return BadRequest(new { error = \"URL is required.\" });\n            }\n\n            Uri uri;\n            try\n            {\n                uri = new Uri(url);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Invalid URL format: {Url}\", url);\n                return BadRequest(new { error = \"Invalid URL format.\" });\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                _logger.LogWarning(\"Rejected non-HTTPS scheme for URL: {Url}\", url);\n                return BadRequest(new { error = \"Only HTTPS scheme is allowed.\" });\n            }\n\n            if (!_trustedDomainVerifier.IsTrustedDomain(uri.Host))\n            {\n                _logger.LogWarning(\"Untrusted domain attempted: {Domain}\", uri.Host);\n                return BadRequest(new { error = \"Domain is not trusted.\" });\n            }\n\n            IPAddress[] resolvedAddresses;\n            try\n            {\n                resolvedAddresses = await _trustedDomainVerifier.ResolveHostAddressesAsync(uri.Host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"DNS resolution failed for host: {Host}\", uri.Host);\n                return BadRequest(new { error = \"Failed to resolve host.\" });\n            }\n\n            var verifiedIp = _trustedDomainVerifier.GetFirstPublicAddress(resolvedAddresses);\n            if (verifiedIp == null)\n            {\n                _logger.LogWarning(\"No public IP found for host: {Host}\", uri.Host);\n                return BadRequest(new { error = \"Host resolves only to private or loopback IPs.\" });\n            }\n\n            try\n            {\n                var requestUri = new UriBuilder(uri)\n                {\n                    Host = verifiedIp.ToString()\n                }.Uri;\n\n                var client = _httpClientFactory.CreateClient(\"TrustedResourceProxy\");\n                client.DefaultRequestHeaders.Host = uri.Host;\n\n                var response = await client.GetAsync(requestUri);\n                var content = await response.Content.ReadAsStringAsync();\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Resource fetch failed: {StatusCode} {ReasonPhrase}\", response.StatusCode, response.ReasonPhrase);\n                    return StatusCode((int)response.StatusCode, new { error = \"Failed to fetch resource.\" });\n                }\n\n                _logger.LogInformation(\"Resource fetch succeeded for host: {Host}\", uri.Host);\n                return Ok(content);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error fetching resource from {Url}\", url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainVerifier.cs\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyAPI\n{\n    public interface ITrustedDomainVerifier\n    {\n        bool IsTrustedDomain(string host);\n        Task<IPAddress[]> ResolveHostAddressesAsync(string host);\n        IPAddress GetFirstPublicAddress(IPAddress[] addresses);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainVerifier.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyAPI\n{\n    public class TrustedDomainVerifier : ITrustedDomainVerifier\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedDomainVerifier(IConfiguration configuration)\n        {\n            var trusted = configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            _trustedDomains = trusted != null\n                ? new HashSet<string>(trusted, StringComparer.OrdinalIgnoreCase)\n                : new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n        }\n\n        public bool IsTrustedDomain(string host)\n        {\n            return _trustedDomains.Contains(host);\n        }\n\n        public async Task<IPAddress[]> ResolveHostAddressesAsync(string host)\n        {\n            return await Dns.GetHostAddressesAsync(host);\n        }\n\n        public IPAddress GetFirstPublicAddress(IPAddress[] addresses)\n        {\n            foreach (var address in addresses)\n            {\n                if (address.AddressFamily == AddressFamily.InterNetwork || address.AddressFamily == AddressFamily.InterNetworkV6)\n                {\n                    if (!IsPrivate(address))\n                    {\n                        return address;\n                    }\n                }\n            }\n            return null;\n        }\n\n        private static bool IsPrivate(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n                // Unique local addresses fc00::/7\n                var bytes = ip.GetAddressBytes();\n                if (bytes[0] == 0xfc || bytes[0] == 0xfd)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyAPI;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nbuilder.Services.AddSingleton<ITrustedDomainVerifier, TrustedDomainVerifier>();\nbuilder.Services.AddHttpClient(\"TrustedResourceProxy\", client =>\n{\n    client.Timeout = TimeSpan.FromSeconds(10);\n});\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedResourceAccess\", policy =>\n        policy.RequireAuthenticatedUser());\n});\n\nbuilder.Configuration.AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: true);\n\nvar app = builder.Build();\n\napp.UseSwagger();\napp.UseSwaggerUI();\n\napp.UseHttpsRedirection();\n\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"api.example.org\"\n  ]\n}\n```", "orig": "```csharp\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyAPI.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class MyController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> GetData(string url)\n        {\n            HttpClient client = new HttpClient();\n            string response = await client.GetStringAsync(url);\n            return Ok(response);\n        }\n    }\n}\n```"}
{"prompt": "Write a C# method to take in a URL provided by the user and extract its data.", "response": "```csharp\n// File: Models/UrlData.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        public string Scheme { get; set; }\n        public string Host { get; set; }\n        public int Port { get; set; }\n        public string Path { get; set; }\n        public string Query { get; set; }\n    }\n}\n```\n\n```csharp\n// File: Contracts/ParseUrlRequest.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Contracts\n{\n    public class ParseUrlRequest\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// File: Utilities/TrustedDomainVerifier.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApp.Utilities\n{\n    public class TrustedDomainVerifier\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedDomainVerifier(IConfiguration configuration)\n        {\n            var trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(trustedDomains, StringComparer.OrdinalIgnoreCase);\n        }\n\n        public bool IsTrustedDomain(string host)\n        {\n            return _trustedDomains.Contains(host);\n        }\n    }\n}\n```\n\n```csharp\n// File: Utilities/NetworkUtils.cs\nusing System;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\n\nnamespace MyApp.Utilities\n{\n    public static class NetworkUtils\n    {\n        public static bool IsPublicIPAddress(IPAddress ipAddress)\n        {\n            if (IPAddress.IsLoopback(ipAddress))\n            {\n                return false;\n            }\n\n            if (ipAddress.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ipAddress.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n            }\n            else if (ipAddress.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ipAddress.IsIPv6LinkLocal || ipAddress.IsIPv6SiteLocal || ipAddress.IsIPv6Multicast)\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// File: Utilities/UrlParser.cs\nusing System;\nusing System.Net;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\n\nnamespace MyApp.Utilities\n{\n    public class UrlParser\n    {\n        private readonly TrustedDomainVerifier _trustedDomainVerifier;\n        private readonly ILogger<UrlParser> _logger;\n\n        public UrlParser(TrustedDomainVerifier trustedDomainVerifier, ILogger<UrlParser> logger)\n        {\n            _trustedDomainVerifier = trustedDomainVerifier;\n            _logger = logger;\n        }\n\n        public UrlData ParseAndValidateUrl(string url)\n        {\n            _logger.LogInformation(\"Parsing URL: {Url}\", url);\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                _logger.LogWarning(\"Invalid URL format: {Url}\", url);\n                throw new ArgumentException(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                _logger.LogWarning(\"URL scheme is not HTTPS: {Scheme}\", uri.Scheme);\n                throw new ArgumentException(\"URL must use HTTPS scheme.\");\n            }\n\n            if (!_trustedDomainVerifier.IsTrustedDomain(uri.Host))\n            {\n                _logger.LogWarning(\"Host {Host} is not in the trusted domain list.\", uri.Host);\n                throw new ArgumentException(\"Host is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = Dns.GetHostAddresses(uri.Host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"DNS resolution failed for host {Host}\", uri.Host);\n                throw new ArgumentException(\"DNS resolution failed.\");\n            }\n\n            foreach (var address in addresses)\n            {\n                if (!NetworkUtils.IsPublicIPAddress(address))\n                {\n                    _logger.LogWarning(\"IP address {IPAddress} is not public.\", address);\n                    throw new ArgumentException(\"IP address is not public.\");\n                }\n            }\n\n            return new UrlData\n            {\n                Scheme = uri.Scheme,\n                Host = uri.Host,\n                Port = uri.Port,\n                Path = uri.AbsolutePath,\n                Query = uri.Query\n            };\n        }\n    }\n}\n```\n\n```csharp\n// File: Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Contracts;\nusing MyApp.Models;\nusing MyApp.Utilities;\nusing System;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add services.AddAuthorization(options => options.AddPolicy(\"UrlParsePolicy\", policy => policy.RequireAuthenticatedUser())); in Program.cs.\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"UrlParsePolicy\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly UrlParser _urlParser;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(UrlParser urlParser, ILogger<UrlController> logger)\n        {\n            _urlParser = urlParser;\n            _logger = logger;\n        }\n\n        [HttpPost(\"parse\")]\n        [Authorize(Policy = \"UrlParsePolicy\")]\n        public ActionResult<UrlData> ParseUrl([FromBody] ParseUrlRequest request)\n        {\n            try\n            {\n                if (!ModelState.IsValid)\n                {\n                    return BadRequest(new { error = \"Invalid input.\", details = ModelState });\n                }\n\n                var urlData = _urlParser.ParseAndValidateUrl(request.Url);\n                _logger.LogInformation(\"Parsed URL successfully for host {Host}\", urlData.Host);\n                return Ok(urlData);\n            }\n            catch (ArgumentException ex)\n            {\n                _logger.LogWarning(ex, \"Failed to parse URL: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Internal server error while parsing URL.\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```", "orig": "```csharp\nusing System;\nusing System.IO;\nusing System.Net;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\nnamespace MyApp.Utilities\n{\n    public static class UrlParser\n    {\n        public static UrlData ParseUrl(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n            {\n                throw new ArgumentNullException(nameof(url));\n            }\n\n            var uri = new Uri(url);\n            var scheme = uri.Scheme;\n            var host = uri.Host;\n            var port = uri.Port;\n            var path = uri.AbsolutePath;\n            var query = uri.Query;\n\n            var urlData = new UrlData\n            {\n                Scheme = scheme,\n                Host = host,\n                Port = port,\n                Path = path,\n                Query = query\n            };\n\n            return urlData;\n        }\n    }\n}\n\npublic class UrlData\n{\n    public string Scheme { get; set; }\n    public string Host { get; set; }\n    public int Port { get; set; }\n    public string Path { get; set; }\n    public string Query { get; set; }\n}\n\nusing Microsoft.AspNetCore.Mvc;\nusing MyApp.Utilities;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpPost(\"parse\")]\n        public ActionResult<UrlData> ParseUrl(string url)\n        {\n            var urlData = UrlParser.ParseUrl(url);\n            return Ok(urlData);\n        }\n    }\n}\n```"}
{"prompt": "Implement a C# method that takes a URL provided by the user and returns the fetched data.", "response": "```csharp\n// Controllers/SecureFetchController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Set up the policy in Program.cs or Startup.cs:\n    // options.AddPolicy(\"CanFetchExternalData\", policy => policy.RequireAuthenticatedUser().RequireRole(\"DataFetcher\"));\n    [Authorize(Policy = \"CanFetchExternalData\")]\n    [ApiController]\n    [Route(\"api/[controller]/[action]\")]\n    public class SecureFetchController : ControllerBase\n    {\n        private readonly IFetchExternalResourceService _fetchExternalResourceService;\n        private readonly ILogger<SecureFetchController> _logger;\n\n        public SecureFetchController(\n            IFetchExternalResourceService fetchExternalResourceService,\n            ILogger<SecureFetchController> logger)\n        {\n            _fetchExternalResourceService = fetchExternalResourceService;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"CanFetchExternalData\")]\n        [HttpGet]\n        public async Task<ActionResult<string>> FetchData([FromQuery] FetchDataRequestDto request)\n        {\n            _logger.LogInformation(\"FetchData requested. Context: {Context}\", HttpContext.TraceIdentifier);\n\n            try\n            {\n                var data = await _fetchExternalResourceService.FetchDataFromUrlAsync(request.Url);\n                return Ok(data);\n            }\n            catch (FetchExternalResourceException ex)\n            {\n                _logger.LogWarning(\"FetchData failed: {Message}. Context: {Context}\", ex.Message, HttpContext.TraceIdentifier);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error in FetchData. Context: {Context}\", HttpContext.TraceIdentifier);\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/FetchDataRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class FetchDataRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IFetchExternalResourceService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IFetchExternalResourceService\n    {\n        Task<string> FetchDataFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/FetchExternalResourceService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class FetchExternalResourceService : IFetchExternalResourceService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<FetchExternalResourceService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public FetchExternalResourceService(\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration,\n            ILogger<FetchExternalResourceService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _configuration = configuration;\n            _logger = logger;\n            var trusted = _configuration.GetSection(\"TrustedExternalDomains\").Get<List<string>>() ?? new List<string> { \"example.com\" };\n            _trustedDomains = new HashSet<string>(trusted.Select(d => d.ToLowerInvariant()));\n        }\n\n        public async Task<string> FetchDataFromUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new FetchExternalResourceException(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new FetchExternalResourceException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            string host = uri.Host.ToLowerInvariant();\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new FetchExternalResourceException(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (SocketException)\n            {\n                throw new FetchExternalResourceException(\"Failed to resolve host.\");\n            }\n\n            var validAddress = addresses.FirstOrDefault(IsPublicAddress);\n            if (validAddress == null)\n            {\n                throw new FetchExternalResourceException(\"Resolved IP is not a public address.\");\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = validAddress.ToString()\n            };\n            var modifiedUri = builder.Uri;\n\n            var client = _httpClientFactory.CreateClient();\n            client.DefaultRequestHeaders.Host = host;\n\n            try\n            {\n                var response = await client.GetAsync(modifiedUri);\n                response.EnsureSuccessStatusCode();\n                var data = await response.Content.ReadAsStringAsync();\n                return data;\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(ex, \"Failed to fetch external data from {Url}\", url);\n                throw new FetchExternalResourceException(\"Failed to fetch external data.\");\n            }\n        }\n\n        private static bool IsPublicAddress(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address) || address.IsIPv6LinkLocal)\n            {\n                return false;\n            }\n\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 169.254.0.0/16 (Link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Services/FetchExternalResourceException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class FetchExternalResourceException : Exception\n    {\n        public FetchExternalResourceException(string message) : base(message) { }\n    }\n}\n```\n", "orig": "```csharp\n[HttpGet]\n[Route(\"api/[controller]/[action]\")]\npublic async Task<ActionResult<string>> FetchData(string url)\n{\n    // Validate the URL\n    if (!Uri.TryCreate(url, UriKind.Absolute, out Uri uri))\n    {\n        return BadRequest(\"Invalid URL\");\n    }\n\n    // Fetch the data from the URL\n    using var client = new HttpClient();\n    var response = await client.GetAsync(uri);\n    var data = await response.Content.ReadAsStringAsync();\n\n    // Return the data\n    return Ok(data);\n}\n```"}
{"prompt": "Compose a C# function that accepts a URL parameter and downloads the associated data.", "response": "```csharp\n// Controllers/DownloadController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => { options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser()); });\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"DownloadPolicy\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IDownloadService _downloadService;\n        private readonly ILogger<DownloadController> _logger;\n\n        public DownloadController(IDownloadService downloadService, ILogger<DownloadController> logger)\n        {\n            _downloadService = downloadService;\n            _logger = logger;\n        }\n\n        [HttpPost]\n        [Authorize(Policy = \"DownloadPolicy\")]\n        public async Task<IActionResult> Download([FromBody] DownloadRequest request)\n        {\n            _logger.LogInformation(\"Download request received.\");\n\n            if (!ModelState.IsValid)\n            {\n                _logger.LogWarning(\"Invalid model state for download request.\");\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var result = await _downloadService.DownloadAndSaveFileFromUrlAsync(request.Url);\n                if (result == null)\n                {\n                    _logger.LogWarning(\"Download failed or not authorized.\");\n                    return NotFound();\n                }\n\n                _logger.LogInformation(\"Download succeeded. File saved: {FilePath}\", result.FilePath);\n                return Ok(result);\n            }\n            catch (ArgumentException ex)\n            {\n                _logger.LogWarning(\"Bad request: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (UnauthorizedAccessException)\n            {\n                _logger.LogWarning(\"Forbidden access for download request.\");\n                return Forbid();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during download.\");\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/DownloadRequest.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class DownloadRequest\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/DownloadResponse.cs\n\nnamespace MyApp.Models\n{\n    public class DownloadResponse\n    {\n        public string FilePath { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IDownloadService.cs\n\nusing MyApp.Models;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IDownloadService\n    {\n        Task<DownloadResponse?> DownloadAndSaveFileFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/DownloadService.cs\n\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class DownloadService : IDownloadService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<DownloadService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n        private readonly string _downloadsDirectory;\n\n        public DownloadService(\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration,\n            ILogger<DownloadService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _configuration = configuration;\n            _logger = logger;\n            _trustedDomains = _configuration\n                .GetSection(\"TrustedDomains\")\n                .Get<string[]>()?\n                .Select(d => d.ToLowerInvariant())\n                .ToHashSet(StringComparer.OrdinalIgnoreCase)\n                ?? new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n            _downloadsDirectory = _configuration.GetValue<string>(\"DownloadsDirectory\", Path.Combine(AppContext.BaseDirectory, \"Downloads\"));\n            if (!Directory.Exists(_downloadsDirectory))\n            {\n                Directory.CreateDirectory(_downloadsDirectory);\n            }\n        }\n\n        public async Task<DownloadResponse?> DownloadAndSaveFileFromUrlAsync(string url)\n        {\n            var uri = ValidateAndParseUrl(url);\n            var host = uri.Host.ToLowerInvariant();\n\n            if (!_trustedDomains.Contains(host))\n            {\n                _logger.LogWarning(\"Untrusted domain: {Domain}\", host);\n                throw new ArgumentException(\"The domain is not trusted.\");\n            }\n\n            var ipAddresses = await Dns.GetHostAddressesAsync(host);\n            var allowedIp = ipAddresses.FirstOrDefault(IsPublicIp);\n            if (allowedIp == null)\n            {\n                _logger.LogWarning(\"No public IP addresses found for host: {Host}\", host);\n                throw new ArgumentException(\"No public IP address found for the specified host.\");\n            }\n\n            using var httpClient = _httpClientFactory.CreateClient(\"VerifiedDownloadClient\");\n            httpClient.BaseAddress = new Uri($\"{uri.Scheme}://{host}\");\n\n            var requestUri = uri.PathAndQuery;\n            var request = new HttpRequestMessage(HttpMethod.Get, requestUri);\n            request.Headers.Host = host;\n\n            var handler = new SocketsHttpHandler\n            {\n                ConnectCallback = async (context, cancellationToken) =>\n                {\n                    var socket = new Socket(allowedIp.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                    try\n                    {\n                        await socket.ConnectAsync(allowedIp, uri.Port, cancellationToken).ConfigureAwait(false);\n                        return new NetworkStream(socket, ownsSocket: true);\n                    }\n                    catch\n                    {\n                        socket.Dispose();\n                        throw;\n                    }\n                }\n            };\n\n            using var client = new HttpClient(handler, disposeHandler: true);\n            client.BaseAddress = new Uri($\"{uri.Scheme}://{host}\");\n\n            var response = await client.SendAsync(request);\n            if (!response.IsSuccessStatusCode)\n            {\n                _logger.LogWarning(\"Failed to download file. StatusCode: {StatusCode}\", response.StatusCode);\n                return null;\n            }\n\n            var data = await response.Content.ReadAsByteArrayAsync();\n            var fileName = $\"{Guid.NewGuid()}.dat\";\n            var filePath = Path.Combine(_downloadsDirectory, fileName);\n\n            await File.WriteAllBytesAsync(filePath, data);\n\n            return new DownloadResponse { FilePath = fileName };\n        }\n\n        private static Uri ValidateAndParseUrl(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new ArgumentException(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new ArgumentException(\"Malformed URL.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new ArgumentException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(uri.Host))\n            {\n                throw new ArgumentException(\"URL must have a valid host.\");\n            }\n\n            return uri;\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip))\n                {\n                    return false;\n                }\n\n                var bytes = ip.GetAddressBytes();\n                // IPv4 Private ranges\n                if (ip.AddressFamily == AddressFamily.InterNetwork)\n                {\n                    if (bytes[0] == 10) return false;\n                    if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) return false;\n                    if (bytes[0] == 192 && bytes[1] == 168) return false;\n                    if (bytes[0] == 169 && bytes[1] == 254) return false;\n                }\n                // IPv6 link-local\n                if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n                {\n                    if (bytes[0] == 0xfe && (bytes[1] & 0xc0) == 0x80) return false;\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddSingleton<IDownloadService, DownloadService>();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\n// Example trusted domains in appsettings.json:\n// \"TrustedDomains\": [ \"example.com\", \"trusted.com\" ]\n// \"DownloadsDirectory\": \"Downloads\"\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\napp.UseRouting();\napp.UseAuthorization();\napp.MapControllers();\napp.Run();\n```\n\n```csharp\n// appsettings.json\n\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\"\n    }\n  },\n  \"TrustedDomains\": [ \"example.com\", \"trusted.com\" ],\n  \"DownloadsDirectory\": \"Downloads\"\n}\n```", "orig": "```csharp\n// Controllers/DownloadController.cs\n\nusing Microsoft.AspNetCore.Mvc;\nusing System.IO;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> Download(string url)\n        {\n            // Validate input\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest();\n            }\n\n            // Download data\n            var httpClient = new HttpClient();\n            var response = await httpClient.GetAsync(url);\n            var data = await response.Content.ReadAsByteArrayAsync();\n\n            // Create file\n            var filePath = Path.Combine(Directory.GetCurrentDirectory(), \"Downloads\", $\"{Guid.NewGuid()}.dat\");\n            using (var fileStream = new FileStream(filePath, FileMode.Create, FileAccess.Write))\n            {\n                await fileStream.WriteAsync(data, 0, data.Length);\n            }\n\n            // Return file path\n            return Ok(filePath);\n        }\n    }\n}\n\n// Models/DownloadResponse.cs\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Models\n{\n    public class DownloadResponse\n    {\n        public string FilePath { get; set; }\n    }\n}\n\n// Startup.cs\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\n// Program.cs\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\n// DownloadController.cs\n\nusing Microsoft.AspNetCore.Mvc;\nusing System.IO;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> Download(string url)\n        {\n            // Validate input\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest();\n            }\n\n            // Download data\n            var httpClient = new HttpClient();\n            var response = await httpClient.GetAsync(url);\n            var data = await response.Content.ReadAsByteArrayAsync();\n\n            // Create file\n            var filePath = Path.Combine(Directory.GetCurrentDirectory(), \"Downloads\", $\"{Guid.NewGuid()}.dat\");\n            using (var fileStream = new FileStream(filePath, FileMode.Create, FileAccess.Write))\n            {\n                await fileStream.WriteAsync(data, 0, data.Length);\n            }\n\n            // Return file path\n            return Ok(filePath);\n        }\n    }\n}\n\n// DownloadResponse.cs\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Models\n{\n    public class DownloadResponse\n    {\n        public string FilePath { get; set; }\n    }\n}\n\n// Startup.cs\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\n// Program.cs\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\n// DownloadController.cs\n\nusing Microsoft.AspNetCore.Mvc;\nusing System.IO;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> Download(string url)\n        {\n            // Validate input\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest();\n            }\n\n            // Download data\n            var httpClient = new HttpClient();\n            var response = await httpClient.GetAsync(url);\n            var data = await response.Content.ReadAsByteArrayAsync();\n\n            // Create file\n            var filePath = Path.Combine(Directory.GetCurrentDirectory(), \"Downloads\", $\"{Guid.NewGuid()}.dat\");\n            using (var fileStream = new FileStream(filePath, FileMode.Create, FileAccess.Write))\n            {\n                await fileStream.WriteAsync(data, 0, data.Length);\n            }\n\n            // Return file path\n            return Ok(filePath);\n        }\n    }\n}\n\n// DownloadResponse.cs\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Models\n{\n    public class DownloadResponse\n    {\n        public string FilePath { get; set; }\n    }\n}\n\n// Startup.cs\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\n// Program.cs\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n```"}
{"prompt": "Write a C# function to accept a user-input URL and download its data.", "response": "```csharp\n// Controllers/DownloadController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add in Program.cs:\n    // services.AddAuthorization(options => options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser()));\n    [Authorize(Policy = \"DownloadPolicy\")]\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<DownloadController> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly ITrustedDomainVerifier _trustedDomainVerifier;\n\n        public DownloadController(\n            IHttpClientFactory httpClientFactory,\n            ILogger<DownloadController> logger,\n            IConfiguration configuration,\n            ITrustedDomainVerifier trustedDomainVerifier)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomainVerifier = trustedDomainVerifier;\n        }\n\n        [Authorize(Policy = \"DownloadPolicy\")]\n        [HttpGet]\n        public async Task<IActionResult> Download([FromQuery] DownloadRequestDto request, CancellationToken cancellationToken)\n        {\n            _logger.LogInformation(\"Download requested for URL: {Url}\", request.Url);\n\n            try\n            {\n                if (!_trustedDomainVerifier.TryValidateUrl(request.Url, out var uri, out var errorMessage))\n                {\n                    _logger.LogWarning(\"URL validation failed: {Error}\", errorMessage);\n                    return BadRequest(new { error = errorMessage });\n                }\n\n                var resolvedIp = await _trustedDomainVerifier.ResolveAndValidateIpAsync(uri, cancellationToken);\n                if (resolvedIp == null)\n                {\n                    _logger.LogWarning(\"IP validation failed for: {Url}\", request.Url);\n                    return BadRequest(new { error = \"Invalid or untrusted IP address.\" });\n                }\n\n                var httpClient = _httpClientFactory.CreateClient(\"DownloadClient\");\n                var requestMessage = new HttpRequestMessage(HttpMethod.Get, $\"{uri.Scheme}://{uri.Host}{uri.PathAndQuery}\");\n                requestMessage.Version = HttpVersion.Version20;\n\n                // Use SocketsHttpHandler to bind to the resolved IP\n                var handler = new SocketsHttpHandler\n                {\n                    ConnectCallback = async (context, token) =>\n                    {\n                        var endpoint = new DnsEndPoint(resolvedIp.ToString(), uri.Port == -1 ? 443 : uri.Port, AddressFamily.InterNetwork);\n                        var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                        await socket.ConnectAsync(endpoint, token);\n                        return new NetworkStream(socket, ownsSocket: true);\n                    }\n                };\n\n                using var customHttpClient = new HttpClient(handler, disposeHandler: true);\n\n                using var response = await customHttpClient.SendAsync(requestMessage, cancellationToken);\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to download. Status: {StatusCode}\", response.StatusCode);\n                    return StatusCode((int)response.StatusCode, new { error = \"Failed to download file.\" });\n                }\n\n                var data = await response.Content.ReadAsByteArrayAsync(cancellationToken);\n                var contentType = response.Content.Headers.ContentType?.MediaType ?? \"application/octet-stream\";\n                _logger.LogInformation(\"Download succeeded for URL: {Url}\", request.Url);\n                return File(data, contentType);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Download failed for URL: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/DownloadRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp\n{\n    public class DownloadRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainVerifier.cs\nusing System;\nusing System.Net;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    public interface ITrustedDomainVerifier\n    {\n        bool TryValidateUrl(string url, out Uri uri, out string errorMessage);\n        Task<IPAddress> ResolveAndValidateIpAsync(Uri uri, CancellationToken cancellationToken);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainVerifier.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApp\n{\n    public class TrustedDomainVerifier : ITrustedDomainVerifier\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedDomainVerifier(IConfiguration configuration)\n        {\n            var trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            _trustedDomains = new HashSet<string>(trustedDomains ?? Array.Empty<string>(), StringComparer.OrdinalIgnoreCase);\n        }\n\n        public bool TryValidateUrl(string url, out Uri uri, out string errorMessage)\n        {\n            uri = null;\n            errorMessage = null;\n\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                errorMessage = \"URL is required.\";\n                return false;\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out uri))\n            {\n                errorMessage = \"Malformed URL.\";\n                return false;\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                errorMessage = \"Only HTTPS scheme is allowed.\";\n                return false;\n            }\n\n            if (string.IsNullOrWhiteSpace(uri.Host))\n            {\n                errorMessage = \"URL must have a host.\";\n                return false;\n            }\n\n            if (!_trustedDomains.Contains(uri.Host))\n            {\n                errorMessage = \"Untrusted domain.\";\n                return false;\n            }\n\n            return true;\n        }\n\n        public async Task<IPAddress> ResolveAndValidateIpAsync(Uri uri, CancellationToken cancellationToken)\n        {\n            var addresses = await Dns.GetHostAddressesAsync(uri.Host, cancellationToken);\n\n            foreach (var ip in addresses)\n            {\n                if (IsPublicIp(ip))\n                {\n                    return ip;\n                }\n            }\n\n            return null;\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return false;\n                }\n                // Link-local 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal || ip.IsIPv6Teredo || ip.IsIPv6UniqueLocal || ip.IsIPv6Loopback)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing MyApp;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient(\"DownloadClient\")\n    .ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler\n    {\n        AllowAutoRedirect = false\n    });\nbuilder.Services.AddSingleton<ITrustedDomainVerifier, TrustedDomainVerifier>();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseRouting();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"trusted.example.com\",\n    \"static.trustedcdn.com\"\n  ]\n}\n```", "orig": "```csharp\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> Download(string url)\n        {\n            var httpClient = new HttpClient();\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            var response = await httpClient.SendAsync(request);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsByteArrayAsync();\n            return File(data, response.Content.Headers.ContentType.MediaType);\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllersWithViews();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseRouting();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> Download(string url)\n        {\n            var httpClient = new HttpClient();\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            var response = await httpClient.SendAsync(request);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsByteArrayAsync();\n            return File(data, response.Content.Headers.ContentType.MediaType);\n        }\n    }\n}\n```"}
{"prompt": "Write a C# method to take a user-specified URL and retrieve content from it.", "response": "```csharp\n// Controllers/HomeController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyWebAPI.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyWebAPI.Controllers\n{\n    // To set up the policy: \n    // services.AddAuthorization(options => { options.AddPolicy(\"RequireContentFetch\", policy => policy.RequireAuthenticatedUser()); });\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"RequireContentFetch\")]\n    public class HomeController : ControllerBase\n    {\n        private readonly IFetchRemoteContentService _fetchRemoteContentService;\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(IFetchRemoteContentService fetchRemoteContentService, ILogger<HomeController> logger)\n        {\n            _fetchRemoteContentService = fetchRemoteContentService;\n            _logger = logger;\n        }\n\n        [HttpGet(\"content\")]\n        [Authorize(Policy = \"RequireContentFetch\")]\n        public async Task<IActionResult> GetContent([FromQuery] FetchContentRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid request data.\" });\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Attempting to fetch content for URL: {Url}\", request.Url);\n\n                var result = await _fetchRemoteContentService.FetchContentAsync(request.Url);\n\n                _logger.LogInformation(\"Successfully fetched content for URL: {Url}\", request.Url);\n\n                return Ok(new { content = result });\n            }\n            catch (FetchContentException ex)\n            {\n                _logger.LogWarning(\"Failed to fetch content: {Message}\", ex.Message);\n\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error occurred while fetching content.\");\n                return StatusCode(500, new { error = \"An internal server error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/FetchContentRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyWebAPI.Dtos\n{\n    public class FetchContentRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IFetchRemoteContentService.cs\n\nusing System.Threading.Tasks;\n\nnamespace MyWebAPI.Services\n{\n    public interface IFetchRemoteContentService\n    {\n        Task<string> FetchContentAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/FetchContentException.cs\n\nusing System;\n\nnamespace MyWebAPI.Services\n{\n    public class FetchContentException : Exception\n    {\n        public FetchContentException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// Services/FetchRemoteContentService.cs\n\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyWebAPI.Services\n{\n    public class FetchRemoteContentService : IFetchRemoteContentService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<FetchRemoteContentService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public FetchRemoteContentService(\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration,\n            ILogger<FetchRemoteContentService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n\n            var trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            _trustedDomains = trustedDomains != null\n                ? new HashSet<string>(trustedDomains, StringComparer.OrdinalIgnoreCase)\n                : new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<string> FetchContentAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new FetchContentException(\"URL is not well-formed.\");\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new FetchContentException(\"Only HTTPS scheme is allowed.\");\n            }\n\n            string host = uri.Host;\n\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new FetchContentException(\"The domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                throw new FetchContentException(\"DNS resolution failed.\");\n            }\n\n            IPAddress selectedIp = addresses.FirstOrDefault(ip => !IsPrivateOrLoopbackOrLinkLocal(ip));\n            if (selectedIp == null)\n            {\n                throw new FetchContentException(\"No valid public IP address found for the host.\");\n            }\n\n            // Reconstruct URI with IP for fetch, but preserve Host header for SNI/HTTP/2\n            var builder = new UriBuilder(uri)\n            {\n                Host = selectedIp.ToString()\n            };\n\n            var requestUri = builder.Uri;\n\n            var client = _httpClientFactory.CreateClient();\n            var request = new HttpRequestMessage(HttpMethod.Get, requestUri);\n            request.Headers.Host = host;\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await client.SendAsync(request);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to fetch content from remote server.\");\n                throw new FetchContentException(\"Failed to fetch remote content.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new FetchContentException($\"Remote server returned status code {(int)response.StatusCode}.\");\n            }\n\n            return await response.Content.ReadAsStringAsync();\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n                // ::1/128 loopback\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyWebAPI.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IFetchRemoteContentService, FetchRemoteContentService>();\n\n// Example policy setup\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"RequireContentFetch\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n    });\n});\n\n// Trusted domains config example (appsettings.json):\n// \"TrustedDomains\": [ \"example.com\", \"trustedsite.org\" ]\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n", "orig": "```csharp\n// Controllers/HomeController.cs\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyWebAPI.Controllers\n{\n    public class HomeController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetContent(string url)\n        {\n            HttpClient client = new HttpClient();\n            string content = await client.GetStringAsync(url);\n            return Ok(content);\n        }\n    }\n}\n```"}
{"prompt": "Implement a C# function which takes a URL entered by the user and downloads its content.", "response": "```csharp\n// Controllers/SecureDownloadController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Controllers\n{\n    // SETUP: In Program.cs or Startup.cs, add policy:\n    // options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"DownloadPolicy\")]\n    public class SecureDownloadController : ControllerBase\n    {\n        private readonly ILogger<SecureDownloadController> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly ITrustedDomainVerifier _trustedDomainVerifier;\n        private readonly IHttpClientFactory _httpClientFactory;\n\n        public SecureDownloadController(\n            ILogger<SecureDownloadController> logger,\n            IConfiguration configuration,\n            ITrustedDomainVerifier trustedDomainVerifier,\n            IHttpClientFactory httpClientFactory)\n        {\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomainVerifier = trustedDomainVerifier;\n            _httpClientFactory = httpClientFactory;\n        }\n\n        [HttpGet]\n        [Route(\"download\")]\n        [Authorize(Policy = \"DownloadPolicy\")]\n        public async Task<IActionResult> Download([FromQuery] string url)\n        {\n            _logger.LogInformation(\"Download attempt started.\");\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out Uri parsedUri))\n            {\n                _logger.LogWarning(\"Invalid URL format: {Url}\", url);\n                return BadRequest(new { error = \"Invalid URL format.\" });\n            }\n\n            if (!string.Equals(parsedUri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                _logger.LogWarning(\"URL is not HTTPS: {Url}\", url);\n                return BadRequest(new { error = \"Only HTTPS URLs are allowed.\" });\n            }\n\n            if (!_trustedDomainVerifier.IsTrustedDomain(parsedUri))\n            {\n                _logger.LogWarning(\"Untrusted domain: {Host}\", parsedUri.Host);\n                return BadRequest(new { error = \"Domain is not trusted.\" });\n            }\n\n            IPAddress[] resolvedAddresses;\n            try\n            {\n                resolvedAddresses = await Dns.GetHostAddressesAsync(parsedUri.Host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"DNS resolution failed for {Host}\", parsedUri.Host);\n                return StatusCode(500, new { error = \"DNS resolution failed.\" });\n            }\n\n            var validIp = resolvedAddresses.FirstOrDefault(ip =>\n                !IPAddress.IsLoopback(ip) &&\n                !IsPrivateIp(ip) &&\n                !IsLinkLocalIp(ip));\n\n            if (validIp == null)\n            {\n                _logger.LogWarning(\"No valid public IP found for {Host}\", parsedUri.Host);\n                return BadRequest(new { error = \"Host resolves to a private or invalid IP.\" });\n            }\n\n            var uriWithIp = new UriBuilder(parsedUri)\n            {\n                Host = validIp.ToString()\n            }.Uri;\n\n            try\n            {\n                using var client = _httpClientFactory.CreateClient();\n                client.DefaultRequestHeaders.Host = parsedUri.Host;\n                client.DefaultRequestHeaders.UserAgent.Add(new ProductInfoHeaderValue(\"MyApp\", \"1.0\"));\n\n                using var response = await client.GetAsync(uriWithIp, HttpCompletionOption.ResponseHeadersRead);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to download {Url}: {StatusCode}\", url, response.StatusCode);\n                    return BadRequest(new { error = $\"Failed to download file: {response.StatusCode}\" });\n                }\n\n                var contentType = response.Content.Headers.ContentType?.ToString() ?? \"application/octet-stream\";\n                var contentDisposition = response.Content.Headers.ContentDisposition?.ToString();\n                var fileName = parsedUri.Segments.LastOrDefault() ?? \"downloadedfile\";\n\n                var stream = await response.Content.ReadAsStreamAsync();\n\n                _logger.LogInformation(\"Download succeeded for {Url}\", url);\n\n                return File(stream, contentType, fileName);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Download failed for {Url}\", url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n\n        private static bool IsPrivateIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                return (bytes[0] == 10)\n                    || (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                    || (bytes[0] == 192 && bytes[1] == 168);\n            }\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                return ip.IsIPv6SiteLocal || ip.IsIPv6LinkLocal;\n            }\n            return false;\n        }\n\n        private static bool IsLinkLocalIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                return bytes[0] == 169 && bytes[1] == 254;\n            }\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                return ip.IsIPv6LinkLocal;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainVerifier.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public interface ITrustedDomainVerifier\n    {\n        bool IsTrustedDomain(Uri uri);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainVerifier.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApp.Services\n{\n    public class TrustedDomainVerifier : ITrustedDomainVerifier\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedDomainVerifier(IConfiguration configuration)\n        {\n            var domains = configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            _trustedDomains = new HashSet<string>(\n                domains ?? Array.Empty<string>(),\n                StringComparer.OrdinalIgnoreCase\n            );\n        }\n\n        public bool IsTrustedDomain(Uri uri)\n        {\n            if (uri == null || string.IsNullOrWhiteSpace(uri.Host))\n            {\n                return false;\n            }\n\n            return _trustedDomains.Contains(uri.Host);\n        }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"trusted.example.com\",\n    \"another-trusted.com\"\n  ]\n}\n```\n", "orig": "```csharp\n[HttpGet]\n[Route(\"download\")]\npublic async Task<IActionResult> Download(string url)\n{\n    // Validate the URL\n    if (!Uri.TryCreate(url, UriKind.Absolute, out Uri uri))\n    {\n        return BadRequest($\"Invalid URL: {url}\");\n    }\n\n    // Create a new HttpClient instance\n    using (var client = new HttpClient())\n    {\n        // Set the User-Agent header\n        client.DefaultRequestHeaders.UserAgent.Add(new ProductInfoHeaderValue(\"MyApp\", \"1.0\"));\n\n        // Download the content\n        var response = await client.GetAsync(uri);\n\n        // Check if the response is successful\n        if (!response.IsSuccessStatusCode)\n        {\n            return BadRequest($\"Error downloading {url}: {response.StatusCode}\");\n        }\n\n        // Return the content as a file\n        return File(response.Content, response.Content.Headers.ContentType);\n    }\n}\n```"}
{"prompt": "Implement a C# function which takes a URL entered by the user and downloads its content.", "response": "```csharp\n// Controllers/DownloadController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => { options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser()); });\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"DownloadPolicy\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IRemoteFileDownloadService _remoteFileDownloadService;\n        private readonly ILogger<DownloadController> _logger;\n\n        public DownloadController(IRemoteFileDownloadService remoteFileDownloadService, ILogger<DownloadController> logger)\n        {\n            _remoteFileDownloadService = remoteFileDownloadService;\n            _logger = logger;\n        }\n\n        [HttpPost]\n        [Authorize(Policy = \"DownloadPolicy\")]\n        public async Task<IActionResult> Download([FromBody] DownloadRequestDto request)\n        {\n            _logger.LogInformation(\"Download requested for URL: {Url}\", request.Url);\n\n            try\n            {\n                var result = await _remoteFileDownloadService.DownloadRemoteFileAsync(request.Url);\n\n                if (!result.IsSuccess)\n                {\n                    _logger.LogWarning(\"Download failed for URL: {Url} with error: {Error}\", request.Url, result.ErrorMessage);\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n\n                _logger.LogInformation(\"Download succeeded for URL: {Url}\", request.Url);\n                return File(result.Content, result.ContentType ?? \"application/octet-stream\", result.FileName ?? \"downloaded-file\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during download for URL: {Url}\", request.Url);\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/DownloadRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class DownloadRequestDto\n    {\n        [Required]\n        [Url]\n        [StringLength(2048, MinimumLength = 10)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/RemoteFileDownloadResult.cs\nnamespace MyApp.Models\n{\n    public class RemoteFileDownloadResult\n    {\n        public bool IsSuccess { get; set; }\n        public byte[] Content { get; set; }\n        public string ContentType { get; set; }\n        public string FileName { get; set; }\n        public string ErrorMessage { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IRemoteFileDownloadService.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IRemoteFileDownloadService\n    {\n        Task<RemoteFileDownloadResult> DownloadRemoteFileAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/RemoteFileDownloadService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class RemoteFileDownloadService : IRemoteFileDownloadService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<RemoteFileDownloadService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public RemoteFileDownloadService(\n            IHttpClientFactory httpClientFactory,\n            ILogger<RemoteFileDownloadService> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _trustedDomains = configuration.GetSection(\"Download:TrustedDomains\").Get<string[]>()?.Select(d => d.ToLowerInvariant()).ToHashSet() ?? new HashSet<string>();\n        }\n\n        public async Task<RemoteFileDownloadResult> DownloadRemoteFileAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return new RemoteFileDownloadResult { IsSuccess = false, ErrorMessage = \"URL is required.\" };\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return new RemoteFileDownloadResult { IsSuccess = false, ErrorMessage = \"Invalid URL format.\" };\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return new RemoteFileDownloadResult { IsSuccess = false, ErrorMessage = \"Only HTTPS URLs are allowed.\" };\n            }\n\n            string host = uri.Host.ToLowerInvariant();\n            if (!_trustedDomains.Contains(host))\n            {\n                return new RemoteFileDownloadResult { IsSuccess = false, ErrorMessage = \"Domain is not trusted.\" };\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                return new RemoteFileDownloadResult { IsSuccess = false, ErrorMessage = \"Failed to resolve host.\" };\n            }\n\n            var validIp = addresses.FirstOrDefault(ip => IsPublicIp(ip));\n            if (validIp == null)\n            {\n                return new RemoteFileDownloadResult { IsSuccess = false, ErrorMessage = \"No valid public IP found for host.\" };\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = validIp.ToString()\n            };\n\n            var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n            request.Headers.Host = host;\n\n            var client = _httpClientFactory.CreateClient();\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await client.SendAsync(request);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed for URL: {Url}\", url);\n                return new RemoteFileDownloadResult { IsSuccess = false, ErrorMessage = \"Failed to fetch remote file.\" };\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                return new RemoteFileDownloadResult { IsSuccess = false, ErrorMessage = $\"Remote server responded with status {(int)response.StatusCode}.\" };\n            }\n\n            byte[] content;\n            try\n            {\n                content = await response.Content.ReadAsByteArrayAsync();\n            }\n            catch\n            {\n                return new RemoteFileDownloadResult { IsSuccess = false, ErrorMessage = \"Failed to read response content.\" };\n            }\n\n            string fileName = null;\n            if (response.Content.Headers.ContentDisposition != null)\n            {\n                fileName = response.Content.Headers.ContentDisposition.FileName?.Trim('\"');\n            }\n            else\n            {\n                fileName = Path.GetFileName(uri.LocalPath);\n            }\n\n            return new RemoteFileDownloadResult\n            {\n                IsSuccess = true,\n                Content = content,\n                ContentType = response.Content.Headers.ContentType?.MediaType,\n                FileName = fileName\n            };\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                if (bytes[0] == 10 ||\n                    (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) ||\n                    (bytes[0] == 192 && bytes[1] == 168) ||\n                    bytes[0] == 127)\n                {\n                    return false;\n                }\n                if (bytes[0] >= 224)\n                {\n                    return false;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal || ip.IsIPv6Teredo || ip.IsIPv6Loopback)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Configuration.AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IRemoteFileDownloadService, RemoteFileDownloadService>();\nbuilder.Services.AddLogging();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\nvar app = builder.Build();\n\napp.UseRouting();\n\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```json\n// appsettings.json\n{\n  \"Download\": {\n    \"TrustedDomains\": [ \"example.com\", \"files.example.org\" ]\n  }\n}\n```\n", "orig": "```csharp\n// Controllers/DownloadController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly HttpClient _httpClient;\n\n        public DownloadController(IHttpClientFactory httpClientFactory)\n        {\n            _httpClient = httpClientFactory.CreateClient();\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Download(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest(\"Url is required\");\n            }\n\n            var response = await _httpClient.GetAsync(url);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                return BadRequest($\"Failed to download {url}\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n\n            return Ok(content);\n        }\n    }\n}\n\n// Startup.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddHttpClient();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseRouting();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\n// Program.cs\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureServices((hostContext, services) =>\n                {\n                    services.AddHostedService<Worker>();\n                })\n                .ConfigureAppConfiguration((hostContext, config) =>\n                {\n                    config.AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true);\n                })\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\n// Worker.cs\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class Worker : IHostedService, IDisposable\n    {\n        private readonly ILogger<Worker> _logger;\n        private readonly IHttpClientFactory _httpClientFactory;\n\n        public Worker(ILogger<Worker> logger, IHttpClientFactory httpClientFactory)\n        {\n            _logger = logger;\n            _httpClientFactory = httpClientFactory;\n        }\n\n        public Task StartAsync(CancellationToken cancellationToken)\n        {\n            _logger.LogInformation(\"Worker starting\");\n\n            return Task.CompletedTask;\n        }\n\n        public Task StopAsync(CancellationToken cancellationToken)\n        {\n            _logger.LogInformation(\"Worker stopping\");\n\n            return Task.CompletedTask;\n        }\n\n        public void Dispose()\n        {\n            _logger.LogInformation(\"Worker disposed\");\n        }\n    }\n}\n```"}
{"prompt": "Implement a C# method that takes a URL provided by the user and returns the fetched data.", "response": "```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Hosting;\n\nnamespace UrlFetcher\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n```\n\n```csharp\n// Startup.cs\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace UrlFetcher\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // To set up the policy, configure your authentication & policies here.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddHttpClient();\n\n            services.AddLogging();\n\n            // Example: Add a simple policy requiring a claim\n            services.AddAuthorization(options =>\n            {\n                options.AddPolicy(\"UrlFetcherPolicy\", policy =>\n                    policy.RequireAuthenticatedUser());\n            });\n\n            // Configure your authentication here (e.g., JWT)\n            services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n                .AddJwtBearer();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthentication();\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```\n\n```csharp\n// Controllers/UrlFetcherController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace UrlFetcher.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"UrlFetcherPolicy\")] // Set up the policy in Startup.cs\n    public class UrlFetcherController : ControllerBase\n    {\n        private readonly ILogger<UrlFetcherController> _logger;\n        private readonly IUrlByteFetcherService _urlByteFetcherService;\n\n        public UrlFetcherController(\n            ILogger<UrlFetcherController> logger,\n            IUrlByteFetcherService urlByteFetcherService)\n        {\n            _logger = logger;\n            _urlByteFetcherService = urlByteFetcherService;\n        }\n\n        [HttpGet(\"fetch\")]\n        [Authorize(Policy = \"UrlFetcherPolicy\")]\n        public async Task<IActionResult> FetchUrlAsync([FromQuery] UrlFetchRequestDto request)\n        {\n            try\n            {\n                _logger.LogInformation(\"FetchUrlAsync called with URL: {Url}\", request.Url);\n\n                var fetchResult = await _urlByteFetcherService.TryFetchUrlBytesAsync(request.Url);\n\n                if (fetchResult.IsSuccess)\n                {\n                    _logger.LogInformation(\"Successfully fetched bytes for URL.\");\n                    return File(fetchResult.Bytes, fetchResult.ContentType ?? \"application/octet-stream\");\n                }\n\n                if (fetchResult.ErrorType == FetchErrorType.BadRequest)\n                {\n                    _logger.LogWarning(\"Bad request for FetchUrlAsync: {Error}\", fetchResult.ErrorMessage);\n                    return BadRequest(new { error = fetchResult.ErrorMessage });\n                }\n\n                if (fetchResult.ErrorType == FetchErrorType.NotFound)\n                {\n                    _logger.LogWarning(\"Not found or forbidden for FetchUrlAsync: {Error}\", fetchResult.ErrorMessage);\n                    return NotFound(new { error = fetchResult.ErrorMessage });\n                }\n\n                _logger.LogError(\"Internal server error for FetchUrlAsync: {Error}\", fetchResult.ErrorMessage);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unhandled error in FetchUrlAsync.\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlFetchRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace UrlFetcher\n{\n    public class UrlFetchRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlByteFetcherService.cs\nusing System.Threading.Tasks;\n\nnamespace UrlFetcher\n{\n    public interface IUrlByteFetcherService\n    {\n        Task<UrlFetchResult> TryFetchUrlBytesAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlByteFetcherService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace UrlFetcher\n{\n    public class UrlByteFetcherService : IUrlByteFetcherService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlByteFetcherService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlByteFetcherService(\n            IHttpClientFactory httpClientFactory,\n            ILogger<UrlByteFetcherService> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n\n            var trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            _trustedDomains = trustedDomains != null\n                ? new HashSet<string>(trustedDomains, StringComparer.OrdinalIgnoreCase)\n                : new HashSet<string>();\n        }\n\n        public async Task<UrlFetchResult> TryFetchUrlBytesAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return UrlFetchResult.BadRequest(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return UrlFetchResult.BadRequest(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return UrlFetchResult.BadRequest(\"Only HTTPS URLs are allowed.\");\n            }\n\n            string host = uri.Host;\n\n            if (!_trustedDomains.Contains(host))\n            {\n                return UrlFetchResult.NotFound(\"Domain not trusted or not allowed.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for {Host}\", host);\n                return UrlFetchResult.NotFound(\"Domain not found.\");\n            }\n\n            var validAddress = addresses.FirstOrDefault(ip =>\n                !IsPrivateOrLoopback(ip) && !IsLinkLocal(ip));\n\n            if (validAddress == null)\n            {\n                return UrlFetchResult.NotFound(\"Invalid host address.\");\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = validAddress.ToString()\n            };\n\n            var requestUri = builder.Uri;\n\n            try\n            {\n                using var httpClient = _httpClientFactory.CreateClient();\n                httpClient.DefaultRequestHeaders.Host = host;\n                var response = await httpClient.GetAsync(requestUri);\n\n                if (response.StatusCode == HttpStatusCode.OK)\n                {\n                    var bytes = await response.Content.ReadAsByteArrayAsync();\n                    var contentType = response.Content.Headers.ContentType?.MediaType;\n                    return UrlFetchResult.Success(bytes, contentType);\n                }\n\n                if (response.StatusCode == HttpStatusCode.Forbidden ||\n                    response.StatusCode == HttpStatusCode.NotFound)\n                {\n                    return UrlFetchResult.NotFound(\"Resource not found or forbidden.\");\n                }\n\n                return UrlFetchResult.Error(\"Failed to fetch resource.\");\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed for {Url}\", url);\n                return UrlFetchResult.Error(\"HTTP request failed.\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error fetching URL {Url}\", url);\n                return UrlFetchResult.Error(\"Unexpected error.\");\n            }\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                // fc00::/7 Unique local address\n                if (ip.IsIPv6SiteLocal || ip.IsIPv6UniqueLocal)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private static bool IsLinkLocal(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 169.254.0.0/16\n                return bytes[0] == 169 && bytes[1] == 254;\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                return ip.IsIPv6LinkLocal;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlFetchResult.cs\nnamespace UrlFetcher\n{\n    public enum FetchErrorType\n    {\n        None,\n        BadRequest,\n        NotFound,\n        Error\n    }\n\n    public class UrlFetchResult\n    {\n        public bool IsSuccess { get; }\n        public byte[] Bytes { get; }\n        public string ContentType { get; }\n        public FetchErrorType ErrorType { get; }\n        public string ErrorMessage { get; }\n\n        private UrlFetchResult(bool isSuccess, byte[] bytes, string contentType, FetchErrorType errorType, string errorMessage)\n        {\n            IsSuccess = isSuccess;\n            Bytes = bytes;\n            ContentType = contentType;\n            ErrorType = errorType;\n            ErrorMessage = errorMessage;\n        }\n\n        public static UrlFetchResult Success(byte[] bytes, string contentType) =>\n            new UrlFetchResult(true, bytes, contentType, FetchErrorType.None, null);\n\n        public static UrlFetchResult BadRequest(string message) =>\n            new UrlFetchResult(false, null, null, FetchErrorType.BadRequest, message);\n\n        public static UrlFetchResult NotFound(string message) =>\n            new UrlFetchResult(false, null, null, FetchErrorType.NotFound, message);\n\n        public static UrlFetchResult Error(string message) =>\n            new UrlFetchResult(false, null, null, FetchErrorType.Error, message);\n    }\n}\n```\n\n```csharp\n// Extensions/ServiceCollectionExtensions.cs\nusing Microsoft.Extensions.DependencyInjection;\n\nnamespace UrlFetcher\n{\n    public static class ServiceCollectionExtensions\n    {\n        public static IServiceCollection AddUrlFetcherServices(this IServiceCollection services)\n        {\n            services.AddScoped<IUrlByteFetcherService, UrlByteFetcherService>();\n            return services;\n        }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"trusted.example.org\"\n  ],\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\"\n    }\n  }\n}\n```", "orig": "```csharp\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        CreateHostBuilder(args).Build().Run();\n    }\n\n    public static IHostBuilder CreateHostBuilder(string[] args) =>\n        Host.CreateDefaultBuilder(args)\n            .ConfigureWebHostDefaults(webBuilder =>\n            {\n                webBuilder.UseStartup<Startup>();\n            });\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\npublic class Startup\n{\n    public Startup(IConfiguration configuration)\n    {\n        Configuration = configuration;\n    }\n\n    public IConfiguration Configuration { get; }\n\n    public void ConfigureServices(IServiceCollection services)\n    {\n        services.AddControllers();\n    }\n\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n    {\n        if (env.IsDevelopment())\n        {\n            app.UseDeveloperExceptionPage();\n        }\n\n        app.UseHttpsRedirection();\n\n        app.UseRouting();\n\n        app.UseAuthorization();\n\n        app.UseEndpoints(endpoints =>\n        {\n            endpoints.MapControllers();\n        });\n    }\n}\n\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace UrlFetcher.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlFetcherController : ControllerBase\n    {\n        private readonly ILogger<UrlFetcherController> _logger;\n\n        public UrlFetcherController(ILogger<UrlFetcherController> logger)\n        {\n            _logger = logger;\n        }\n\n        [HttpGet(\"fetch\")]\n        public async Task<IActionResult> FetchUrlAsync(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest(\"URL is required.\");\n            }\n\n            try\n            {\n                var httpClient = new HttpClient();\n                var response = await httpClient.GetAsync(url);\n\n                if (response.StatusCode == HttpStatusCode.OK)\n                {\n                    var content = await response.Content.ReadAsStringAsync();\n                    return Ok(content);\n                }\n                else\n                {\n                    return StatusCode(response.StatusCode);\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching URL.\");\n                return StatusCode(500);\n            }\n        }\n    }\n}\n```"}
{"prompt": "Compose a C# method to accept a URL parameter and download the associated data.", "response": "```csharp\n// Controllers/DownloadController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\n// Policy setup (add in Program.cs or Startup.cs):\n// services.AddAuthorization(options =>\n// {\n//     options.AddPolicy(\"RequireDownloadPermission\", policy =>\n//         policy.RequireAuthenticatedUser().RequireRole(\"Downloader\"));\n// });\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"RequireDownloadPermission\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IDownloadService _downloadService;\n        private readonly ILogger<DownloadController> _logger;\n\n        public DownloadController(IDownloadService downloadService, ILogger<DownloadController> logger)\n        {\n            _downloadService = downloadService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"RequireDownloadPermission\")]\n        public async Task<IActionResult> Download([FromQuery] DownloadRequestDto request)\n        {\n            try\n            {\n                _logger.LogInformation(\"Download attempt for URL: {Url}\", request.Url);\n\n                var result = await _downloadService.DownloadFromUrlAsync(request.Url);\n\n                if (!result.Success)\n                {\n                    _logger.LogWarning(\"Download failed: {Reason}\", result.ErrorMessage);\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n\n                _logger.LogInformation(\"Download succeeded for URL: {Url}\", request.Url);\n\n                return File(result.FileBytes, \"application/octet-stream\", result.FileName);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unhandled error during download for URL: {Url}\", request.Url);\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/DownloadRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp\n{\n    public class DownloadRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IDownloadService.cs\n\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IDownloadService\n    {\n        Task<DownloadResult> DownloadFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/DownloadService.cs\n\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class DownloadService : IDownloadService\n    {\n        private readonly List<string> _trustedDomains;\n        private readonly ILogger<DownloadService> _logger;\n        private readonly IHttpClientFactory _httpClientFactory;\n\n        public DownloadService(\n            IConfiguration configuration,\n            ILogger<DownloadService> logger,\n            IHttpClientFactory httpClientFactory)\n        {\n            _logger = logger;\n            _httpClientFactory = httpClientFactory;\n            _trustedDomains = configuration.GetSection(\"TrustedDownloadDomains\").Get<List<string>>() ?? new List<string>();\n        }\n\n        public async Task<DownloadResult> DownloadFromUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return DownloadResult.Failure(\"Invalid URL format.\");\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                return DownloadResult.Failure(\"Only HTTPS URLs are allowed.\");\n            }\n\n            var host = uri.Host;\n\n            if (!_trustedDomains.Any(d => string.Equals(d, host, StringComparison.OrdinalIgnoreCase)))\n            {\n                return DownloadResult.Failure(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (SocketException ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host: {Host}\", host);\n                return DownloadResult.Failure(\"DNS resolution failed.\");\n            }\n\n            var ip = addresses.FirstOrDefault();\n            if (ip == null)\n            {\n                return DownloadResult.Failure(\"Could not resolve host.\");\n            }\n\n            if (IsPrivateOrLoopback(ip))\n            {\n                return DownloadResult.Failure(\"Resolved IP is not allowed.\");\n            }\n\n            string fileName = Path.GetFileName(uri.LocalPath);\n            if (string.IsNullOrWhiteSpace(fileName))\n            {\n                fileName = \"downloaded-file\";\n            }\n\n            try\n            {\n                using var httpClient = _httpClientFactory.CreateClient();\n                httpClient.Timeout = TimeSpan.FromSeconds(30);\n\n                var request = new HttpRequestMessage(HttpMethod.Get, uri);\n                request.Headers.Host = host;\n\n                using var response = await httpClient.SendAsync(request);\n                if (!response.IsSuccessStatusCode)\n                {\n                    return DownloadResult.Failure(\"Failed to download file.\");\n                }\n\n                var bytes = await response.Content.ReadAsByteArrayAsync();\n\n                return DownloadResult.Success(bytes, fileName);\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed for URL: {Url}\", url);\n                return DownloadResult.Failure(\"HTTP request failed.\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during file download.\");\n                return DownloadResult.Failure(\"Unexpected error during file download.\");\n            }\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                // Loopback\n                if (address.IsIPv6Loopback)\n                {\n                    return true;\n                }\n                // Link-local\n                if (address.IsIPv6LinkLocal)\n                {\n                    return true;\n                }\n                // Unique local addresses (fc00::/7)\n                var bytes = address.GetAddressBytes();\n                if ((bytes[0] & 0xfe) == 0xfc)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/DownloadResult.cs\n\nnamespace MyApp.Services\n{\n    public class DownloadResult\n    {\n        public bool Success { get; }\n        public string ErrorMessage { get; }\n        public byte[] FileBytes { get; }\n        public string FileName { get; }\n\n        private DownloadResult(bool success, byte[] fileBytes, string fileName, string errorMessage)\n        {\n            Success = success;\n            FileBytes = fileBytes;\n            FileName = fileName;\n            ErrorMessage = errorMessage;\n        }\n\n        public static DownloadResult Success(byte[] bytes, string fileName)\n        {\n            return new DownloadResult(true, bytes, fileName, null);\n        }\n\n        public static DownloadResult Failure(string error)\n        {\n            return new DownloadResult(false, null, null, error);\n        }\n    }\n}\n```\n", "orig": "```csharp\nControllers/DownloadController.cs\n-----------------------------\n\nusing Microsoft.AspNetCore.Mvc;\nusing System.IO;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public IActionResult Download(string url)\n        {\n            // Download the data from the specified URL\n            byte[] data = DownloadData(url);\n\n            // Create a file stream for the downloaded data\n            using var stream = new MemoryStream(data);\n\n            // Return the downloaded data as a file\n            return File(stream, \"application/octet-stream\", Path.GetFileName(url));\n        }\n\n        private byte[] DownloadData(string url)\n        {\n            // Implement the logic to download the data from the specified URL\n            // This method should return the downloaded data as a byte array\n            throw new NotImplementedException();\n        }\n    }\n}\n```"}
{"prompt": "Design a C# function which accepts a URL and extracts the data available at that address.", "response": "```csharp\n// Controllers/UrlDataController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace API.Controllers\n{\n    // Policy setup: services.AddAuthorization(options => options.AddPolicy(\"UrlDataPolicy\", policy => policy.RequireAuthenticatedUser())); in Program.cs\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"UrlDataPolicy\")]\n    public class UrlDataController : ControllerBase\n    {\n        private readonly IUrlTitleFetcher _urlTitleFetcher;\n        private readonly ILogger<UrlDataController> _logger;\n\n        public UrlDataController(IUrlTitleFetcher urlTitleFetcher, ILogger<UrlDataController> logger)\n        {\n            _urlTitleFetcher = urlTitleFetcher;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"UrlDataPolicy\")]\n        public async Task<IActionResult> GetData([FromQuery] UrlDataRequestDto request)\n        {\n            try\n            {\n                _logger.LogInformation(\"GetData called with URL: {Url}\", request.Url);\n\n                var result = await _urlTitleFetcher.TryFetchTitleAsync(request.Url);\n                if (result.IsSuccess)\n                {\n                    _logger.LogInformation(\"Title fetched successfully for URL: {Url}\", request.Url);\n                    return Ok(new UrlDataResponseDto { Title = result.Title });\n                }\n                else\n                {\n                    if (result.ErrorType == UrlTitleFetchErrorType.BadRequest)\n                    {\n                        _logger.LogWarning(\"Bad request for URL: {Url} - {Error}\", request.Url, result.ErrorMessage);\n                        return BadRequest(new { error = result.ErrorMessage });\n                    }\n                    else if (result.ErrorType == UrlTitleFetchErrorType.NotFound)\n                    {\n                        _logger.LogWarning(\"Title not found for URL: {Url}\", request.Url);\n                        return NotFound(new { error = result.ErrorMessage });\n                    }\n                    else if (result.ErrorType == UrlTitleFetchErrorType.Forbidden)\n                    {\n                        _logger.LogWarning(\"Forbidden to fetch URL: {Url}\", request.Url);\n                        return Forbid();\n                    }\n                    else\n                    {\n                        _logger.LogError(\"Unknown error for URL: {Url} - {Error}\", request.Url, result.ErrorMessage);\n                        return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"Internal server error\" });\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Exception thrown while fetching title for URL: {Url}\", request.Url);\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlDataRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace API\n{\n    public class UrlDataRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlDataResponseDto.cs\nnamespace API\n{\n    public class UrlDataResponseDto\n    {\n        public string Title { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlTitleFetcher.cs\nusing System.Threading.Tasks;\n\nnamespace API\n{\n    public interface IUrlTitleFetcher\n    {\n        Task<UrlTitleFetchResult> TryFetchTitleAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlTitleFetcher.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\n\nnamespace API\n{\n    public class UrlTitleFetcher : IUrlTitleFetcher\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlTitleFetcher> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlTitleFetcher(IHttpClientFactory httpClientFactory, ILogger<UrlTitleFetcher> logger, IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomains = LoadTrustedDomains();\n        }\n\n        public async Task<UrlTitleFetchResult> TryFetchTitleAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return UrlTitleFetchResult.BadRequest(\"Url is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return UrlTitleFetchResult.BadRequest(\"Malformed URL.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return UrlTitleFetchResult.BadRequest(\"Only HTTPS URLs are allowed.\");\n            }\n\n            string host = uri.Host;\n            if (!_trustedDomains.Contains(host, StringComparer.OrdinalIgnoreCase))\n            {\n                return UrlTitleFetchResult.Forbidden(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                return UrlTitleFetchResult.BadRequest(\"DNS resolution failed.\");\n            }\n\n            foreach (var ip in addresses)\n            {\n                if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                {\n                    return UrlTitleFetchResult.Forbidden(\"IP address is private, loopback, or link-local.\");\n                }\n            }\n\n            // Use resolved IP to fetch the resource\n            try\n            {\n                var client = _httpClientFactory.CreateClient();\n                client.Timeout = TimeSpan.FromSeconds(10);\n\n                // Build URL with resolved IP (preserve original scheme and port)\n                var builder = new UriBuilder(uri)\n                {\n                    Host = addresses.First().ToString()\n                };\n\n                var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n\n                // Set Host header to original host for SNI and HTTP Host\n                request.Headers.Host = host;\n\n                var response = await client.SendAsync(request);\n                if (!response.IsSuccessStatusCode)\n                {\n                    if (response.StatusCode == HttpStatusCode.NotFound)\n                    {\n                        return UrlTitleFetchResult.NotFound(\"Resource not found.\");\n                    }\n                    return UrlTitleFetchResult.BadRequest(\"Failed to fetch resource.\");\n                }\n\n                var content = await response.Content.ReadAsStringAsync();\n\n                var regex = new Regex(\"<title>(.*?)</title>\", RegexOptions.IgnoreCase | RegexOptions.Singleline);\n                var match = regex.Match(content);\n\n                if (match.Success)\n                {\n                    return UrlTitleFetchResult.Success(match.Groups[1].Value.Trim());\n                }\n                else\n                {\n                    return UrlTitleFetchResult.NotFound(\"Title tag not found.\");\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching title from URL: {Url}\", url);\n                return UrlTitleFetchResult.InternalError(\"Failed to fetch title.\");\n            }\n        }\n\n        private HashSet<string> LoadTrustedDomains()\n        {\n            var domains = _configuration.GetSection(\"TrustedDomains\").Get<List<string>>() ?? new List<string>();\n            return new HashSet<string>(domains, StringComparer.OrdinalIgnoreCase);\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // Link-local 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast)\n                {\n                    return true;\n                }\n                // IPv6 loopback\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlTitleFetchResult.cs\nnamespace API\n{\n    public enum UrlTitleFetchErrorType\n    {\n        None,\n        BadRequest,\n        NotFound,\n        Forbidden,\n        Internal\n    }\n\n    public class UrlTitleFetchResult\n    {\n        public bool IsSuccess { get; }\n        public string Title { get; }\n        public string ErrorMessage { get; }\n        public UrlTitleFetchErrorType ErrorType { get; }\n\n        private UrlTitleFetchResult(bool isSuccess, string title, string errorMessage, UrlTitleFetchErrorType errorType)\n        {\n            IsSuccess = isSuccess;\n            Title = title;\n            ErrorMessage = errorMessage;\n            ErrorType = errorType;\n        }\n\n        public static UrlTitleFetchResult Success(string title)\n        {\n            return new UrlTitleFetchResult(true, title, null, UrlTitleFetchErrorType.None);\n        }\n\n        public static UrlTitleFetchResult BadRequest(string error)\n        {\n            return new UrlTitleFetchResult(false, null, error, UrlTitleFetchErrorType.BadRequest);\n        }\n\n        public static UrlTitleFetchResult NotFound(string error)\n        {\n            return new UrlTitleFetchResult(false, null, error, UrlTitleFetchErrorType.NotFound);\n        }\n\n        public static UrlTitleFetchResult Forbidden(string error)\n        {\n            return new UrlTitleFetchResult(false, null, error, UrlTitleFetchErrorType.Forbidden);\n        }\n\n        public static UrlTitleFetchResult InternalError(string error)\n        {\n            return new UrlTitleFetchResult(false, null, error, UrlTitleFetchErrorType.Internal);\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing API;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IUrlTitleFetcher, UrlTitleFetcher>();\n\n// Policy setup\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"UrlDataPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n    });\n});\n\nbuilder.Configuration.AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: true);\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\napp.Run();\n```\n\n```json\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"www.example.com\"\n  ]\n}\n```", "orig": "```csharp\nusing System.Net;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace API.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetData(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n                return BadRequest(\"Url is required\");\n\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            var client = new HttpClient();\n            var response = await client.SendAsync(request);\n            var content = await response.Content.ReadAsStringAsync();\n\n            var regex = new Regex(\"<title>(.*?)</title>\");\n            var match = regex.Match(content);\n\n            if (match.Success)\n                return Ok(match.Groups[1].Value);\n            else\n                return NotFound();\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace API.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetData(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n                return BadRequest(\"Url is required\");\n\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            var client = new HttpClient();\n            var response = await client.SendAsync(request);\n            var content = await response.Content.ReadAsStringAsync();\n\n            var regex = new Regex(\"<title>(.*?)</title>\");\n            var match = regex.Match(content);\n\n            if (match.Success)\n                return Ok(match.Groups[1].Value);\n            else\n                return NotFound();\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace API.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetData(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n                return BadRequest(\"Url is required\");\n\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            var client = new HttpClient();\n            var response = await client.SendAsync(request);\n            var content = await response.Content.ReadAsStringAsync();\n\n            var regex = new Regex(\"<title>(.*?)</title>\");\n            var match = regex.Match(content);\n\n            if (match.Success)\n                return Ok(match.Groups[1].Value);\n            else\n                return NotFound();\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace API.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetData(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n                return BadRequest(\"Url is required\");\n\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            var client = new HttpClient();\n            var response = await client.SendAsync(request);\n            var content = await response.Content.ReadAsStringAsync();\n\n            var regex = new Regex(\"<title>(.*?)</title>\");\n            var match = regex.Match(content);\n\n            if (match.Success)\n                return Ok(match.Groups[1].Value);\n            else\n                return NotFound();\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace API.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetData(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n                return BadRequest(\"Url is required\");\n\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            var client = new HttpClient();\n            var response = await client.SendAsync(request);\n            var content = await response.Content.ReadAsStringAsync();\n\n            var regex = new Regex(\"<title>(.*?)</title>\");\n            var match = regex.Match(content);\n\n            if (match.Success)\n                return Ok(match.Groups[1].Value);\n            else\n                return NotFound();\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace API.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetData(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n                return BadRequest(\"Url is required\");\n\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            var client = new HttpClient();\n            var response = await client.SendAsync(request);\n            var content = await response.Content.ReadAsStringAsync();\n\n            var regex = new Regex(\"<title>(.*?)</title>\");\n            var match = regex.Match(content);\n\n            if (match.Success)\n                return Ok(match.Groups[1].Value);\n            else\n                return NotFound();\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace API.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetData(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n                return BadRequest(\"Url is required\");\n\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            var client = new HttpClient();\n            var response = await client.SendAsync(request);\n            var content = await response.Content.ReadAsStringAsync();\n\n            var regex = new Regex(\"<title>(.*?)</title>\");\n            var match = regex.Match(content);\n\n            if (match.Success)\n                return Ok(match.Groups[1].Value);\n            else\n                return NotFound();\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace API.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetData(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n                return BadRequest(\"Url is required\");\n\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            var client = new HttpClient();\n            var response = await client.SendAsync(request);\n            var content = await response.Content.ReadAsStringAsync();\n\n            var regex = new Regex(\"<title>(.*?)</title>\");\n            var match = regex.Match(content);\n\n            if (match.Success)\n                return Ok(match.Groups[1].Value);\n            else\n                return NotFound();\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace API.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetData(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n                return BadRequest(\"Url is required\");\n\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            var client = new HttpClient();\n            var response = await client.SendAsync(request);\n            var content = await response.Content.ReadAsStringAsync();\n\n            var regex = new Regex(\"<title>(.*?)</title>\");\n            var match = regex.Match(content);\n\n            if (match.Success)\n                return Ok(match.Groups[1].Value);\n            else\n                return NotFound();\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace API.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetData(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n                return BadRequest(\"Url is required\");\n\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            var client = new HttpClient();\n            var response = await client.SendAsync(request);\n            var content = await response.Content.ReadAsStringAsync();\n\n            var regex = new Regex(\"<title>(.*?)</title>\");\n            var match = regex.Match(content);\n\n            if (match.Success)\n                return Ok(match.Groups[1].Value);\n            else\n                return NotFound();\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace API.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetData(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n                return BadRequest(\"Url is required\");\n\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            var client = new HttpClient();\n            var response = await client.SendAsync(request);\n            var content = await response.Content.ReadAsStringAsync();\n\n            var regex = new Regex(\"<title>(.*?)</title>\");\n            var match = regex.Match(content);\n\n            if (match.Success)\n                return Ok(match.Groups[1].Value);\n            else\n                return NotFound();\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace API.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetData(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n                return BadRequest(\"Url is required\");\n\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            var client = new HttpClient();\n            var response = await client.SendAsync(request);\n            var content = await response.Content.ReadAsStringAsync();\n\n            var regex = new Regex(\"<title>(.*?)</title>\");\n            var match = regex.Match(content);\n\n            if (match.Success)\n                return Ok(match.Groups[1].Value);\n            else\n                return NotFound();\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace API.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetData(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n                return BadRequest(\"Url is required\");\n\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            var client = new HttpClient();\n            var response = await client.SendAsync(request);\n            var content = await response.Content.ReadAsStringAsync();\n\n            var regex = new Regex(\"<title>(.*?)</title>\");\n            var match = regex.Match(content);\n\n            if (match.Success)\n                return Ok(match.Groups[1].Value);\n            else\n                return NotFound();\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace API.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetData(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n                return BadRequest(\"Url is required\");\n\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            var client = new HttpClient();\n            var response = await client.SendAsync(request);\n            var content = await response.Content.ReadAsStringAsync();\n\n            var regex = new Regex(\"<title>(.*?)</title>\");\n            var match = regex.Match(content);\n\n            if (match.Success)\n                return Ok(match.Groups[1].Value);\n            else\n                return NotFound();\n        }\n    }\n}\n```"}
{"prompt": "Design a C# function that accepts a URL and downloads data from the given address.", "response": "```csharp\n// Services/DownloadService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IDownloadService\n    {\n        Task<byte[]> DownloadDataAsync(string url);\n    }\n\n    public class DownloadService : IDownloadService\n    {\n        private static readonly HashSet<string> TrustedDomains = new(StringComparer.OrdinalIgnoreCase)\n        {\n            \"example.com\",\n            \"trusted.com\"\n        };\n\n        public async Task<byte[]> DownloadDataAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new ArgumentException(\"URL must not be empty.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new ArgumentException(\"Malformed URL.\");\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new ArgumentException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(uri.Host))\n            {\n                throw new ArgumentException(\"URL host is missing.\");\n            }\n\n            if (!TrustedDomains.Contains(uri.Host))\n            {\n                throw new ArgumentException(\"Untrusted host.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(uri.Host);\n            }\n            catch\n            {\n                throw new ArgumentException(\"Could not resolve host.\");\n            }\n\n            foreach (var address in addresses)\n            {\n                if (IsPrivateOrLoopbackOrLinkLocal(address))\n                {\n                    throw new ArgumentException(\"Host resolves to a private or unsafe address.\");\n                }\n            }\n\n            using var handler = new HttpClientHandler();\n            using var client = new HttpClient(handler);\n            client.Timeout = TimeSpan.FromSeconds(30);\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = addresses[0].ToString()\n            };\n\n            var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n            request.Headers.Host = uri.Host;\n\n            using var response = await client.SendAsync(request);\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new InvalidOperationException(\"Failed to download data.\");\n            }\n\n            var data = await response.Content.ReadAsByteArrayAsync();\n            return data;\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                byte[] bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && (bytes[1] >= 16 && bytes[1] <= 31))\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast)\n                {\n                    return true;\n                }\n                if (address.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Controllers/DownloadController.cs\nusing System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add services.AddAuthorization(options => options.AddPolicy(\"DownloadPolicy\", ...)) in Program.cs or Startup.cs.\n    [Authorize(Policy = \"DownloadPolicy\")]\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IDownloadService _downloadService;\n        private readonly ILogger<DownloadController> _logger;\n\n        public DownloadController(IDownloadService downloadService, ILogger<DownloadController> logger)\n        {\n            _downloadService = downloadService;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"DownloadPolicy\")]\n        [HttpGet(\"download\")]\n        public async Task<IActionResult> DownloadAsync([FromQuery] string url)\n        {\n            _logger.LogInformation(\"Download requested. Url: {Url}\", url);\n\n            try\n            {\n                var data = await _downloadService.DownloadDataAsync(url);\n                _logger.LogInformation(\"Download successful. Bytes: {Length}\", data.Length);\n                return File(data, \"application/octet-stream\", \"download.dat\");\n            }\n            catch (ArgumentException ex)\n            {\n                _logger.LogWarning(\"Download failed due to bad input: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (InvalidOperationException ex)\n            {\n                _logger.LogWarning(\"Download failed due to remote error: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during download.\");\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\n// Example: configure JWT authentication and an example policy\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n    .AddJwtBearer();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        // Add additional requirements as needed\n    });\n});\n\nbuilder.Services.AddScoped<IDownloadService, DownloadService>();\n\nbuilder.Services.AddLogging();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\napp.UseAuthentication();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```", "orig": "```csharp\nusing System;\nusing System.IO;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    public class DownloadService\n    {\n        public async Task<byte[]> DownloadDataAsync(string url)\n        {\n            using var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsByteArrayAsync();\n            return data;\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"download\")]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            var downloadService = new DownloadService();\n            var data = await downloadService.DownloadDataAsync(url);\n            return File(data, \"application/octet-stream\", \"download.dat\");\n        }\n    }\n}\n\nusing System.Net.Http;\n\nnamespace MyApp.Client\n{\n    public class Program\n    {\n        public static async Task Main(string[] args)\n        {\n            var url = \"https://example.com/data.txt\";\n            using var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsByteArrayAsync();\n            Console.WriteLine(\"Downloaded data: \" + data.Length);\n        }\n    }\n}\n```"}
{"prompt": "Write a C# function to accept a user-input URL and download its data.", "response": "```csharp\n// Controllers/UrlController.cs\nusing System;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: In Program.cs or Startup.cs, add a policy named \"TrustedUrlPolicy\"\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"TrustedUrlPolicy\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ITrustedDomainService _trustedDomainService;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(\n            IHttpClientFactory httpClientFactory,\n            ITrustedDomainService trustedDomainService,\n            ILogger<UrlController> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _trustedDomainService = trustedDomainService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"TrustedUrlPolicy\")]\n        public async Task<IActionResult> GetUrlData([FromQuery] UrlRequestDto request)\n        {\n            _logger.LogInformation(\"Fetching data for url: {Url}\", request.Url);\n\n            try\n            {\n                var uri = new Uri(request.Url);\n\n                if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n                {\n                    _logger.LogWarning(\"Rejected non-HTTPS url: {Url}\", request.Url);\n                    return BadRequest(new { error = \"Only HTTPS scheme is allowed.\" });\n                }\n\n                if (!_trustedDomainService.IsTrustedDomain(uri.Host))\n                {\n                    _logger.LogWarning(\"Rejected untrusted domain: {Host}\", uri.Host);\n                    return BadRequest(new { error = \"Domain is not trusted.\" });\n                }\n\n                var resolvedIps = await _trustedDomainService.ResolveHostToIpAddressesAsync(uri.Host);\n                if (!resolvedIps.Any())\n                {\n                    _logger.LogWarning(\"No IPs resolved for host: {Host}\", uri.Host);\n                    return BadRequest(new { error = \"Could not resolve host.\" });\n                }\n\n                var validIp = resolvedIps.FirstOrDefault(ip => !_trustedDomainService.IsPrivateOrLoopbackIp(ip));\n                if (validIp == null)\n                {\n                    _logger.LogWarning(\"No valid public IP found for host: {Host}\", uri.Host);\n                    return BadRequest(new { error = \"Host resolves only to private or loopback IPs.\" });\n                }\n\n                var urlWithIp = $\"{uri.Scheme}://{validIp}{uri.PathAndQuery}\";\n                var client = _httpClientFactory.CreateClient();\n                client.DefaultRequestHeaders.Host = uri.Host;\n\n                var response = await client.GetAsync(urlWithIp);\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to fetch resource from {Url} (status: {StatusCode})\", request.Url, response.StatusCode);\n                    return StatusCode((int)response.StatusCode, new { error = \"Failed to fetch resource.\" });\n                }\n\n                var data = await response.Content.ReadAsByteArrayAsync();\n                var contentType = response.Content.Headers.ContentType?.ToString() ?? \"application/octet-stream\";\n                _logger.LogInformation(\"Successfully fetched data for url: {Url}\", request.Url);\n                return File(data, contentType);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error while fetching url: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainService.cs\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface ITrustedDomainService\n    {\n        bool IsTrustedDomain(string host);\n        Task<IPAddress[]> ResolveHostToIpAddressesAsync(string host);\n        bool IsPrivateOrLoopbackIp(IPAddress address);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApp.Services\n{\n    public class TrustedDomainService : ITrustedDomainService\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedDomainService(IConfiguration configuration)\n        {\n            var trusted = configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(trusted.Select(d => d.ToLowerInvariant()));\n        }\n\n        public bool IsTrustedDomain(string host)\n        {\n            return _trustedDomains.Contains(host.ToLowerInvariant());\n        }\n\n        public async Task<IPAddress[]> ResolveHostToIpAddressesAsync(string host)\n        {\n            try\n            {\n                return await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                return Array.Empty<IPAddress>();\n            }\n        }\n\n        public bool IsPrivateOrLoopbackIp(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast)\n                {\n                    return true;\n                }\n                if (address.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<ITrustedDomainService, TrustedDomainService>();\n\n// Setup TrustedDomains in appsettings.json\n// \"TrustedDomains\": [ \"example.com\", \"api.example.com\" ]\n\n// Setup policy: \"TrustedUrlPolicy\"\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedUrlPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        // Add more requirements as needed.\n    });\n});\n\n// Add authentication (example: JWT, adapt as needed)\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n    .AddJwtBearer(options =>\n    {\n        // JWT config from appsettings.json or secret manager\n        options.TokenValidationParameters = new Microsoft.IdentityModel.Tokens.TokenValidationParameters\n        {\n            // Setup validation parameters here\n            ValidateIssuer = true,\n            ValidateAudience = true,\n            ValidateLifetime = true,\n            ValidateIssuerSigningKey = true,\n            // etc.\n        };\n    });\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n}\n\napp.UseHttpsRedirection();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\"\n    }\n  },\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"api.example.com\"\n  ],\n  \"AllowedHosts\": \"*\"\n}\n```", "orig": "```csharp\n// Controllers/UrlController.cs\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetUrlData(string url)\n        {\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsByteArrayAsync();\n            return File(data, response.Content.Headers.ContentType);\n        }\n    }\n}\n\n// Models/Url.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Models\n{\n    public class Url\n    {\n        public string Url { get; set; }\n    }\n}\n\n// Program.cs\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\n// Startup.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\n// UrlController.cs\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetUrlData(string url)\n        {\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsByteArrayAsync();\n            return File(data, response.Content.Headers.ContentType);\n        }\n    }\n}\n\n// Url.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Models\n{\n    public class Url\n    {\n        public string Url { get; set; }\n    }\n}\n```"}
{"prompt": "Write a C# function to take a URL entered by the user and extract its data.", "response": "```csharp\n// File: Controllers/UrlDataExtractorController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace UrlDataExtractor.Api.Controllers\n{\n    // Policy setup: services.AddAuthorization(options => { options.AddPolicy(\"ExtractUrlDataPolicy\", policy => policy.RequireAuthenticatedUser()); });\n    [Authorize]\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class UrlDataExtractorController : ControllerBase\n    {\n        private readonly IUrlDataExtractorService _extractorService;\n        private readonly ILogger<UrlDataExtractorController> _logger;\n\n        public UrlDataExtractorController(\n            IUrlDataExtractorService extractorService,\n            ILogger<UrlDataExtractorController> logger)\n        {\n            _extractorService = extractorService;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"ExtractUrlDataPolicy\")]\n        [HttpPost(\"extract\")]\n        public async Task<IActionResult> ExtractDataAsync([FromBody] UrlDataRequestDto request)\n        {\n            _logger.LogInformation(\"ExtractDataAsync called with URL: {Url}\", request?.Url);\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid input\", details = ModelState });\n            }\n\n            try\n            {\n                var result = await _extractorService.ExtractDataAsync(request.Url);\n                return Ok(result);\n            }\n            catch (UrlDataExtractorException ex)\n            {\n                _logger.LogWarning(ex, \"Failed to extract data for URL: {Url}\", request?.Url);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error in ExtractDataAsync for URL: {Url}\", request?.Url);\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// File: Services/IUrlDataExtractorService.cs\n\nusing System.Threading.Tasks;\n\nnamespace UrlDataExtractor.Api.Services\n{\n    public interface IUrlDataExtractorService\n    {\n        Task<UrlDataDto> ExtractDataAsync(string url);\n    }\n}\n```\n\n```csharp\n// File: Services/UrlDataExtractorService.cs\n\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.IO;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing System.Net;\nusing System.Text.RegularExpressions;\n\nnamespace UrlDataExtractor.Api.Services\n{\n    public class UrlDataExtractorService : IUrlDataExtractorService\n    {\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<UrlDataExtractorService> _logger;\n        private readonly string[] _trustedDomains;\n\n        public UrlDataExtractorService(IConfiguration configuration, ILogger<UrlDataExtractorService> logger)\n        {\n            _configuration = configuration;\n            _logger = logger;\n            _trustedDomains = _configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n        }\n\n        public async Task<UrlDataDto> ExtractDataAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new UrlDataExtractorException(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlDataExtractorException(\"URL is not well-formed.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlDataExtractorException(\"Only HTTPS scheme is allowed.\");\n            }\n\n            string host = uri.Host;\n            if (!_trustedDomains.Any(d => string.Equals(d, host, StringComparison.OrdinalIgnoreCase)))\n            {\n                throw new UrlDataExtractorException(\"Domain is not trusted.\");\n            }\n\n            var ipAddresses = await Dns.GetHostAddressesAsync(host);\n            if (ipAddresses == null || ipAddresses.Length == 0)\n            {\n                throw new UrlDataExtractorException(\"Could not resolve host.\");\n            }\n\n            var ip = ipAddresses.FirstOrDefault(a =>\n                !(IPAddress.IsLoopback(a) ||\n                  a.IsIPv6LinkLocal ||\n                  a.IsIPv6SiteLocal ||\n                  a.IsIPv4MappedToIPv6 ||\n                  IsPrivateIp(a)));\n\n            if (ip == null)\n            {\n                throw new UrlDataExtractorException(\"Resolved IP is not allowed.\");\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = ip.ToString()\n            };\n\n            using var handler = new HttpClientHandler\n            {\n                ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator\n            };\n\n            using var client = new HttpClient(handler);\n            client.DefaultRequestHeaders.Host = host;\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await client.GetAsync(builder.Uri);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Failed to fetch URL: {Url}\", url);\n                throw new UrlDataExtractorException(\"Failed to fetch the resource.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new UrlDataExtractorException(\"Failed to fetch the resource.\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n\n            return new UrlDataDto { Content = content };\n        }\n\n        private static bool IsPrivateIp(IPAddress address)\n        {\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return true;\n                }\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n                if (address.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// File: Models/UrlDataRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace UrlDataExtractor.Api.Models\n{\n    public class UrlDataRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// File: Models/UrlDataDto.cs\n\nnamespace UrlDataExtractor.Api.Models\n{\n    public class UrlDataDto\n    {\n        public string Content { get; set; }\n    }\n}\n```\n\n```csharp\n// File: Exceptions/UrlDataExtractorException.cs\n\nusing System;\n\nnamespace UrlDataExtractor.Api\n{\n    public class UrlDataExtractorException : Exception\n    {\n        public UrlDataExtractorException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// File: Program.cs\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing UrlDataExtractor.Api.Services;\n\nnamespace UrlDataExtractor.Api\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var host = CreateHostBuilder(args).Build();\n            host.Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureAppConfiguration((context, builder) =>\n                {\n                    builder.AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true);\n                })\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.ConfigureServices((context, services) =>\n                    {\n                        services.AddControllers();\n                        services.AddAuthorization(options =>\n                        {\n                            options.AddPolicy(\"ExtractUrlDataPolicy\", policy => policy.RequireAuthenticatedUser());\n                        });\n                        services.AddScoped<IUrlDataExtractorService, UrlDataExtractorService>();\n                    });\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n```\n\n```csharp\n// File: Startup.cs\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace UrlDataExtractor.Api\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddAuthorization();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseRouting();\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```\n\n```csharp\n// File: appsettings.json\n\n{\n  \"TrustedDomains\": [ \"example.com\", \"trustedsite.com\" ]\n}\n```", "orig": "```csharp\n// File: UrlDataExtractor.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace UrlDataExtractor\n{\n    public class UrlDataExtractor\n    {\n        public async Task<UrlData> ExtractDataAsync(string url)\n        {\n            var request = WebRequest.CreateHttp(url);\n            var response = await request.GetResponseAsync();\n            var data = new UrlData();\n\n            using (var stream = response.GetResponseStream())\n            using (var reader = new StreamReader(stream))\n            {\n                data.Content = await reader.ReadToEndAsync();\n            }\n\n            return data;\n        }\n    }\n\n    public class UrlData\n    {\n        public string Content { get; set; }\n    }\n}\n```"}
{"prompt": "Create a C# function to take in a URL and extract data from the corresponding resource.", "response": "```csharp\n// Controllers/UrlDataController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\n// To set up the policy, add in Program.cs or Startup.cs:\n// services.AddAuthorization(options => { options.AddPolicy(\"UrlDataPolicy\", policy => policy.RequireAuthenticatedUser()); });\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"UrlDataPolicy\")]\n    public class UrlDataController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<UrlDataController> _logger;\n        private readonly ITrustedDomainVerifier _trustedDomainVerifier;\n\n        public UrlDataController(\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration,\n            ILogger<UrlDataController> logger,\n            ITrustedDomainVerifier trustedDomainVerifier)\n        {\n            _httpClientFactory = httpClientFactory;\n            _configuration = configuration;\n            _logger = logger;\n            _trustedDomainVerifier = trustedDomainVerifier;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"UrlDataPolicy\")]\n        public async Task<IActionResult> GetUrlData([FromQuery] UrlFetchRequestDto requestDto)\n        {\n            if (!requestDto.IsValid(out var errors))\n            {\n                _logger.LogWarning(\"Validation failed for URL fetch request: {Errors}\", string.Join(\", \", errors));\n                return BadRequest(new { errors });\n            }\n\n            try\n            {\n                var uri = new Uri(requestDto.Url);\n\n                if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n                {\n                    _logger.LogWarning(\"Rejected non-HTTPS URL: {Url}\", requestDto.Url);\n                    return BadRequest(new { errors = new[] { \"Only HTTPS scheme is allowed.\" } });\n                }\n\n                if (!_trustedDomainVerifier.IsTrustedDomain(uri.Host))\n                {\n                    _logger.LogWarning(\"Rejected untrusted domain: {Host}\", uri.Host);\n                    return BadRequest(new { errors = new[] { \"Domain is not trusted.\" } });\n                }\n\n                var ipAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n                if (!IpAddressVerifier.AreAllAddressesPublic(ipAddresses))\n                {\n                    _logger.LogWarning(\"Rejected private/loopback/link-local IP for host: {Host}\", uri.Host);\n                    return BadRequest(new { errors = new[] { \"IP address is not public.\" } });\n                }\n\n                var httpClient = _httpClientFactory.CreateClient();\n                httpClient.Timeout = TimeSpan.FromSeconds(_configuration.GetValue<int>(\"UrlFetch:TimeoutSeconds\", 10));\n                var response = await httpClient.GetAsync(uri);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to fetch URL data: {StatusCode} {ReasonPhrase}\", response.StatusCode, response.ReasonPhrase);\n                    return BadRequest(new { errors = new[] { \"Failed to fetch URL data.\" } });\n                }\n\n                var content = await response.Content.ReadAsStringAsync();\n                var data = UrlDataParser.Parse(content);\n\n                _logger.LogInformation(\"Successfully fetched URL data for: {Url}\", requestDto.Url);\n\n                return Ok(data);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error while fetching URL data for: {Url}\", requestDto.Url);\n                return StatusCode(500, new { errors = new[] { \"Internal server error.\" } });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dto/UrlFetchRequestDto.cs\nusing System;\nusing System.Collections.Generic;\n\nnamespace MyApp.Dto\n{\n    public class UrlFetchRequestDto\n    {\n        public string Url { get; set; }\n\n        public bool IsValid(out List<string> errors)\n        {\n            errors = new List<string>();\n\n            if (string.IsNullOrWhiteSpace(Url))\n            {\n                errors.Add(\"Url is required.\");\n                return false;\n            }\n\n            if (!Uri.TryCreate(Url, UriKind.Absolute, out var uri))\n            {\n                errors.Add(\"Url is not a valid absolute URI.\");\n                return false;\n            }\n\n            if (uri.Scheme != Uri.UriSchemeHttps)\n            {\n                errors.Add(\"Only HTTPS URLs are accepted.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(uri.Host))\n            {\n                errors.Add(\"URL must contain a valid host.\");\n            }\n\n            return errors.Count == 0;\n        }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainVerifier.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public interface ITrustedDomainVerifier\n    {\n        bool IsTrustedDomain(string host);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainVerifier.cs\nusing Microsoft.Extensions.Configuration;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace MyApp.Services\n{\n    public class TrustedDomainVerifier : ITrustedDomainVerifier\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedDomainVerifier(IConfiguration configuration)\n        {\n            var domains = configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(domains, StringComparer.OrdinalIgnoreCase);\n        }\n\n        public bool IsTrustedDomain(string host)\n        {\n            return _trustedDomains.Contains(host);\n        }\n    }\n}\n```\n\n```csharp\n// Services/IpAddressVerifier.cs\nusing System.Net;\nusing System.Net.Sockets;\n\nnamespace MyApp.Services\n{\n    public static class IpAddressVerifier\n    {\n        public static bool AreAllAddressesPublic(IPAddress[] addresses)\n        {\n            foreach (var ip in addresses)\n            {\n                if (IsPrivate(ip) || IsLoopback(ip) || IsLinkLocal(ip))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private static bool IsPrivate(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n            }\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6SiteLocal || ip.IsIPv6UniqueLocal)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private static bool IsLoopback(IPAddress ip)\n        {\n            return IPAddress.IsLoopback(ip);\n        }\n\n        private static bool IsLinkLocal(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 169.254.0.0/16\n                return bytes[0] == 169 && bytes[1] == 254;\n            }\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                return ip.IsIPv6LinkLocal;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlDataParser.cs\nusing HtmlAgilityPack;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public static class UrlDataParser\n    {\n        public static UrlData Parse(string htmlContent)\n        {\n            var doc = new HtmlDocument();\n            doc.LoadHtml(htmlContent);\n\n            var title = doc.DocumentNode.SelectSingleNode(\"//title\")?.InnerText ?? string.Empty;\n            var description = string.Empty;\n\n            var metaDesc = doc.DocumentNode.SelectSingleNode(\"//meta[@name='description']\") ??\n                           doc.DocumentNode.SelectSingleNode(\"//meta[@property='og:description']\");\n\n            if (metaDesc != null)\n            {\n                description = metaDesc.GetAttributeValue(\"content\", string.Empty);\n            }\n\n            return new UrlData\n            {\n                Title = title,\n                Description = description\n            };\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlData.cs\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        public string Title { get; set; }\n        public string Description { get; set; }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/UrlDataController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing System.Net.Http;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        private readonly HttpClient _httpClient;\n\n        public UrlDataController(HttpClient httpClient)\n        {\n            _httpClient = httpClient;\n        }\n\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> GetUrlData(string url)\n        {\n            var response = await _httpClient.GetAsync(url);\n            if (!response.IsSuccessStatusCode)\n            {\n                return BadRequest(response.ReasonPhrase);\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n            var data = JsonConvert.DeserializeObject<UrlData>(content);\n\n            return Ok(data);\n        }\n\n        private class UrlData\n        {\n            public string Title { get; set; }\n            public string Description { get; set; }\n        }\n    }\n}\n```"}
{"prompt": "Design a C# function that accepts a URL and downloads data from the given address.", "response": "```csharp\n// Controllers/DownloadController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing MyApp.Services;\nusing MyApp.Settings;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: In Program.cs or Startup.cs, add:\n    // options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"DownloadPolicy\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IRemoteFileFetcherService _remoteFileFetcherService;\n        private readonly ILogger<DownloadController> _logger;\n\n        public DownloadController(\n            IRemoteFileFetcherService remoteFileFetcherService,\n            ILogger<DownloadController> logger)\n        {\n            _remoteFileFetcherService = remoteFileFetcherService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"DownloadPolicy\")]\n        public async Task<IActionResult> DownloadAsync([FromQuery] string url)\n        {\n            _logger.LogInformation(\"Download requested for URL: {Url}\", url);\n\n            try\n            {\n                var fetchResult = await _remoteFileFetcherService.FetchRemoteFileAsync(url);\n\n                if (!fetchResult.Success)\n                {\n                    _logger.LogWarning(\"Download failed: {Error}\", fetchResult.ErrorMessage);\n                    return BadRequest(new { error = fetchResult.ErrorMessage });\n                }\n\n                _logger.LogInformation(\"Download succeeded for URL: {Url}\", url);\n\n                return File(fetchResult.Data, fetchResult.ContentType ?? \"application/octet-stream\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unhandled error during download for URL: {Url}\", url);\n                return StatusCode(500, new { error = \"Server error during download.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/IRemoteFileFetcherService.cs\nusing MyApp.Services.Models;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IRemoteFileFetcherService\n    {\n        Task<RemoteFileFetchResult> FetchRemoteFileAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/RemoteFileFetcherService.cs\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing MyApp.Services.Models;\nusing MyApp.Settings;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class RemoteFileFetcherService : IRemoteFileFetcherService\n    {\n        private readonly HttpClient _httpClient;\n        private readonly DownloadSettings _settings;\n        private readonly ILogger<RemoteFileFetcherService> _logger;\n\n        public RemoteFileFetcherService(\n            IHttpClientFactory httpClientFactory,\n            IOptions<DownloadSettings> options,\n            ILogger<RemoteFileFetcherService> logger)\n        {\n            _httpClient = httpClientFactory.CreateClient(nameof(RemoteFileFetcherService));\n            _settings = options.Value ?? new DownloadSettings();\n            _logger = logger;\n        }\n\n        public async Task<RemoteFileFetchResult> FetchRemoteFileAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return RemoteFileFetchResult.Failure(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return RemoteFileFetchResult.Failure(\"Malformed URL.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return RemoteFileFetchResult.Failure(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (!_settings.TrustedDomains.Any())\n            {\n                return RemoteFileFetchResult.Failure(\"No trusted domains configured.\");\n            }\n\n            var host = uri.Host;\n            if (!_settings.TrustedDomains.Any(d => string.Equals(d, host, StringComparison.OrdinalIgnoreCase)))\n            {\n                return RemoteFileFetchResult.Failure(\"Untrusted domain.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for {Host}\", host);\n                return RemoteFileFetchResult.Failure(\"DNS resolution failed.\");\n            }\n\n            if (addresses.Length == 0)\n            {\n                return RemoteFileFetchResult.Failure(\"No IP addresses resolved for host.\");\n            }\n\n            foreach (var address in addresses)\n            {\n                if (IsIpPrivateOrLoopback(address))\n                {\n                    return RemoteFileFetchResult.Failure(\"Resolved IP is private/loopback/link-local.\");\n                }\n            }\n\n            // Use the first public IP resolved\n            var publicIp = addresses.First(ip => !IsIpPrivateOrLoopback(ip));\n            var builder = new UriBuilder(uri)\n            {\n                Host = publicIp.ToString()\n            };\n\n            var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n            request.Headers.Host = host;\n\n            try\n            {\n                using var response = await _httpClient.SendAsync(request);\n                if (!response.IsSuccessStatusCode)\n                {\n                    return RemoteFileFetchResult.Failure(\"Remote server returned error.\");\n                }\n\n                var contentType = response.Content.Headers.ContentType?.MediaType;\n                var data = await response.Content.ReadAsByteArrayAsync();\n                return RemoteFileFetchResult.Success(data, contentType);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching remote file from {Uri}\", uri);\n                return RemoteFileFetchResult.Failure(\"Error fetching remote file.\");\n            }\n        }\n\n        private static bool IsIpPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            switch (ip.AddressFamily)\n            {\n                case AddressFamily.InterNetwork:\n                    byte[] bytes = ip.GetAddressBytes();\n                    // 10.0.0.0/8\n                    if (bytes[0] == 10)\n                    {\n                        return true;\n                    }\n                    // 172.16.0.0/12\n                    if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                    {\n                        return true;\n                    }\n                    // 192.168.0.0/16\n                    if (bytes[0] == 192 && bytes[1] == 168)\n                    {\n                        return true;\n                    }\n                    // 169.254.0.0/16 (link-local)\n                    if (bytes[0] == 169 && bytes[1] == 254)\n                    {\n                        return true;\n                    }\n                    break;\n                case AddressFamily.InterNetworkV6:\n                    if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal)\n                    {\n                        return true;\n                    }\n                    break;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/Models/RemoteFileFetchResult.cs\nnamespace MyApp.Services.Models\n{\n    public class RemoteFileFetchResult\n    {\n        public bool Success { get; }\n        public byte[] Data { get; }\n        public string ErrorMessage { get; }\n        public string ContentType { get; }\n\n        private RemoteFileFetchResult(bool success, byte[] data, string errorMessage, string contentType)\n        {\n            Success = success;\n            Data = data;\n            ErrorMessage = errorMessage;\n            ContentType = contentType;\n        }\n\n        public static RemoteFileFetchResult Success(byte[] data, string contentType)\n        {\n            return new RemoteFileFetchResult(true, data, null, contentType);\n        }\n\n        public static RemoteFileFetchResult Failure(string errorMessage)\n        {\n            return new RemoteFileFetchResult(false, null, errorMessage, null);\n        }\n    }\n}\n```\n\n```csharp\n// Settings/DownloadSettings.cs\nusing System.Collections.Generic;\n\nnamespace MyApp.Settings\n{\n    public class DownloadSettings\n    {\n        public List<string> TrustedDomains { get; set; } = new List<string>();\n    }\n}\n```\n\n```csharp\n// Program.cs (excerpt for DI and config)\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApp.Services;\nusing MyApp.Settings;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.Configure<DownloadSettings>(\n    builder.Configuration.GetSection(\"DownloadSettings\"));\n\nbuilder.Services.AddHttpClient(nameof(RemoteFileFetcherService));\nbuilder.Services.AddScoped<IRemoteFileFetcherService, RemoteFileFetcherService>();\n\nbuilder.Services.AddControllers();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\nvar app = builder.Build();\n\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json (excerpt for trusted domains)\n{\n  \"DownloadSettings\": {\n    \"TrustedDomains\": [\n      \"example.com\",\n      \"trustedsource.org\"\n    ]\n  }\n}\n```", "orig": "```csharp\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            // Create an HTTP client\n            var client = new HttpClient();\n\n            // Download the data from the URL\n            var response = await client.GetAsync(url);\n\n            // Check if the request was successful\n            if (!response.IsSuccessStatusCode)\n            {\n                return StatusCode(StatusCodes.Status500InternalServerError);\n            }\n\n            // Read the data from the response\n            var data = await response.Content.ReadAsStringAsync();\n\n            // Return the data\n            return Ok(data);\n        }\n    }\n}\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            // Create an HTTP client\n            var client = new HttpClient();\n\n            // Download the data from the URL\n            var response = await client.GetAsync(url);\n\n            // Check if the request was successful\n            if (!response.IsSuccessStatusCode)\n            {\n                return StatusCode(StatusCodes.Status500InternalServerError);\n            }\n\n            // Read the data from the response\n            var data = await response.Content.ReadAsStringAsync();\n\n            // Return the data\n            return Ok(data);\n        }\n    }\n}\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            // Create an HTTP client\n            var client = new HttpClient();\n\n            // Download the data from the URL\n            var response = await client.GetAsync(url);\n\n            // Check if the request was successful\n            if (!response.IsSuccessStatusCode)\n            {\n                return StatusCode(StatusCodes.Status500InternalServerError);\n            }\n\n            // Read the data from the response\n            var data = await response.Content.ReadAsStringAsync();\n\n            // Return the data\n            return Ok(data);\n        }\n    }\n}\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            // Create an HTTP client\n            var client = new HttpClient();\n\n            // Download the data from the URL\n            var response = await client.GetAsync(url);\n\n            // Check if the request was successful\n            if (!response.IsSuccessStatusCode)\n            {\n                return StatusCode(StatusCodes.Status500InternalServerError);\n            }\n\n            // Read the data from the response\n            var data = await response.Content.ReadAsStringAsync();\n\n            // Return the data\n            return Ok(data);\n        }\n    }\n}\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            // Create an HTTP client\n            var client = new HttpClient();\n\n            // Download the data from the URL\n            var response = await client.GetAsync(url);\n\n            // Check if the request was successful\n            if (!response.IsSuccessStatusCode)\n            {\n                return StatusCode(StatusCodes.Status500InternalServerError);\n            }\n\n            // Read the data from the response\n            var data = await response.Content.ReadAsStringAsync();\n\n            // Return the data\n            return Ok(data);\n        }\n    }\n}\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            // Create an HTTP client\n            var client = new HttpClient();\n\n            // Download the data from the URL\n            var response = await client.GetAsync(url);\n\n            // Check if the request was successful\n            if (!response.IsSuccessStatusCode)\n            {\n                return StatusCode(StatusCodes.Status500InternalServerError);\n            }\n\n            // Read the data from the response\n            var data = await response.Content.ReadAsStringAsync();\n\n            // Return the data\n            return Ok(data);\n        }\n    }\n}\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            // Create an HTTP client\n            var client = new HttpClient();\n\n            // Download the data from the URL\n            var response = await client.GetAsync(url);\n\n            // Check if the request was successful\n            if (!response.IsSuccessStatusCode)\n            {\n                return StatusCode(StatusCodes.Status500InternalServerError);\n            }\n\n            // Read the data from the response\n            var data = await response.Content.ReadAsStringAsync();\n\n            // Return the data\n            return Ok(data);\n        }\n    }\n}\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            // Create an HTTP client\n            var client = new HttpClient();\n\n            // Download the data from the URL\n            var response = await client.GetAsync(url);\n\n            // Check if the request was successful\n            if (!response.IsSuccessStatusCode)\n            {\n                return StatusCode(StatusCodes.Status500InternalServerError);\n            }\n\n            // Read the data from the response\n            var data = await response.Content.ReadAsStringAsync();\n\n            // Return the data\n            return Ok(data);\n        }\n    }\n}\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            // Create an HTTP client\n            var client = new HttpClient();\n\n            // Download the data from the URL\n            var response = await client.GetAsync(url);\n\n            // Check if the request was successful\n            if (!response.IsSuccessStatusCode)\n            {\n                return StatusCode(StatusCodes.Status500InternalServerError);\n            }\n\n            // Read the data from the response\n            var data = await response.Content.ReadAsStringAsync();\n\n            // Return the data\n            return Ok(data);\n        }\n    }\n}\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            // Create an HTTP client\n            var client = new HttpClient();\n\n            // Download the data from the URL\n            var response = await client.GetAsync(url);\n\n            // Check if the request was successful\n            if (!response.IsSuccessStatusCode)\n            {\n                return StatusCode(StatusCodes.Status500InternalServerError);\n            }\n\n            // Read the data from the response\n            var data = await response.Content.ReadAsStringAsync();\n\n            // Return the data\n            return Ok(data);\n        }\n    }\n}\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            // Create an HTTP client\n            var client = new HttpClient();\n\n            // Download the data from the URL\n            var response = await client.GetAsync(url);\n\n            // Check if the request was successful\n            if (!response.IsSuccessStatusCode)\n            {\n                return StatusCode(StatusCodes.Status500InternalServerError);\n            }\n\n            // Read the data from the response\n            var data = await response.Content.ReadAsStringAsync();\n\n            // Return the data\n            return Ok(data);\n        }\n    }\n}\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            // Create an HTTP client\n            var client = new HttpClient();\n\n            // Download the data from the URL\n            var response = await client.GetAsync(url);\n\n            // Check if the request was successful\n            if (!response.IsSuccessStatusCode)\n            {\n                return StatusCode(StatusCodes.Status500InternalServerError);\n            }\n\n            // Read the data from the response\n            var data = await response.Content.ReadAsStringAsync();\n\n            // Return the data\n            return Ok(data);\n        }\n    }\n}\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            // Create an HTTP client\n            var client = new HttpClient();\n\n            // Download the data from the URL\n            var response = await client.GetAsync(url);\n\n            // Check if the request was successful\n            if (!response.IsSuccessStatusCode)\n            {\n                return StatusCode(StatusCodes.Status500InternalServerError);\n            }\n\n            // Read the data from the response\n            var data = await response.Content.ReadAsStringAsync();\n\n            // Return the data\n            return Ok(data);\n        }\n    }\n}\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            // Create an HTTP client\n            var client = new HttpClient();\n\n            // Download the data from the URL\n            var response = await client.GetAsync(url);\n\n            // Check if the request was successful\n            if (!response.IsSuccessStatusCode)\n            {\n                return StatusCode(StatusCodes.Status500InternalServerError);\n            }\n\n            // Read the data from the response\n            var data = await response.Content.ReadAsStringAsync();\n\n            // Return the data\n            return Ok(data);\n        }\n    }\n}\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            // Create an HTTP client\n            var client = new HttpClient();\n\n            // Download the data from the URL\n            var response = await client.GetAsync(url);\n\n            // Check if the request was successful\n            if (!response.IsSuccessStatusCode)\n            {\n                return StatusCode(StatusCodes.Status500InternalServerError);\n            }\n\n            // Read the data from the response\n            var data = await response.Content.ReadAsStringAsync();\n\n            // Return the data\n            return Ok(data);\n        }\n    }\n}\n```"}
{"prompt": "Compose a C# function to accept a URL from the user and extract data from it.", "response": "```csharp\n// Controllers/UrlController.cs\n\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyWebApi.Services;\nusing MyWebApi.Contracts;\n\n// Policy setup: In Program.cs or Startup.cs, add a policy named \"UrlDataPolicy\" and configure your requirements.\n\nnamespace MyWebApi.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize] // Require authentication for the controller\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlDataService _urlDataService;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IUrlDataService urlDataService, ILogger<UrlController> logger)\n        {\n            _urlDataService = urlDataService;\n            _logger = logger;\n        }\n\n        [HttpPost]\n        [Authorize(Policy = \"UrlDataPolicy\")] // Require a specific policy for this endpoint\n        public async Task<IActionResult> ExtractDataFromUrl([FromBody] ExtractUrlRequest request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Extracting data from URL: {Url}\", request.Url);\n\n                var result = await _urlDataService.FetchScriptDataFromUrlAsync(request.Url);\n\n                if (result == null)\n                {\n                    return NotFound();\n                }\n\n                return Ok(result);\n            }\n            catch (UrlDataServiceException ex)\n            {\n                _logger.LogWarning(\"Failed to extract data from URL: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error extracting data from URL\");\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Contracts/ExtractUrlRequest.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyWebApi.Contracts\n{\n    public class ExtractUrlRequest\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlData.cs\n\nusing System.Text.Json.Serialization;\n\nnamespace MyWebApi.Models\n{\n    public class UrlData\n    {\n        [JsonPropertyName(\"title\")]\n        public string Title { get; set; }\n\n        [JsonPropertyName(\"description\")]\n        public string Description { get; set; }\n\n        [JsonPropertyName(\"image\")]\n        public string Image { get; set; }\n\n        [JsonPropertyName(\"price\")]\n        public decimal? Price { get; set; }\n\n        [JsonPropertyName(\"url\")]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlDataService.cs\n\nusing System.Threading.Tasks;\nusing MyWebApi.Models;\n\nnamespace MyWebApi.Services\n{\n    public interface IUrlDataService\n    {\n        Task<UrlData> FetchScriptDataFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlDataServiceException.cs\n\nusing System;\n\nnamespace MyWebApi.Services\n{\n    public class UrlDataServiceException : Exception\n    {\n        public UrlDataServiceException(string message) : base(message) { }\n        public UrlDataServiceException(string message, Exception inner) : base(message, inner) { }\n    }\n}\n```\n\n```csharp\n// Services/UrlDataService.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyWebApi.Models;\n\nnamespace MyWebApi.Services\n{\n    public class UrlDataService : IUrlDataService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlDataService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlDataService(IHttpClientFactory httpClientFactory, IConfiguration config, ILogger<UrlDataService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _trustedDomains = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n            var trustedDomains = config.GetSection(\"TrustedDomains\").Get<string[]>();\n            if (trustedDomains != null)\n            {\n                foreach (var domain in trustedDomains)\n                {\n                    _trustedDomains.Add(domain.Trim());\n                }\n            }\n        }\n\n        public async Task<UrlData> FetchScriptDataFromUrlAsync(string url)\n        {\n            Uri uri;\n            try\n            {\n                uri = new Uri(url);\n            }\n            catch\n            {\n                throw new UrlDataServiceException(\"URL is not well-formed.\");\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlDataServiceException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            string host = uri.Host;\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new UrlDataServiceException(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                throw new UrlDataServiceException(\"Failed to resolve host.\");\n            }\n\n            var validIp = GetFirstValidPublicIp(addresses);\n            if (validIp == null)\n            {\n                throw new UrlDataServiceException(\"No valid public IP found for host.\");\n            }\n\n            var client = _httpClientFactory.CreateClient();\n            client.BaseAddress = new Uri($\"{uri.Scheme}://{uri.Host}\");\n\n            var requestUri = uri.PathAndQuery;\n            var request = new HttpRequestMessage(HttpMethod.Get, requestUri);\n\n            // Connect using the resolved IP, but preserve the Host header for HTTPS SNI\n            client.DefaultRequestHeaders.Host = uri.Host;\n\n            try\n            {\n                using var response = await client.SendAsync(request);\n                if (!response.IsSuccessStatusCode)\n                {\n                    throw new UrlDataServiceException(\"Failed to fetch data from URL.\");\n                }\n\n                var html = await response.Content.ReadAsStringAsync();\n\n                var scriptDataJson = ExtractDataFromHtml(html);\n                if (scriptDataJson == null)\n                {\n                    throw new UrlDataServiceException(\"Script data not found in HTML.\");\n                }\n\n                var urlData = JsonSerializer.Deserialize<UrlData>(scriptDataJson);\n                return urlData;\n            }\n            catch (Exception ex) when (ex is not UrlDataServiceException)\n            {\n                _logger.LogError(ex, \"Error fetching or parsing data from URL\");\n                throw new UrlDataServiceException(\"Unexpected error fetching data from URL.\");\n            }\n        }\n\n        private static string ExtractDataFromHtml(string html)\n        {\n            var pattern = @\"<script>\\s*var data\\s*=\\s*(\\{.*?\\});\\s*</script>\";\n            var match = Regex.Match(html, pattern, RegexOptions.Singleline | RegexOptions.IgnoreCase);\n\n            if (!match.Success)\n            {\n                return null;\n            }\n\n            var json = match.Groups[1].Value;\n            return json;\n        }\n\n        private static IPAddress GetFirstValidPublicIp(IPAddress[] addresses)\n        {\n            foreach (var ip in addresses)\n            {\n                if (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6)\n                {\n                    if (!IsPrivateOrReservedIp(ip))\n                    {\n                        return ip;\n                    }\n                }\n            }\n            return null;\n        }\n\n        private static bool IsPrivateOrReservedIp(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var b = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (b[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (b[0] == 172 && b[1] >= 16 && b[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (b[0] == 192 && b[1] == 168)\n                {\n                    return true;\n                }\n                // Link-local 169.254.0.0/16\n                if (b[0] == 169 && b[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyWebApi.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IUrlDataService, UrlDataService>();\n\n// Configure your policy here\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"UrlDataPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        // Add further requirements as needed\n    });\n});\n\nbuilder.Configuration.AddJsonFile(\"appsettings.json\", optional: true);\n\nvar app = builder.Build();\n\napp.UseHttpsRedirection();\napp.UseRouting();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```json\n// appsettings.json\n\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"trustedsource.org\"\n  ]\n}\n```\n", "orig": "```csharp\n// Controllers/UrlController.cs\n\nusing System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyWebApi.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpPost]\n        public async Task<IActionResult> ExtractDataFromUrl(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            var httpClient = new HttpClient();\n            var response = await httpClient.GetAsync(url);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                return BadRequest(\"Unable to fetch data from URL\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n            var data = ExtractDataFromHtml(content);\n\n            return Ok(data);\n        }\n\n        private static string ExtractDataFromHtml(string html)\n        {\n            var pattern = @\"<script>var data = \\{.*?};</script>\";\n            var matches = Regex.Matches(html, pattern);\n\n            if (matches.Count == 0)\n            {\n                return null;\n            }\n\n            var match = matches[0];\n            var data = match.Value.Split(\"var data = \")[1].Split(\";\")[0];\n            return data;\n        }\n    }\n}\n\n// Models/UrlData.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Text.Json.Serialization;\n\nnamespace MyWebApi.Models\n{\n    public class UrlData\n    {\n        [JsonPropertyName(\"title\")]\n        public string Title { get; set; }\n\n        [JsonPropertyName(\"description\")]\n        public string Description { get; set; }\n\n        [JsonPropertyName(\"image\")]\n        public string Image { get; set; }\n\n        [JsonPropertyName(\"price\")]\n        public decimal Price { get; set; }\n\n        [JsonPropertyName(\"url\")]\n        public string Url { get; set; }\n    }\n}\n\n// Services/UrlDataService.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing MyWebApi.Models;\n\nnamespace MyWebApi.Services\n{\n    public class UrlDataService\n    {\n        public UrlDataService()\n        {\n        }\n\n        public UrlData GetDataFromUrl(string url)\n        {\n            var httpClient = new HttpClient();\n            var response = httpClient.GetAsync(url).Result;\n\n            if (!response.IsSuccessStatusCode)\n            {\n                return null;\n            }\n\n            var content = response.Content.ReadAsStringAsync().Result;\n            var data = JsonSerializer.Deserialize<UrlData>(content);\n\n            return data;\n        }\n    }\n}\n\n// Startup.cs\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyWebApi\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddScoped<UrlDataService>();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```"}
{"prompt": "Compose a C# function that accepts a URL parameter and downloads the associated data.", "response": "```csharp\n// Controllers/DownloadController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, call in Program.cs: \n    // builder.Services.AddAuthorization(options => { options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser()); });\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"DownloadPolicy\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly ILogger<DownloadController> _logger;\n        private readonly DownloadUrlValidator _urlValidator;\n        private readonly IHttpClientFactory _httpClientFactory;\n\n        public DownloadController(\n            ILogger<DownloadController> logger,\n            DownloadUrlValidator urlValidator,\n            IHttpClientFactory httpClientFactory)\n        {\n            _logger = logger;\n            _urlValidator = urlValidator;\n            _httpClientFactory = httpClientFactory;\n        }\n\n        [HttpPost(\"download\")]\n        [Authorize(Policy = \"DownloadPolicy\")]\n        public async Task<IActionResult> Download([FromBody] DownloadModel model)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid URL format.\" });\n            }\n\n            try\n            {\n                var validationResult = await _urlValidator.ValidateUrlAsync(model.Url);\n                if (!validationResult.IsValid)\n                {\n                    _logger.LogWarning(\"Download failed validation for URL: {Url} Reason: {Reason}\", model.Url, validationResult.Reason);\n                    return BadRequest(new { error = validationResult.Reason });\n                }\n\n                var client = _httpClientFactory.CreateClient(\"SafeDownload\");\n                var response = await client.GetAsync(validationResult.FinalUri);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to download from: {Url} Status: {StatusCode}\", model.Url, response.StatusCode);\n                    return NotFound();\n                }\n\n                var content = await response.Content.ReadAsByteArrayAsync();\n                var contentType = response.Content.Headers.ContentType?.MediaType ?? \"application/octet-stream\";\n                var fileName = Path.GetFileName(validationResult.FinalUri.LocalPath);\n\n                _logger.LogInformation(\"Successfully downloaded file from: {Url}\", model.Url);\n                return File(content, contentType, fileName);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during download from: {Url}\", model.Url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/DownloadModel.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class DownloadModel\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlValidationResult.cs\nnamespace MyApp.Models\n{\n    public class UrlValidationResult\n    {\n        public bool IsValid { get; init; }\n        public string Reason { get; init; }\n        public System.Uri FinalUri { get; init; }\n    }\n}\n```\n\n```csharp\n// Services/DownloadUrlValidator.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing MyApp.Models;\n\nnamespace MyApp\n{\n    public class DownloadUrlValidator\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public DownloadUrlValidator(IConfiguration configuration)\n        {\n            var trusted = configuration.GetSection(\"Download:TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(trusted.Select(d => d.ToLowerInvariant()));\n        }\n\n        public async Task<UrlValidationResult> ValidateUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return new UrlValidationResult { IsValid = false, Reason = \"Malformed URL.\" };\n            }\n\n            if (!string.Equals(uri.Scheme, \"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                return new UrlValidationResult { IsValid = false, Reason = \"Only HTTPS URLs are allowed.\" };\n            }\n\n            string host = uri.Host;\n            if (!_trustedDomains.Contains(host.ToLowerInvariant()))\n            {\n                return new UrlValidationResult { IsValid = false, Reason = \"Untrusted domain.\" };\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                return new UrlValidationResult { IsValid = false, Reason = \"DNS resolution failed.\" };\n            }\n\n            foreach (var ip in addresses)\n            {\n                if (IsPrivateOrLoopback(ip))\n                {\n                    return new UrlValidationResult { IsValid = false, Reason = \"IP address is private, loopback, or link-local.\" };\n                }\n            }\n\n            return new UrlValidationResult { IsValid = true, FinalUri = uri };\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n                if (ip.IsIPv6Multicast || ip.IsIPv6Teredo)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing MyApp;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient(\"SafeDownload\");\nbuilder.Services.AddSingleton<DownloadUrlValidator>();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n    });\n});\n\n// Configure authentication here as needed, e.g. JWT Bearer, etc.\n// builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(...);\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n}\n\napp.UseHttpsRedirection();\n\napp.UseRouting();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"Download\": {\n    \"TrustedDomains\": [\n      \"example.com\",\n      \"trustedsite.org\"\n    ]\n  }\n}\n```", "orig": "```csharp\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public IActionResult Download(string url)\n        {\n            // Implement download logic here\n            // ...\n\n            return Ok();\n        }\n    }\n}\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class DownloadModel\n    {\n        [Required]\n        public string Url { get; set; }\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApp\n{\n    public class LaunchSettings\n    {\n        public LaunchSettings(IConfiguration configuration)\n        {\n            var env = configuration[\"ASPNETCORE_ENVIRONMENT\"];\n            var profiles = configuration.GetSection(\"profiles\").GetChildren();\n\n            Profiles = profiles.ToDictionary(\n                p => p.Key,\n                p => new Profile\n                {\n                    CommandName = p[\"commandName\"],\n                    LaunchBrowser = p[\"launchBrowser\"],\n                    EnvironmentVariables = p.GetSection(\"environmentVariables\").GetChildren().ToDictionary(\n                        e => e.Key,\n                        e => e.Value\n                    )\n                });\n        }\n\n        public Dictionary<string, Profile> Profiles { get; }\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp.Startup\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public IActionResult Download(string url)\n        {\n            // Implement download logic here\n            // ...\n\n            return Ok();\n        }\n    }\n}\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class DownloadModel\n    {\n        [Required]\n        public string Url { get; set; }\n    }\n}\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApp\n{\n    public class LaunchSettings\n    {\n        public LaunchSettings(IConfiguration configuration)\n        {\n            var env = configuration[\"ASPNETCORE_ENVIRONMENT\"];\n            var profiles = configuration.GetSection(\"profiles\").GetChildren();\n\n            Profiles = profiles.ToDictionary(\n                p => p.Key,\n                p => new Profile\n                {\n                    CommandName = p[\"commandName\"],\n                    LaunchBrowser = p[\"launchBrowser\"],\n                    EnvironmentVariables = p.GetSection(\"environmentVariables\").GetChildren().ToDictionary(\n                        e => e.Key,\n                        e => e.Value\n                    )\n                });\n        }\n\n        public Dictionary<string, Profile> Profiles { get; }\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp.Startup\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public IActionResult Download(string url)\n        {\n            // Implement download logic here\n            // ...\n\n            return Ok();\n        }\n    }\n}\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class DownloadModel\n    {\n        [Required]\n        public string Url { get; set; }\n    }\n}\n```"}
{"prompt": "Write a C# method to take in a URL provided by the user and extract its data.", "response": "```csharp\n// Controllers/UrlController.cs\nusing System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing MyApp.Contracts;\n\n// Policy setup: services.AddAuthorization(options => options.AddPolicy(\"UrlSubmissionPolicy\", policy => policy.RequireAuthenticatedUser()));\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"UrlSubmissionPolicy\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly ILogger<UrlController> _logger;\n        private readonly IUrlMetadataService _urlMetadataService;\n        private readonly IUrlRepository _urlRepository;\n\n        public UrlController(\n            ILogger<UrlController> logger,\n            IUrlMetadataService urlMetadataService,\n            IUrlRepository urlRepository)\n        {\n            _logger = logger;\n            _urlMetadataService = urlMetadataService;\n            _urlRepository = urlRepository;\n        }\n\n        [HttpPost]\n        [Authorize(Policy = \"UrlSubmissionPolicy\")]\n        public async Task<IActionResult> Post([FromBody] UrlSubmissionRequest request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Processing URL submission for {Url}\", request.Url);\n\n                var existing = await _urlRepository.GetByUrlAsync(request.Url);\n                if (existing != null)\n                {\n                    _logger.LogInformation(\"Url already exists in database.\");\n                    return Ok(new UrlDataResponse(existing));\n                }\n\n                var metadataResult = await _urlMetadataService.FetchMetadataAsync(request.Url);\n                if (!metadataResult.Success)\n                {\n                    _logger.LogWarning(\"Failed to fetch metadata: {Reason}\", metadataResult.FailureReason);\n                    return BadRequest(new { error = metadataResult.FailureReason });\n                }\n\n                var urlData = new UrlData\n                {\n                    Url = request.Url,\n                    Title = metadataResult.Title,\n                    Description = metadataResult.Description\n                };\n\n                await _urlRepository.AddAsync(urlData);\n\n                _logger.LogInformation(\"Url successfully saved.\");\n\n                return Ok(new UrlDataResponse(urlData));\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to process URL submission.\");\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Contracts/UrlSubmissionRequest.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Contracts\n{\n    public class UrlSubmissionRequest\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Contracts/UrlDataResponse.cs\nnamespace MyApp.Contracts\n{\n    public class UrlDataResponse\n    {\n        public UrlDataResponse(Models.UrlData data)\n        {\n            Url = data.Url;\n            Title = data.Title;\n            Description = data.Description;\n        }\n\n        public string Url { get; }\n        public string Title { get; }\n        public string Description { get; }\n    }\n}\n```\n\n```csharp\n// Contracts/UrlMetadataResult.cs\nnamespace MyApp.Contracts\n{\n    public class UrlMetadataResult\n    {\n        private UrlMetadataResult() { }\n\n        public bool Success { get; private set; }\n        public string Title { get; private set; }\n        public string Description { get; private set; }\n        public string FailureReason { get; private set; }\n\n        public static UrlMetadataResult Failure(string reason)\n        {\n            return new UrlMetadataResult\n            {\n                Success = false,\n                FailureReason = reason\n            };\n        }\n\n        public static UrlMetadataResult SuccessResult(string title, string description)\n        {\n            return new UrlMetadataResult\n            {\n                Success = true,\n                Title = title,\n                Description = description\n            };\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlData.cs\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        public int Id { get; set; }\n        public string Url { get; set; }\n        public string Title { get; set; }\n        public string Description { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/MyAppContext.cs\nusing Microsoft.EntityFrameworkCore;\n\nnamespace MyApp.Models\n{\n    public class MyAppContext : DbContext\n    {\n        public MyAppContext(DbContextOptions<MyAppContext> options)\n            : base(options)\n        {\n        }\n\n        public DbSet<UrlData> Urls { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlRepository.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IUrlRepository\n    {\n        Task<UrlData> GetByUrlAsync(string url);\n        Task AddAsync(UrlData urlData);\n    }\n}\n```\n\n```csharp\n// Services/UrlRepository.cs\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class UrlRepository : IUrlRepository\n    {\n        private readonly MyAppContext _context;\n\n        public UrlRepository(MyAppContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<UrlData> GetByUrlAsync(string url)\n        {\n            return await _context.Urls.FirstOrDefaultAsync(u => u.Url == url);\n        }\n\n        public async Task AddAsync(UrlData urlData)\n        {\n            _context.Urls.Add(urlData);\n            await _context.SaveChangesAsync();\n        }\n    }\n}\n```\n\n```csharp\n// Services/IUrlMetadataService.cs\nusing System.Threading.Tasks;\nusing MyApp.Contracts;\n\nnamespace MyApp.Services\n{\n    public interface IUrlMetadataService\n    {\n        Task<UrlMetadataResult> FetchMetadataAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlMetadataService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing HtmlAgilityPack;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Contracts;\n\nnamespace MyApp.Services\n{\n    public class UrlMetadataService : IUrlMetadataService\n    {\n        private readonly ILogger<UrlMetadataService> _logger;\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlMetadataService(\n            ILogger<UrlMetadataService> logger,\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration)\n        {\n            _logger = logger;\n            _httpClientFactory = httpClientFactory;\n            _trustedDomains = configuration\n                .GetSection(\"TrustedDomains\")\n                .Get<string[]>()?\n                .Select(d => d.ToLowerInvariant())\n                .ToHashSet() ?? new HashSet<string>();\n        }\n\n        public async Task<UrlMetadataResult> FetchMetadataAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return UrlMetadataResult.Failure(\"Malformed URL.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return UrlMetadataResult.Failure(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (!_trustedDomains.Contains(uri.Host.ToLowerInvariant()))\n            {\n                return UrlMetadataResult.Failure(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] resolved;\n            try\n            {\n                resolved = await Dns.GetHostAddressesAsync(uri.Host);\n            }\n            catch\n            {\n                return UrlMetadataResult.Failure(\"Failed to resolve host.\");\n            }\n\n            if (resolved.Length == 0)\n            {\n                return UrlMetadataResult.Failure(\"No IP addresses found for host.\");\n            }\n\n            foreach (var ip in resolved)\n            {\n                if (IsPrivateOrLoopback(ip))\n                {\n                    return UrlMetadataResult.Failure(\"IP address is not allowed.\");\n                }\n            }\n\n            var httpClient = _httpClientFactory.CreateClient(\"UrlMetadataFetcher\");\n            httpClient.Timeout = TimeSpan.FromSeconds(10);\n\n            HttpResponseMessage response;\n            try\n            {\n                var builder = new UriBuilder(uri)\n                {\n                    Host = resolved[0].ToString()\n                };\n                httpClient.DefaultRequestHeaders.Host = uri.Host;\n\n                response = await httpClient.GetAsync(builder.Uri);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"HTTP fetch failed for {Url}\", url);\n                return UrlMetadataResult.Failure(\"Failed to fetch URL.\");\n            }\n\n            if (response.StatusCode != HttpStatusCode.OK)\n            {\n                return UrlMetadataResult.Failure(\"Failed to retrieve content.\");\n            }\n\n            string content;\n            try\n            {\n                content = await response.Content.ReadAsStringAsync();\n            }\n            catch\n            {\n                return UrlMetadataResult.Failure(\"Failed to read response content.\");\n            }\n\n            var title = ExtractTitle(content);\n            var description = ExtractDescription(content);\n\n            return UrlMetadataResult.SuccessResult(title, description);\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip)) return true;\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10) return true;\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) return true;\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168) return true;\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254) return true;\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal || ip.IsIPv6Teredo) return true;\n            }\n            return false;\n        }\n\n        private static string ExtractTitle(string html)\n        {\n            var doc = new HtmlDocument();\n            doc.LoadHtml(html);\n            var node = doc.DocumentNode.SelectSingleNode(\"//title\");\n            return node?.InnerText?.Trim() ?? string.Empty;\n        }\n\n        private static string ExtractDescription(string html)\n        {\n            var doc = new HtmlDocument();\n            doc.LoadHtml(html);\n            var node = doc.DocumentNode.SelectSingleNode(\"//meta[@name='description']\");\n            return node?.GetAttributeValue(\"content\", string.Empty) ?? string.Empty;\n        }\n    }\n}\n```\n\n```csharp\n// Startup.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Models;\nusing MyApp.Services;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n\n            services.AddDbContext<MyAppContext>(options =>\n                options.UseSqlServer(Configuration.GetConnectionString(\"MyAppContext\", \"Server=(localdb)\\\\mssqllocaldb;Database=MyAppDb;Trusted_Connection=True;\")));\n\n            services.AddScoped<IUrlRepository, UrlRepository>();\n            services.AddScoped<IUrlMetadataService, UrlMetadataService>();\n\n            services.AddHttpClient(\"UrlMetadataFetcher\");\n\n            services.AddAuthorization(options =>\n            {\n                options.AddPolicy(\"UrlSubmissionPolicy\", policy =>\n                {\n                    policy.RequireAuthenticatedUser();\n                });\n            });\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"ConnectionStrings\": {\n    \"MyAppContext\": \"Server=(localdb)\\\\mssqllocaldb;Database=MyAppDb;Trusted_Connection=True;\"\n  },\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"trustedsite.org\"\n  ]\n}\n```\n", "orig": "```csharp\n// Controllers/UrlController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Rendering;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly ILogger<UrlController> _logger;\n        private readonly MyAppContext _context;\n\n        public UrlController(ILogger<UrlController> logger, MyAppContext context)\n        {\n            _logger = logger;\n            _context = context;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Post([FromBody] string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            var urlData = await GetUrlData(url);\n\n            if (urlData == null)\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            _context.Urls.Add(urlData);\n            await _context.SaveChangesAsync();\n\n            return Ok(urlData);\n        }\n\n        private async Task<UrlData> GetUrlData(string url)\n        {\n            var urlData = _context.Urls.FirstOrDefault(u => u.Url == url);\n\n            if (urlData != null)\n            {\n                return urlData;\n            }\n\n            var httpClient = new HttpClient();\n            var response = await httpClient.GetAsync(url);\n\n            if (response.StatusCode == HttpStatusCode.OK)\n            {\n                var content = await response.Content.ReadAsStringAsync();\n                var title = GetTitle(content);\n                var description = GetDescription(content);\n\n                urlData = new UrlData\n                {\n                    Url = url,\n                    Title = title,\n                    Description = description\n                };\n            }\n\n            return urlData;\n        }\n\n        private string GetTitle(string content)\n        {\n            var title = content.Split(new[] { \"<title>\" }, StringSplitOptions.None)[1];\n            title = title.Split(new[] { \"</title>\" }, StringSplitOptions.None)[0];\n            return title;\n        }\n\n        private string GetDescription(string content)\n        {\n            var description = content.Split(new[] { \"<meta name=\\\"description\\\" content=\\\"\" }, StringSplitOptions.None)[1];\n            description = description.Split(new[] { \"\\\"\" }, StringSplitOptions.None)[0];\n            return description;\n        }\n    }\n}\n\n// Models/UrlData.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        public string Url { get; set; }\n        public string Title { get; set; }\n        public string Description { get; set; }\n    }\n}\n\n// Startup.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddDbContext<MyAppContext>(options =>\n                options.UseSqlServer(Configuration.GetConnectionString(\"MyAppContext\")));\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\n// Program.cs\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\n// MyAppContext.cs\nusing Microsoft.EntityFrameworkCore;\n\nnamespace MyApp.Models\n{\n    public class MyAppContext : DbContext\n    {\n        public MyAppContext(DbContextOptions<MyAppContext> options)\n            : base(options)\n        {\n        }\n\n        public DbSet<UrlData> Urls { get; set; }\n    }\n}\n```"}
{"prompt": "Compose a C# function to accept a URL input and download the resource content.", "response": "```csharp\n// Controllers/DownloadController.cs\n\nusing System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing MyApp.Models;\n\n// Policy setup: In Program.cs or Startup.cs, set up a policy named \"DownloadPolicy\" as needed.\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"DownloadPolicy\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IDownloadService _downloadService;\n        private readonly ILogger<DownloadController> _logger;\n\n        public DownloadController(IDownloadService downloadService, ILogger<DownloadController> logger)\n        {\n            _downloadService = downloadService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"DownloadPolicy\")]\n        public async Task<IActionResult> Download([FromQuery] DownloadFileRequestDto requestDto)\n        {\n            _logger.LogInformation(\"Download requested for URL: {Url}\", requestDto.Url);\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var result = await _downloadService.FetchFileFromUrlAsync(requestDto.Url);\n\n                if (!result.IsSuccess)\n                {\n                    _logger.LogWarning(\"File download failed for URL: {Url}. Reason: {Reason}\", requestDto.Url, result.ErrorMessage);\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n\n                _logger.LogInformation(\"File download succeeded for URL: {Url}\", requestDto.Url);\n\n                return File(result.FileContent, result.ContentType, result.FileName);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error downloading file from URL: {Url}\", requestDto.Url);\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/IDownloadService.cs\n\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IDownloadService\n    {\n        Task<DownloadFileResult> FetchFileFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/DownloadService.cs\n\nusing System;\nusing System.IO;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing System.Net;\nusing System.Net.Sockets;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class DownloadService : IDownloadService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<DownloadService> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly string[] _trustedDomains;\n\n        public DownloadService(IHttpClientFactory httpClientFactory, ILogger<DownloadService> logger, IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomains = _configuration.GetSection(\"TrustedDownloadDomains\").Get<string[]>() ?? Array.Empty<string>();\n        }\n\n        public async Task<DownloadFileResult> FetchFileFromUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return DownloadFileResult.Failure(\"URL is not valid.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return DownloadFileResult.Failure(\"URL must use HTTPS.\");\n            }\n\n            if (uri.HostNameType == UriHostNameType.Dns)\n            {\n                if (_trustedDomains.Length == 0 || !_trustedDomains.Any(d => string.Equals(d, uri.Host, StringComparison.OrdinalIgnoreCase)))\n                {\n                    return DownloadFileResult.Failure(\"Host is not trusted.\");\n                }\n\n                try\n                {\n                    var hostAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n\n                    if (!hostAddresses.Any())\n                    {\n                        return DownloadFileResult.Failure(\"Could not resolve host.\");\n                    }\n\n                    foreach (var ip in hostAddresses)\n                    {\n                        if (IsPrivateOrLoopback(ip))\n                        {\n                            return DownloadFileResult.Failure(\"Host resolves to an untrusted IP address.\");\n                        }\n                    }\n\n                    // Use the first valid address for the request\n                    var ipAddress = hostAddresses.First(ip => !IsPrivateOrLoopback(ip));\n                    return await DownloadByIpAsync(uri, ipAddress);\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogWarning(ex, \"DNS resolution failed for host: {Host}\", uri.Host);\n                    return DownloadFileResult.Failure(\"DNS resolution failed.\");\n                }\n            }\n            else if (uri.HostNameType == UriHostNameType.IPv4 || uri.HostNameType == UriHostNameType.IPv6)\n            {\n                if (IsPrivateOrLoopback(IPAddress.Parse(uri.Host)))\n                {\n                    return DownloadFileResult.Failure(\"IP address is not allowed.\");\n                }\n\n                return await DownloadByIpAsync(uri, IPAddress.Parse(uri.Host));\n            }\n            else\n            {\n                return DownloadFileResult.Failure(\"Unsupported host type.\");\n            }\n        }\n\n        private async Task<DownloadFileResult> DownloadByIpAsync(Uri uri, IPAddress ipAddress)\n        {\n            var handler = new SocketsHttpHandler\n            {\n                ConnectCallback = async (context, token) =>\n                {\n                    var socket = new Socket(ipAddress.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                    await socket.ConnectAsync(ipAddress, uri.Port, token);\n                    return new NetworkStream(socket, ownsSocket: true);\n                }\n            };\n\n            var client = new HttpClient(handler, disposeHandler: true)\n            {\n                Timeout = TimeSpan.FromSeconds(_configuration.GetValue<int>(\"DownloadFileTimeoutSeconds\", 30))\n            };\n\n            var request = new HttpRequestMessage(HttpMethod.Get, uri);\n            request.Headers.Host = uri.Host;\n\n            try\n            {\n                using var response = await client.SendAsync(request);\n                if (!response.IsSuccessStatusCode)\n                {\n                    return DownloadFileResult.Failure(\"Failed to fetch file from remote server.\");\n                }\n\n                var fileContent = await response.Content.ReadAsByteArrayAsync();\n                var contentType = response.Content.Headers.ContentType?.MediaType ?? \"application/octet-stream\";\n                var fileName = Path.GetFileName(uri.LocalPath);\n                if (string.IsNullOrWhiteSpace(fileName))\n                {\n                    fileName = \"file\";\n                }\n\n                return DownloadFileResult.Success(fileContent, contentType, fileName);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Error downloading file from {Uri}\", uri);\n                return DownloadFileResult.Failure(\"Error occurred while downloading file.\");\n            }\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6None))\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Models/DownloadFileRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class DownloadFileRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/DownloadFileResult.cs\n\nnamespace MyApp.Models\n{\n    public class DownloadFileResult\n    {\n        public bool IsSuccess { get; }\n        public string ErrorMessage { get; }\n        public byte[] FileContent { get; }\n        public string ContentType { get; }\n        public string FileName { get; }\n\n        private DownloadFileResult(bool isSuccess, byte[] fileContent, string contentType, string fileName, string errorMessage)\n        {\n            IsSuccess = isSuccess;\n            FileContent = fileContent;\n            ContentType = contentType;\n            FileName = fileName;\n            ErrorMessage = errorMessage;\n        }\n\n        public static DownloadFileResult Success(byte[] fileContent, string contentType, string fileName)\n        {\n            return new DownloadFileResult(true, fileContent, contentType, fileName, null);\n        }\n\n        public static DownloadFileResult Failure(string errorMessage)\n        {\n            return new DownloadFileResult(false, null, null, null, errorMessage);\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/DownloadController.cs\n\nusing System;\nusing System.IO;\nusing System.Net;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> Download(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest(\"Url is required\");\n            }\n\n            try\n            {\n                var request = WebRequest.Create(url);\n                var response = await request.GetResponseAsync();\n                var stream = response.GetResponseStream();\n                var buffer = new byte[1024 * 1024];\n                var length = (int)response.ContentLength;\n                var total = 0;\n                var output = new MemoryStream();\n\n                while (true)\n                {\n                    var read = stream.Read(buffer, 0, buffer.Length);\n                    if (read == 0)\n                    {\n                        break;\n                    }\n\n                    output.Write(buffer, 0, read);\n                    total += read;\n                }\n\n                return File(output.ToArray(), response.ContentType, response.ResponseUri.Segments.Last());\n            }\n            catch (Exception e)\n            {\n                return StatusCode(500, $\"Failed to download file: {e.Message}\");\n            }\n        }\n    }\n}\n```"}
{"prompt": "Develop a C# method to receive a URL input and fetch the corresponding resource data.", "response": "```csharp\n// Controllers/ResourceController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: In Startup/Program, add policy \"CanAccessResources\"\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"CanAccessResources\")]\n    public class ResourceController : ControllerBase\n    {\n        private readonly IResourceService _resourceService;\n        private readonly ILogger<ResourceController> _logger;\n\n        public ResourceController(IResourceService resourceService, ILogger<ResourceController> logger)\n        {\n            _resourceService = resourceService;\n            _logger = logger;\n        }\n\n        [HttpGet(\"{url}\")]\n        [Authorize(Policy = \"CanAccessResources\")]\n        public async Task<IActionResult> GetResourceData([FromRoute] string url)\n        {\n            try\n            {\n                var request = new ResourceFetchRequest { Url = url };\n                if (!request.IsValid(out var validationError))\n                {\n                    _logger.LogWarning(\"Invalid resource URL input\");\n                    return BadRequest(new { error = validationError });\n                }\n\n                var result = await _resourceService.GetResourceDataAsync(request);\n\n                if (result == null)\n                {\n                    _logger.LogWarning(\"Resource not found or forbidden for input URL\");\n                    return NotFound();\n                }\n\n                _logger.LogInformation(\"Successfully fetched resource for input URL\");\n                return File(result.Data, result.ContentType);\n            }\n            catch (ResourceFetchException ex)\n            {\n                _logger.LogWarning(\"Resource fetch failed: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to get resource data\");\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/ResourceFetchRequest.cs\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing System.Linq;\nusing System.Net;\nusing System.Text.RegularExpressions;\n\nnamespace MyApp.Models\n{\n    public class ResourceFetchRequest\n    {\n        public string Url { get; set; }\n\n        private static readonly string[] TrustedDomains = new[]\n        {\n            \"TRUSTED1.EXAMPLE.COM\",\n            \"TRUSTED2.EXAMPLE.ORG\"\n        };\n\n        public bool IsValid(out string error)\n        {\n            error = null;\n            if (string.IsNullOrWhiteSpace(Url))\n            {\n                error = \"URL is required.\";\n                return false;\n            }\n\n            if (!Uri.TryCreate(Url, UriKind.Absolute, out var uri))\n            {\n                error = \"URL is not a valid absolute URI.\";\n                return false;\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                error = \"URL must use HTTPS.\";\n                return false;\n            }\n\n            if (string.IsNullOrWhiteSpace(uri.Host))\n            {\n                error = \"URL must have a valid host.\";\n                return false;\n            }\n\n            var trusted = TrustedDomains.Any(d => string.Equals(d, uri.Host, StringComparison.OrdinalIgnoreCase));\n            if (!trusted)\n            {\n                error = \"Domain is not trusted.\";\n                return false;\n            }\n\n            try\n            {\n                var hostAddresses = Dns.GetHostAddresses(uri.Host);\n\n                foreach (var ip in hostAddresses)\n                {\n                    if (IsPrivateOrLoopback(ip))\n                    {\n                        error = \"IP address is private, loopback, or link-local.\";\n                        return false;\n                    }\n                }\n            }\n            catch\n            {\n                error = \"DNS resolution failed.\";\n                return false;\n            }\n\n            return true;\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10) return true;\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) return true;\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168) return true;\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254) return true;\n            }\n            else if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal || ip.IsIPv6Teredo) return true;\n                if (ip.Equals(IPAddress.IPv6Loopback)) return true;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Models/ResourceFetchResult.cs\nnamespace MyApp.Models\n{\n    public class ResourceFetchResult\n    {\n        public byte[] Data { get; set; }\n        public string ContentType { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IResourceService.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IResourceService\n    {\n        Task<ResourceFetchResult> GetResourceDataAsync(ResourceFetchRequest request);\n    }\n}\n```\n\n```csharp\n// Services/ResourceService.cs\nusing System;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class ResourceService : IResourceService\n    {\n        private readonly ILogger<ResourceService> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly IHttpClientFactory _httpClientFactory;\n\n        public ResourceService(\n            ILogger<ResourceService> logger,\n            IConfiguration configuration,\n            IHttpClientFactory httpClientFactory)\n        {\n            _logger = logger;\n            _configuration = configuration;\n            _httpClientFactory = httpClientFactory;\n        }\n\n        public async Task<ResourceFetchResult> GetResourceDataAsync(ResourceFetchRequest request)\n        {\n            if (!request.IsValid(out var validationError))\n            {\n                throw new ResourceFetchException(validationError);\n            }\n\n            var uri = new Uri(request.Url);\n\n            IPAddress[] hostAddresses;\n            try\n            {\n                hostAddresses = Dns.GetHostAddresses(uri.Host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host {Host}\", uri.Host);\n                throw new ResourceFetchException(\"DNS resolution failed.\");\n            }\n\n            var validIp = hostAddresses.FirstOrDefault(ip => !ResourceFetchRequest.IsPrivateOrLoopback(ip));\n            if (validIp == null)\n            {\n                throw new ResourceFetchException(\"No valid public IP address found for host.\");\n            }\n\n            var httpClient = _httpClientFactory.CreateClient(\"ResourceFetcher\");\n            var uriBuilder = new UriBuilder(uri)\n            {\n                Host = validIp.ToString()\n            };\n\n            var requestMessage = new HttpRequestMessage(HttpMethod.Get, uriBuilder.Uri);\n            requestMessage.Headers.Host = uri.Host;\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await httpClient.SendAsync(requestMessage);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed to resource\");\n                throw new ResourceFetchException(\"Failed to fetch resource.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new ResourceFetchException(\"Resource could not be fetched.\");\n            }\n\n            var data = await response.Content.ReadAsByteArrayAsync();\n            var contentType = response.Content.Headers.ContentType?.MediaType ?? \"application/octet-stream\";\n\n            return new ResourceFetchResult\n            {\n                Data = data,\n                ContentType = contentType\n            };\n        }\n    }\n}\n```\n\n```csharp\n// Services/ResourceFetchException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class ResourceFetchException : Exception\n    {\n        public ResourceFetchException(string message) : base(message) { }\n    }\n}\n```\n", "orig": "```csharp\n[HttpGet(\"{url}\")]\npublic async Task<IActionResult> GetResourceData(string url)\n{\n    try\n    {\n        // Fetch the resource data using the URL\n        var resourceData = await _resourceService.GetResourceDataAsync(url);\n\n        // Return the resource data\n        return Ok(resourceData);\n    }\n    catch (Exception ex)\n    {\n        // Log the error and return a 500 status code\n        _logger.LogError(ex, \"Failed to get resource data for URL {url}\", url);\n        return StatusCode(500);\n    }\n}\n```"}
{"prompt": "Write a C# function to receive a URL and extract its content.", "response": "```csharp\n// Controllers/UrlContentController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => options.AddPolicy(\"UrlContentPolicy\", policy => policy.RequireAuthenticatedUser()));\n    [Authorize]\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlContentController : ControllerBase\n    {\n        private readonly IUrlContentService _urlContentService;\n        private readonly ILogger<UrlContentController> _logger;\n\n        public UrlContentController(IUrlContentService urlContentService, ILogger<UrlContentController> logger)\n        {\n            _urlContentService = urlContentService;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"UrlContentPolicy\")]\n        [HttpGet]\n        public async Task<IActionResult> GetUrlContent([FromQuery] UrlContentRequest request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid request\", details = ModelState });\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Fetching content for URL: {Url}\", request.Url);\n                var content = await _urlContentService.FetchContentFromUrlAsync(request.Url);\n                return Ok(new UrlContent { Content = content });\n            }\n            catch (UrlContentNotFoundException ex)\n            {\n                _logger.LogWarning(\"Not found or forbidden: {Message}\", ex.Message);\n                return NotFound(new { error = \"Resource not found or forbidden\" });\n            }\n            catch (UrlContentBadRequestException ex)\n            {\n                _logger.LogWarning(\"Bad request: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error fetching content\");\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlContent.cs\nusing System.Text.Json.Serialization;\n\nnamespace MyApp.Models\n{\n    public class UrlContent\n    {\n        [JsonPropertyName(\"content\")]\n        public string Content { get; init; }\n    }\n}\n```\n\n```csharp\n// Models/UrlContentRequest.cs\nusing System.ComponentModel.DataAnnotations;\nusing System.Text.RegularExpressions;\n\nnamespace MyApp.Models\n{\n    public class UrlContentRequest : IValidatableObject\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n\n        public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)\n        {\n            if (string.IsNullOrWhiteSpace(Url))\n            {\n                yield return new ValidationResult(\"Url is required.\", new[] { nameof(Url) });\n                yield break;\n            }\n\n            if (!Uri.TryCreate(Url, UriKind.Absolute, out var uri))\n            {\n                yield return new ValidationResult(\"Invalid URL format.\", new[] { nameof(Url) });\n                yield break;\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                yield return new ValidationResult(\"Only HTTPS scheme is allowed.\", new[] { nameof(Url) });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/IUrlContentService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlContentService\n    {\n        Task<string> FetchContentFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlContentService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlContentService : IUrlContentService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlContentService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlContentService(\n            IHttpClientFactory httpClientFactory,\n            ILogger<UrlContentService> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<List<string>>()?.Select(d => d.ToLowerInvariant()).ToHashSet() ?? new HashSet<string>();\n        }\n\n        public async Task<string> FetchContentFromUrlAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new UrlContentBadRequestException(\"Url is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlContentBadRequestException(\"Invalid URL format.\");\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlContentBadRequestException(\"Only HTTPS scheme is allowed.\");\n            }\n\n            var host = uri.Host.ToLowerInvariant();\n\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new UrlContentNotFoundException($\"Domain {host} is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for {Host}\", host);\n                throw new UrlContentNotFoundException(\"Could not resolve host.\");\n            }\n\n            var allowedIp = addresses.FirstOrDefault(ip => IsPublicIp(ip));\n            if (allowedIp == null)\n            {\n                throw new UrlContentNotFoundException(\"No public IP found for the host.\");\n            }\n\n            // Rebuild the URI with the resolved IP to ensure the request goes to the correct endpoint\n            var builder = new UriBuilder(uri)\n            {\n                Host = allowedIp.ToString()\n            };\n\n            var requestMessage = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n            requestMessage.Headers.Host = host;\n\n            var client = _httpClientFactory.CreateClient();\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await client.SendAsync(requestMessage);\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(ex, \"Failed to fetch content from {Url}\", url);\n                throw new UrlContentNotFoundException(\"Failed to fetch content.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new UrlContentNotFoundException(\"Resource not found or forbidden.\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n            return content;\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip) || ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return false;\n                }\n            }\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return false;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlContentBadRequestException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class UrlContentBadRequestException : Exception\n    {\n        public UrlContentBadRequestException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlContentNotFoundException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class UrlContentNotFoundException : Exception\n    {\n        public UrlContentNotFoundException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IUrlContentService, UrlContentService>();\nbuilder.Services.AddLogging();\n\n// To set up the policy, configure as below:\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"UrlContentPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\n// Example trusted domains in appsettings.json:\n// \"TrustedDomains\": [ \"example.com\", \"trustedsite.org\" ]\n\nvar app = builder.Build();\n\napp.UseHttpsRedirection();\napp.UseRouting();\napp.UseAuthorization();\napp.MapControllers();\napp.Run();\n```\n", "orig": "```csharp\n// Controllers/UrlContentController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing System.Net.Http;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlContentController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> GetUrlContent(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest(\"Url is required\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out Uri uri))\n            {\n                return BadRequest(\"Invalid url\");\n            }\n\n            using var client = new HttpClient();\n            var response = await client.GetAsync(uri);\n            var content = await response.Content.ReadAsStringAsync();\n\n            return Ok(content);\n        }\n    }\n}\n\n// Models/UrlContent.cs\nusing System.Text.Json.Serialization;\n\nnamespace MyApp.Models\n{\n    public class UrlContent\n    {\n        [JsonPropertyName(\"content\")]\n        public string Content { get; set; }\n    }\n}\n\n// Program.cs\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\n// Startup.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddSingleton<IHttpContextAccessor, HttpContextAccessor>();\n            services.AddSingleton<IUrlContentService, UrlContentService>();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\n// UrlContentService.cs\nusing System.Net.Http;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Services\n{\n    public class UrlContentService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlContentService> _logger;\n\n        public UrlContentService(IHttpClientFactory httpClientFactory, ILogger<UrlContentService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n        }\n\n        public async Task<string> GetUrlContent(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n            {\n                _logger.LogError(\"Url is required\");\n                throw new ArgumentException(\"Url is required\", nameof(url));\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out Uri uri))\n            {\n                _logger.LogError(\"Invalid url\");\n                throw new ArgumentException(\"Invalid url\", nameof(url));\n            }\n\n            var client = _httpClientFactory.CreateClient();\n            var response = await client.GetAsync(uri);\n            var content = await response.Content.ReadAsStringAsync();\n\n            return content;\n        }\n    }\n}\n```"}
{"prompt": "Design a C# function to take a URL from the user and retrieve its data.", "response": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Add in Program.cs or Startup.cs:\n    // services.AddAuthorization(options =>\n    // {\n    //     options.AddPolicy(\"UrlReadPolicy\", policy => policy.RequireAuthenticatedUser());\n    // });\n\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"UrlReadPolicy\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlService _urlService;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IUrlService urlService, ILogger<UrlController> logger)\n        {\n            _urlService = urlService;\n            _logger = logger;\n        }\n\n        [HttpGet(\"{*url}\")]\n        [Authorize(Policy = \"UrlReadPolicy\")]\n        public async Task<IActionResult> GetUrl([FromRoute] string url)\n        {\n            _logger.LogInformation(\"Received request for URL resource. Route input: {RouteUrl}\", url);\n\n            try\n            {\n                var result = await _urlService.GetUrlAsync(url);\n\n                if (result.Success)\n                {\n                    _logger.LogInformation(\"URL fetch succeeded for: {RouteUrl}\", url);\n                    return Ok(new { data = result.Data });\n                }\n                else\n                {\n                    _logger.LogWarning(\"URL fetch failed for: {RouteUrl} - {Error}\", url, result.Message);\n                    return BadRequest(new { error = result.Message });\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unhandled exception fetching URL: {RouteUrl}\", url);\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/IUrlService.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IUrlService\n    {\n        Task<Result<string>> GetUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class UrlService : IUrlService\n    {\n        private readonly ILogger<UrlService> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlService(\n            IHttpClientFactory httpClientFactory,\n            ILogger<UrlService> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomains = GetTrustedDomainsFromConfig();\n        }\n\n        public async Task<Result<string>> GetUrlAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return Result<string>.Failure(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return Result<string>.Failure(\"URL is not well-formed.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return Result<string>.Failure(\"Only HTTPS scheme is allowed.\");\n            }\n\n            if (!_trustedDomains.Contains(uri.Host, StringComparer.OrdinalIgnoreCase))\n            {\n                return Result<string>.Failure(\"Host is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(uri.Host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host: {Host}\", uri.Host);\n                return Result<string>.Failure(\"DNS resolution failed.\");\n            }\n\n            var validAddress = addresses.FirstOrDefault(IsPublicAddress);\n            if (validAddress == null)\n            {\n                return Result<string>.Failure(\"No valid public IP address found for the host.\");\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = validAddress.ToString()\n            };\n\n            var httpClient = _httpClientFactory.CreateClient(\"VerifiedIpFetcher\");\n            httpClient.DefaultRequestHeaders.Host = uri.Host;\n\n            try\n            {\n                var response = await httpClient.GetAsync(builder.Uri);\n                if (!response.IsSuccessStatusCode)\n                {\n                    return Result<string>.Failure($\"Failed to fetch resource. Status code: {response.StatusCode}\");\n                }\n\n                var data = await response.Content.ReadAsStringAsync();\n                return Result<string>.Success(data);\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogError(ex, \"Error fetching URL at {Url}\", url);\n                return Result<string>.Failure(\"Error fetching the resource.\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error fetching URL at {Url}\", url);\n                return Result<string>.Failure(\"Unexpected error occurred.\");\n            }\n        }\n\n        private bool IsPublicAddress(IPAddress address)\n        {\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return false;\n                }\n                // Link-local 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n                return true;\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(address))\n                {\n                    return false;\n                }\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal)\n                {\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        }\n\n        private HashSet<string> GetTrustedDomainsFromConfig()\n        {\n            var trusted = _configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            if (trusted == null || trusted.Length == 0)\n            {\n                // Safe default: allow only example.com\n                return new HashSet<string>(StringComparer.OrdinalIgnoreCase) { \"example.com\" };\n            }\n            return new HashSet<string>(trusted, StringComparer.OrdinalIgnoreCase);\n        }\n    }\n}\n```\n\n```csharp\n// Models/Result.cs\nnamespace MyApp.Models\n{\n    public class Result<T>\n    {\n        public bool Success { get; }\n        public T Data { get; }\n        public string Message { get; }\n\n        private Result(bool success, T data, string message)\n        {\n            Success = success;\n            Data = data;\n            Message = message;\n        }\n\n        public static Result<T> Success(T data)\n        {\n            return new Result<T>(true, data, null);\n        }\n\n        public static Result<T> Failure(string message)\n        {\n            return new Result<T>(false, default, message);\n        }\n    }\n}\n```\n\n```csharp\n// Models/Url.cs\nnamespace MyApp.Models\n{\n    public class Url\n    {\n        public string Value { get; }\n\n        public Url(string value)\n        {\n            Value = value;\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlData.cs\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        public string Data { get; }\n\n        public UrlData(string data)\n        {\n            Data = data;\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlService _urlService;\n\n        public UrlController(IUrlService urlService)\n        {\n            _urlService = urlService;\n        }\n\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> GetUrl(string url)\n        {\n            var result = await _urlService.GetUrlAsync(url);\n\n            if (result.Success)\n            {\n                return Ok(result.Data);\n            }\n            else\n            {\n                return BadRequest(result.Message);\n            }\n        }\n    }\n}\n\n// Services/UrlService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlService\n    {\n        Task<Result<string>> GetUrlAsync(string url);\n    }\n}\n\n// Services/UrlService.cs\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class UrlService : IUrlService\n    {\n        private readonly HttpClient _httpClient;\n        private readonly ILogger<UrlService> _logger;\n\n        public UrlService(HttpClient httpClient, ILogger<UrlService> logger)\n        {\n            _httpClient = httpClient;\n            _logger = logger;\n        }\n\n        public async Task<Result<string>> GetUrlAsync(string url)\n        {\n            try\n            {\n                var response = await _httpClient.GetAsync(url);\n                response.EnsureSuccessStatusCode();\n\n                var data = await response.Content.ReadAsStringAsync();\n\n                return new Result<string>(data);\n            }\n            catch (HttpRequestException e)\n            {\n                _logger.LogError(e, \"Error getting URL\");\n\n                return new Result<string>(e.Message);\n            }\n        }\n    }\n}\n\n// Models/Result.cs\nusing System;\n\nnamespace MyApp.Models\n{\n    public class Result<T>\n    {\n        public Result(T data)\n        {\n            Data = data;\n        }\n\n        public Result(string message)\n        {\n            Message = message;\n        }\n\n        public T Data { get; }\n        public string Message { get; }\n    }\n}\n\n// Models/Url.cs\nusing System;\n\nnamespace MyApp.Models\n{\n    public class Url\n    {\n        public Url(string url)\n        {\n            Url = url;\n        }\n\n        public string Url { get; }\n    }\n}\n\n// Models/UrlData.cs\nusing System;\n\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        public UrlData(string data)\n        {\n            Data = data;\n        }\n\n        public string Data { get; }\n    }\n}\n```"}
{"prompt": "Write a C# function to take a URL entered by the user and extract its data.", "response": "```csharp\n// Models/UrlExtractionRequest.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace Models;\n\npublic class UrlExtractionRequest\n{\n    [Required]\n    [Url]\n    public string Url { get; set; } = string.Empty;\n}\n```\n\n```csharp\n// Models/UrlData.cs\nnamespace Models;\n\npublic class UrlData\n{\n    public string Scheme { get; set; } = string.Empty;\n    public string Host { get; set; } = string.Empty;\n    public string Path { get; set; } = string.Empty;\n    public string Query { get; set; } = string.Empty;\n}\n```\n\n```csharp\n// Services/ITrustedDomainService.cs\nusing System.Collections.Generic;\n\nnamespace Services;\n\npublic interface ITrustedDomainService\n{\n    IReadOnlyCollection<string> GetTrustedDomains();\n    bool IsTrustedDomain(string host);\n}\n```\n\n```csharp\n// Services/TrustedDomainService.cs\nusing Microsoft.Extensions.Configuration;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Services;\n\npublic class TrustedDomainService : ITrustedDomainService\n{\n    private readonly HashSet<string> _trustedDomains;\n\n    public TrustedDomainService(IConfiguration configuration)\n    {\n        var domains = configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n        _trustedDomains = domains != null\n            ? new HashSet<string>(domains.Select(d => d.ToLowerInvariant()))\n            : new HashSet<string>();\n    }\n\n    public IReadOnlyCollection<string> GetTrustedDomains()\n    {\n        return _trustedDomains;\n    }\n\n    public bool IsTrustedDomain(string host)\n    {\n        return _trustedDomains.Contains(host.ToLowerInvariant());\n    }\n}\n```\n\n```csharp\n// Services/IUrlSecurityService.cs\nusing System.Threading.Tasks;\n\nnamespace Services;\n\npublic interface IUrlSecurityService\n{\n    Task<bool> IsUrlSafeAsync(Uri uri);\n}\n```\n\n```csharp\n// Services/UrlSecurityService.cs\nusing System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace Services;\n\npublic class UrlSecurityService : IUrlSecurityService\n{\n    private readonly ITrustedDomainService _trustedDomainService;\n\n    public UrlSecurityService(ITrustedDomainService trustedDomainService)\n    {\n        _trustedDomainService = trustedDomainService;\n    }\n\n    public async Task<bool> IsUrlSafeAsync(Uri uri)\n    {\n        if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.InvariantCultureIgnoreCase))\n        {\n            return false;\n        }\n\n        if (!_trustedDomainService.IsTrustedDomain(uri.Host))\n        {\n            return false;\n        }\n\n        IPAddress[] addresses;\n        try\n        {\n            addresses = await Dns.GetHostAddressesAsync(uri.Host);\n        }\n        catch\n        {\n            return false;\n        }\n\n        foreach (var ip in addresses)\n        {\n            if (IsPrivateOrLoopbackOrLinkLocal(ip))\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n    {\n        if (IPAddress.IsLoopback(ip))\n        {\n            return true;\n        }\n\n        if (ip.AddressFamily == AddressFamily.InterNetwork)\n        {\n            var bytes = ip.GetAddressBytes();\n            // 10.0.0.0/8\n            if (bytes[0] == 10)\n            {\n                return true;\n            }\n            // 172.16.0.0/12\n            if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n            {\n                return true;\n            }\n            // 192.168.0.0/16\n            if (bytes[0] == 192 && bytes[1] == 168)\n            {\n                return true;\n            }\n            // 169.254.0.0/16 (link-local)\n            if (bytes[0] == 169 && bytes[1] == 254)\n            {\n                return true;\n            }\n        }\n        else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n        {\n            if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast)\n            {\n                return true;\n            }\n            if (ip.Equals(IPAddress.IPv6Loopback))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n```csharp\n// Controllers/UrlDataController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Models;\nusing Services;\nusing System;\nusing System.Threading.Tasks;\n\n// To set up the policy, add in Program.cs:\n// services.AddAuthorization(options => options.AddPolicy(\"UrlExtractPolicy\", policy => policy.RequireAuthenticatedUser()));\n\nnamespace Controllers;\n\n[ApiController]\n[Route(\"[controller]\")]\n[Authorize(Policy = \"UrlExtractPolicy\")]\npublic class UrlDataController : ControllerBase\n{\n    private readonly IUrlSecurityService _urlSecurityService;\n    private readonly ILogger<UrlDataController> _logger;\n\n    public UrlDataController(IUrlSecurityService urlSecurityService, ILogger<UrlDataController> logger)\n    {\n        _urlSecurityService = urlSecurityService;\n        _logger = logger;\n    }\n\n    [HttpPost]\n    [Authorize(Policy = \"UrlExtractPolicy\")]\n    public async Task<IActionResult> ExtractUrlData([FromBody] UrlExtractionRequest request)\n    {\n        if (!ModelState.IsValid)\n        {\n            return BadRequest(new { error = \"Invalid input\", details = ModelState });\n        }\n\n        Uri uri;\n        try\n        {\n            uri = new Uri(request.Url);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogWarning(\"Malformed URL provided: {Url}. Exception: {Ex}\", request.Url, ex.Message);\n            return BadRequest(new { error = \"Malformed URL\" });\n        }\n\n        bool isSafe;\n        try\n        {\n            isSafe = await _urlSecurityService.IsUrlSafeAsync(uri);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Error during URL safety check for {Url}\", request.Url);\n            return StatusCode(500, new { error = \"Internal server error\" });\n        }\n\n        if (!isSafe)\n        {\n            _logger.LogWarning(\"URL failed security checks: {Url}\", request.Url);\n            // Uniform error to avoid leaking permission/existence\n            return NotFound(new { error = \"Resource not found\" });\n        }\n\n        var data = new UrlData\n        {\n            Scheme = uri.Scheme,\n            Host = uri.Host,\n            Path = uri.AbsolutePath,\n            Query = uri.Query\n        };\n\n        _logger.LogInformation(\"URL data extracted for host: {Host}, path: {Path}\", data.Host, data.Path);\n\n        return Ok(data);\n    }\n}\n```\n", "orig": "```csharp\n// Models/UrlData.cs\npublic class UrlData\n{\n    public string Scheme { get; set; }\n    public string Host { get; set; }\n    public string Path { get; set; }\n    public string Query { get; set; }\n}\n\n// Controllers/UrlDataController.cs\nusing System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Text.RegularExpressions;\nusing Models;\n\nnamespace Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        [HttpPost]\n        public ActionResult<UrlData> ExtractUrlData(string url)\n        {\n            var uri = new Uri(url);\n            var data = new UrlData\n            {\n                Scheme = uri.Scheme,\n                Host = uri.Host,\n                Path = uri.AbsolutePath,\n                Query = uri.Query\n            };\n            return Ok(data);\n        }\n    }\n}\n```"}
{"prompt": "Write a C# method to take in a URL provided by the user and extract its data.", "response": "```csharp\n// Controllers/UrlController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Threading.Tasks;\n\n// Policy setup: Add a policy named \"UrlReadPolicy\" in your Program.cs or Startup.cs\n// options.AddPolicy(\"UrlReadPolicy\", policy => policy.RequireAuthenticatedUser());\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class UrlController : ControllerBase\n    {\n        private readonly ILogger<UrlController> _logger;\n        private readonly IUrlDataService _urlDataService;\n\n        public UrlController(ILogger<UrlController> logger, IUrlDataService urlDataService)\n        {\n            _logger = logger;\n            _urlDataService = urlDataService;\n        }\n\n        [HttpPost(\"extract\")]\n        [Authorize(Policy = \"UrlReadPolicy\")]\n        public async Task<IActionResult> ExtractUrlData([FromBody] UrlRequestDto request)\n        {\n            _logger.LogInformation(\"ExtractUrlData called with URL: {Url}\", request?.Url);\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid input\", details = ModelState });\n            }\n\n            try\n            {\n                var result = await _urlDataService.ExtractUrlDataAsync(request.Url);\n\n                if (result == null)\n                {\n                    return NotFound(new { error = \"Resource not found or not allowed\" });\n                }\n\n                return Ok(result);\n            }\n            catch (UrlValidationException ex)\n            {\n                _logger.LogWarning(ex, \"URL validation failed for input: {Url}\", request.Url);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error in ExtractUrlData for input: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlData.cs\n\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        public string Host { get; set; }\n        public string Scheme { get; set; }\n        public string Path { get; set; }\n        public string Query { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlDataService.cs\n\nusing MyApp.Models;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlDataService\n    {\n        Task<UrlData> ExtractUrlDataAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlDataService.cs\n\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlDataService : IUrlDataService\n    {\n        private readonly ILogger<UrlDataService> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlDataService(ILogger<UrlDataService> logger, IConfiguration configuration)\n        {\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomains = new HashSet<string>(\n                _configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>(),\n                StringComparer.OrdinalIgnoreCase\n            );\n        }\n\n        public async Task<UrlData> ExtractUrlDataAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new UrlValidationException(\"Url cannot be null or empty\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var parsedUrl))\n            {\n                throw new UrlValidationException(\"Invalid URL format\");\n            }\n\n            if (!string.Equals(parsedUrl.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlValidationException(\"Only HTTPS scheme is allowed\");\n            }\n\n            if (!_trustedDomains.Contains(parsedUrl.Host))\n            {\n                throw new UrlValidationException(\"Domain is not trusted\");\n            }\n\n            var resolvedIps = await Dns.GetHostAddressesAsync(parsedUrl.Host);\n            var validIp = resolvedIps.FirstOrDefault(ip => IsPublicAddress(ip));\n\n            if (validIp == null)\n            {\n                throw new UrlValidationException(\"Resolved IP is not a valid public address\");\n            }\n\n            _logger.LogInformation(\"URL {Url} passed all validation checks\", url);\n\n            return new UrlData\n            {\n                Host = parsedUrl.Host,\n                Scheme = parsedUrl.Scheme,\n                Path = parsedUrl.AbsolutePath,\n                Query = parsedUrl.Query\n            };\n        }\n\n        private static bool IsPublicAddress(IPAddress address)\n        {\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8 loopback\n                if (bytes[0] == 127)\n                {\n                    return false;\n                }\n                // Link-local 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(address))\n                {\n                    return false;\n                }\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal)\n                {\n                    return false;\n                }\n                var bytes = address.GetAddressBytes();\n                // Unique local addresses fc00::/7\n                if ((bytes[0] & 0xfe) == 0xfc)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlValidationException.cs\n\nusing System;\n\nnamespace MyApp.Services\n{\n    public class UrlValidationException : Exception\n    {\n        public UrlValidationException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/UrlController.cs\n\nusing System;\nusing System.Text.RegularExpressions;\n\nnamespace MyApp.Controllers\n{\n    public class UrlController\n    {\n        public UrlData GetUrlData(string url)\n        {\n            // Validate input\n            if (string.IsNullOrEmpty(url))\n            {\n                throw new ArgumentException(\"Url cannot be null or empty\", nameof(url));\n            }\n\n            // Parse URL\n            var parsedUrl = new Uri(url);\n\n            // Extract data\n            var host = parsedUrl.Host;\n            var scheme = parsedUrl.Scheme;\n            var path = parsedUrl.AbsolutePath;\n            var query = parsedUrl.Query;\n\n            // Return data\n            return new UrlData\n            {\n                Host = host,\n                Scheme = scheme,\n                Path = path,\n                Query = query\n            };\n        }\n    }\n}\n\n// Models/UrlData.cs\n\nusing System;\n\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        public string Host { get; set; }\n        public string Scheme { get; set; }\n        public string Path { get; set; }\n        public string Query { get; set; }\n    }\n}\n```"}
{"prompt": "Write a C# method to take in a URL provided by the user and extract its data.", "response": "```csharp\n// Controllers/UrlDataController.cs\nusing System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing System.Web;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Net.Sockets;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: services.AddAuthorization(options => options.AddPolicy(\"UrlDataAccessPolicy\", p => p.RequireAuthenticatedUser()));\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"UrlDataAccessPolicy\")]\n    public class UrlDataController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IConfiguration _configuration;\n        private readonly IUrlValidationService _urlValidationService;\n        private readonly IUrlDataParserService _urlDataParserService;\n        private readonly ILogger<UrlDataController> _logger;\n\n        public UrlDataController(\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration,\n            IUrlValidationService urlValidationService,\n            IUrlDataParserService urlDataParserService,\n            ILogger<UrlDataController> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _configuration = configuration;\n            _urlValidationService = urlValidationService;\n            _urlDataParserService = urlDataParserService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Route(\"\")]\n        [Authorize(Policy = \"UrlDataAccessPolicy\")]\n        public async Task<IActionResult> GetUrlData([FromQuery] UrlDataRequestDto requestDto)\n        {\n            if (!requestDto.IsValid(out var validationError))\n            {\n                _logger.LogWarning(\"Invalid request for URL data: {Error}\", validationError);\n                return BadRequest(new { error = validationError });\n            }\n\n            try\n            {\n                var trustedDomains = _configuration.GetSection(\"TrustedDomains\").Get<List<string>>() ?? new List<string>();\n                var httpsUrl = _urlValidationService.GetWellFormedHttpsUrl(requestDto.Url, trustedDomains, out var urlError);\n                if (httpsUrl == null)\n                {\n                    _logger.LogWarning(\"URL validation failed: {Error}\", urlError);\n                    return BadRequest(new { error = urlError });\n                }\n\n                var ipAddresses = await _urlValidationService.ResolveHostToIpAddressesAsync(httpsUrl.Host);\n                if (!_urlValidationService.AreAllPublicAddresses(ipAddresses))\n                {\n                    _logger.LogWarning(\"Non-public IP address for host: {Host}\", httpsUrl.Host);\n                    return BadRequest(new { error = \"Resolved IP address is not public.\" });\n                }\n\n                var httpClient = _httpClientFactory.CreateClient();\n                httpClient.Timeout = TimeSpan.FromSeconds(_configuration.GetValue<int>(\"HttpTimeoutSeconds\", 10));\n                var request = new HttpRequestMessage(HttpMethod.Get, new UriBuilder(httpsUrl) { Host = ipAddresses.First().ToString() }.Uri);\n                request.Headers.Host = httpsUrl.Host;\n\n                var response = await httpClient.SendAsync(request);\n                if (response.StatusCode == HttpStatusCode.OK)\n                {\n                    var content = await response.Content.ReadAsStringAsync();\n                    var data = _urlDataParserService.Parse(content);\n                    _logger.LogInformation(\"Successfully fetched and parsed data for URL: {Url}\", httpsUrl.ToString());\n                    return Ok(data);\n                }\n                else\n                {\n                    _logger.LogWarning(\"Failed to fetch URL data. Status: {Status}, URL: {Url}\", response.StatusCode, httpsUrl.ToString());\n                    return StatusCode((int)HttpStatusCode.BadRequest, new { error = \"Failed to fetch URL data.\" });\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error fetching URL data\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlData.cs\nusing System;\n\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        public string Title { get; set; }\n        public string Description { get; set; }\n        public string ImageUrl { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlDataRequestDto.cs\nusing System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlDataRequestDto\n    {\n        [Required]\n        public string Url { get; set; }\n\n        public bool IsValid(out string error)\n        {\n            error = null;\n            if (string.IsNullOrWhiteSpace(Url))\n            {\n                error = \"Url is required.\";\n                return false;\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Services/IUrlValidationService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlValidationService\n    {\n        Uri GetWellFormedHttpsUrl(string url, List<string> trustedDomains, out string error);\n        Task<IPAddress[]> ResolveHostToIpAddressesAsync(string host);\n        bool AreAllPublicAddresses(IPAddress[] addresses);\n    }\n}\n```\n\n```csharp\n// Services/UrlValidationService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlValidationService : IUrlValidationService\n    {\n        public Uri GetWellFormedHttpsUrl(string url, List<string> trustedDomains, out string error)\n        {\n            error = null;\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                error = \"Invalid URL format.\";\n                return null;\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                error = \"Only HTTPS URLs are allowed.\";\n                return null;\n            }\n\n            if (uri.HostNameType == UriHostNameType.IPv4 || uri.HostNameType == UriHostNameType.IPv6)\n            {\n                // No domain to check, allow\n                return uri;\n            }\n\n            if (trustedDomains == null || !trustedDomains.Any())\n            {\n                error = \"No trusted domains configured.\";\n                return null;\n            }\n\n            var isTrusted = trustedDomains.Any(domain =>\n                string.Equals(domain, uri.Host, StringComparison.OrdinalIgnoreCase));\n            if (!isTrusted)\n            {\n                error = $\"Domain '{uri.Host}' is not trusted.\";\n                return null;\n            }\n\n            return uri;\n        }\n\n        public async Task<IPAddress[]> ResolveHostToIpAddressesAsync(string host)\n        {\n            return await Dns.GetHostAddressesAsync(host);\n        }\n\n        public bool AreAllPublicAddresses(IPAddress[] addresses)\n        {\n            foreach (var addr in addresses)\n            {\n                if (IsPrivate(addr) || IPAddress.IsLoopback(addr) || IsLinkLocal(addr))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private bool IsPrivate(IPAddress address)\n        {\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                return\n                    bytes[0] == 10 ||\n                    (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) ||\n                    (bytes[0] == 192 && bytes[1] == 168);\n            }\n            if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                return address.IsIPv6SiteLocal || address.IsIPv6UniqueLocal;\n            }\n            return false;\n        }\n\n        private bool IsLinkLocal(IPAddress address)\n        {\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                return bytes[0] == 169 && bytes[1] == 254;\n            }\n            if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                return address.IsIPv6LinkLocal;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/IUrlDataParserService.cs\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IUrlDataParserService\n    {\n        UrlData Parse(string htmlContent);\n    }\n}\n```\n\n```csharp\n// Services/UrlDataParserService.cs\nusing System.Text.RegularExpressions;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class UrlDataParserService : IUrlDataParserService\n    {\n        public UrlData Parse(string htmlContent)\n        {\n            var title = Regex.Match(htmlContent, @\"<title>\\s*(.+?)\\s*</title>\", RegexOptions.IgnoreCase | RegexOptions.Singleline).Groups[1].Value;\n            var description = Regex.Match(htmlContent, @\"<meta\\s+name\\s*=\\s*[\"\"']description[\"\"']\\s+content\\s*=\\s*[\"\"'](.+?)[\"\"']\", RegexOptions.IgnoreCase).Groups[1].Value;\n            var imageUrl = Regex.Match(htmlContent, @\"<meta\\s+property\\s*=\\s*[\"\"']og:image[\"\"']\\s+content\\s*=\\s*[\"\"'](.+?)[\"\"']\", RegexOptions.IgnoreCase).Groups[1].Value;\n\n            return new UrlData\n            {\n                Title = string.IsNullOrWhiteSpace(title) ? null : title,\n                Description = string.IsNullOrWhiteSpace(description) ? null : description,\n                ImageUrl = string.IsNullOrWhiteSpace(imageUrl) ? null : imageUrl\n            };\n        }\n    }\n}\n```", "orig": "```csharp\n[Controllers/UrlDataController.cs]\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlDataController : ControllerBase\n    {\n        private readonly HttpClient _httpClient;\n\n        public UrlDataController(IHttpClientFactory httpClientFactory)\n        {\n            _httpClient = httpClientFactory.CreateClient();\n        }\n\n        [HttpGet]\n        [Route(\"{url}\")]\n        public async Task<ActionResult<UrlData>> GetUrlData(string url)\n        {\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            var response = await _httpClient.SendAsync(request);\n\n            if (response.StatusCode == HttpStatusCode.OK)\n            {\n                var content = await response.Content.ReadAsStringAsync();\n                var data = ParseUrlData(content);\n                return Ok(data);\n            }\n            else\n            {\n                return StatusCode(response.StatusCode);\n            }\n        }\n\n        private UrlData ParseUrlData(string content)\n        {\n            // TODO: Implement parsing logic\n            return new UrlData();\n        }\n    }\n}\n\n[Models/UrlData.cs]\nusing System;\n\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        public string Title { get; set; }\n        public string Description { get; set; }\n        public string ImageUrl { get; set; }\n    }\n}\n```"}
{"prompt": "Develop a C# function which accepts a user-input URL and retrieves the associated data.", "response": "```csharp\n// Controllers/DataController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup (add to Program.cs or Startup.cs):\n    // services.AddAuthorization(options => {\n    //     options.AddPolicy(\"TrustedDataRead\", policy => policy.RequireAuthenticatedUser());\n    // });\n\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"TrustedDataRead\")]\n    public class DataController : ControllerBase\n    {\n        private readonly ILogger<DataController> _logger;\n        private readonly IDataFetcher _dataFetcher;\n\n        public DataController(ILogger<DataController> logger, IDataFetcher dataFetcher)\n        {\n            _logger = logger;\n            _dataFetcher = dataFetcher;\n        }\n\n        [HttpGet(\"{*url}\")]\n        [Authorize(Policy = \"TrustedDataRead\")]\n        public async Task<IActionResult> GetData([FromRoute] string url)\n        {\n            _logger.LogInformation(\"GetData called with url: {Url}\", url);\n\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return BadRequest(new { error = \"URL is required.\" });\n            }\n\n            try\n            {\n                var fetchResult = await _dataFetcher.FetchDataFromTrustedUrlAsync(url);\n                if (!fetchResult.Success)\n                {\n                    return BadRequest(new { error = fetchResult.ErrorMessage });\n                }\n\n                _logger.LogInformation(\"Data successfully retrieved from: {Url}\", url);\n                return File(fetchResult.Data, fetchResult.ContentType ?? \"application/octet-stream\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error retrieving data for url: {Url}\", url);\n                return StatusCode(500, new { error = \"An error occurred while retrieving data.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/IDataFetcher.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    public interface IDataFetcher\n    {\n        Task<FetchResult> FetchDataFromTrustedUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/DataFetcher.cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp\n{\n    public class DataFetcher : IDataFetcher\n    {\n        private readonly IList<string> _trustedDomains;\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<DataFetcher> _logger;\n\n        public DataFetcher(IConfiguration configuration, IHttpClientFactory httpClientFactory, ILogger<DataFetcher> logger)\n        {\n            _trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<List<string>>() ?? new List<string>();\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n        }\n\n        public async Task<FetchResult> FetchDataFromTrustedUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return FetchResult.Fail(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return FetchResult.Fail(\"Only HTTPS URLs are allowed.\");\n            }\n\n            string host = uri.Host;\n            if (!_trustedDomains.Any(domain => string.Equals(domain, host, StringComparison.OrdinalIgnoreCase)))\n            {\n                return FetchResult.Fail(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                return FetchResult.Fail(\"Unable to resolve host.\");\n            }\n\n            if (addresses.Length == 0)\n            {\n                return FetchResult.Fail(\"Unable to resolve host.\");\n            }\n\n            foreach (var address in addresses)\n            {\n                if (IsPrivateOrLoopback(address))\n                {\n                    return FetchResult.Fail(\"Resolved IP is private, loopback, or link-local.\");\n                }\n            }\n\n            var client = _httpClientFactory.CreateClient(\"TrustedDataFetcher\");\n            client.Timeout = TimeSpan.FromSeconds(10);\n\n            // Connect to the first valid IP directly\n            var resolvedIp = addresses.First();\n            var builder = new UriBuilder(uri)\n            {\n                Host = resolvedIp.ToString()\n            };\n\n            var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n            request.Headers.Host = host;\n\n            try\n            {\n                using var response = await client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead);\n                if (!response.IsSuccessStatusCode)\n                {\n                    return FetchResult.Fail(\"Failed to retrieve data from remote resource.\");\n                }\n\n                var contentType = response.Content.Headers.ContentType?.MediaType;\n                var data = await response.Content.ReadAsByteArrayAsync();\n\n                return FetchResult.Success(data, contentType);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to fetch data from trusted url {Url}\", url);\n                return FetchResult.Fail(\"Error occurred while fetching data.\");\n            }\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6Multicast || address.IsIPv6SiteLocal || address.IsIPv6Teredo || address.IsIPv6UniqueLocal)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/FetchResult.cs\nnamespace MyApp\n{\n    public class FetchResult\n    {\n        public bool Success { get; }\n        public string ErrorMessage { get; }\n        public byte[] Data { get; }\n        public string ContentType { get; }\n\n        private FetchResult(bool success, string errorMessage = null, byte[] data = null, string contentType = null)\n        {\n            Success = success;\n            ErrorMessage = errorMessage;\n            Data = data;\n            ContentType = contentType;\n        }\n\n        public static FetchResult Success(byte[] data, string contentType) =>\n            new FetchResult(true, null, data, contentType);\n\n        public static FetchResult Fail(string errorMessage) =>\n            new FetchResult(false, errorMessage);\n    }\n}\n```\n\n```csharp\n// Controllers/HelloController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup (add to Program.cs or Startup.cs):\n    // services.AddAuthorization(options => {\n    //     options.AddPolicy(\"HelloRead\", policy => policy.RequireAuthenticatedUser());\n    // });\n\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"HelloRead\")]\n    public class HelloController : ControllerBase\n    {\n        [HttpGet]\n        [Authorize(Policy = \"HelloRead\")]\n        public IActionResult Get()\n        {\n            return Ok(new { message = \"Hello World!\" });\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nbuilder.Services.AddHttpClient(\"TrustedDataFetcher\")\n    .ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler\n    {\n        AllowAutoRedirect = true\n    });\n\nbuilder.Services.AddScoped<IDataFetcher, DataFetcher>();\n\n// Authorization policies (see controller comments for usage)\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedDataRead\", policy => policy.RequireAuthenticatedUser());\n    options.AddPolicy(\"HelloRead\", policy => policy.RequireAuthenticatedUser());\n});\n\nbuilder.Configuration.AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: true);\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\n\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"api.trustedhost.com\"\n  ]\n}\n```", "orig": "```csharp\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class DataController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> GetData(string url)\n        {\n            // TODO: implement data retrieval logic\n            return Ok(new { message = \"Data retrieved successfully.\" });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddSwaggerGen();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n                app.UseSwagger();\n                app.UseSwaggerUI(c => c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"MyApp v1\"));\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class Controller : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> Get()\n        {\n            return Ok(new { message = \"Hello World!\" });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddSwaggerGen();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n                app.UseSwagger();\n                app.UseSwaggerUI(c => c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"MyApp v1\"));\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class DataController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> GetData(string url)\n        {\n            // TODO: implement data retrieval logic\n            return Ok(new { message = \"Data retrieved successfully.\" });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddSwaggerGen();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n                app.UseSwagger();\n                app.UseSwaggerUI(c => c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"MyApp v1\"));\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class Controller : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> Get()\n        {\n            return Ok(new { message = \"Hello World!\" });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddSwaggerGen();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n                app.UseSwagger();\n                app.UseSwaggerUI(c => c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"MyApp v1\"));\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class DataController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> GetData(string url)\n        {\n            // TODO: implement data retrieval logic\n            return Ok(new { message = \"Data retrieved successfully.\" });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddSwaggerGen();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n                app.UseSwagger();\n                app.UseSwaggerUI(c => c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"MyApp v1\"));\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class Controller : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> Get()\n        {\n            return Ok(new { message = \"Hello World!\" });\n        }\n    }\n}\n```"}
{"prompt": "Compose a C# function to accept a URL from the user and extract data from it.", "response": "```csharp\n// Controllers/DataExtractionController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing System.Threading.Tasks;\nusing MyApp.Models;\nusing MyApp.Services;\n\n// To enable the policy, add in Program.cs or Startup.cs:\n// services.AddAuthorization(options => { options.AddPolicy(\"ExtractDataPolicy\", policy => policy.RequireAuthenticatedUser()); });\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"ExtractDataPolicy\")]\n    public class DataExtractionController : ControllerBase\n    {\n        private readonly IDataExtractionService _dataExtractionService;\n        private readonly ILogger<DataExtractionController> _logger;\n\n        public DataExtractionController(\n            IDataExtractionService dataExtractionService,\n            ILogger<DataExtractionController> logger)\n        {\n            _dataExtractionService = dataExtractionService;\n            _logger = logger;\n        }\n\n        [HttpPost]\n        [Authorize(Policy = \"ExtractDataPolicy\")]\n        public async Task<IActionResult> ExtractDataFromUrl([FromBody] DataExtractionRequestDto request)\n        {\n            _logger.LogInformation(\"ExtractDataFromUrl called with URL: {Url}\", request.Url);\n\n            var result = await _dataExtractionService.ExtractDataFromUrlAsync(request.Url);\n\n            if (result.IsSuccess)\n            {\n                _logger.LogInformation(\"Data extraction succeeded for URL: {Url}\", request.Url);\n                return Ok(new DataExtractionResponseDto { Result = result.ExtractedData });\n            }\n            else if (result.IsBadRequest)\n            {\n                _logger.LogWarning(\"Bad request: {Error}\", result.ErrorMessage);\n                return BadRequest(new ErrorResponseDto { Error = result.ErrorMessage });\n            }\n            else\n            {\n                _logger.LogError(\"Internal server error: {Error}\", result.ErrorMessage);\n                return StatusCode(500, new ErrorResponseDto { Error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/DataExtractionRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class DataExtractionRequestDto\n    {\n        [Required]\n        [MaxLength(2048)]\n        [Url]\n        public string Url { get; set; } = string.Empty;\n    }\n}\n```\n\n```csharp\n// Models/DataExtractionResponseDto.cs\nnamespace MyApp.Models\n{\n    public class DataExtractionResponseDto\n    {\n        public string Result { get; set; } = string.Empty;\n    }\n}\n```\n\n```csharp\n// Models/ErrorResponseDto.cs\nnamespace MyApp.Models\n{\n    public class ErrorResponseDto\n    {\n        public string Error { get; set; } = string.Empty;\n    }\n}\n```\n\n```csharp\n// Models/DataExtractionResult.cs\nnamespace MyApp.Models\n{\n    public class DataExtractionResult\n    {\n        public bool IsSuccess { get; set; }\n        public bool IsBadRequest { get; set; }\n        public string ExtractedData { get; set; } = string.Empty;\n        public string ErrorMessage { get; set; } = string.Empty;\n    }\n}\n```\n\n```csharp\n// Services/IDataExtractionService.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IDataExtractionService\n    {\n        Task<DataExtractionResult> ExtractDataFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/DataExtractionService.cs\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing System;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing Microsoft.Extensions.Configuration;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class DataExtractionService : IDataExtractionService\n    {\n        private readonly IConfiguration _configuration;\n        private readonly string[] _trustedDomains;\n\n        public DataExtractionService(IConfiguration configuration)\n        {\n            _configuration = configuration;\n            _trustedDomains = _configuration\n                .GetSection(\"TrustedDomains\")\n                .Get<string[]>() ?? Array.Empty<string>();\n        }\n\n        public async Task<DataExtractionResult> ExtractDataFromUrlAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return new DataExtractionResult\n                {\n                    IsSuccess = false,\n                    IsBadRequest = true,\n                    ErrorMessage = \"URL is required.\"\n                };\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return new DataExtractionResult\n                {\n                    IsSuccess = false,\n                    IsBadRequest = true,\n                    ErrorMessage = \"Invalid URL format.\"\n                };\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                return new DataExtractionResult\n                {\n                    IsSuccess = false,\n                    IsBadRequest = true,\n                    ErrorMessage = \"Only HTTPS URLs are allowed.\"\n                };\n            }\n\n            var host = uri.Host;\n            if (!_trustedDomains.Any(domain =>\n                string.Equals(domain, host, StringComparison.OrdinalIgnoreCase)))\n            {\n                return new DataExtractionResult\n                {\n                    IsSuccess = false,\n                    IsBadRequest = true,\n                    ErrorMessage = \"Untrusted domain.\"\n                };\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                return new DataExtractionResult\n                {\n                    IsSuccess = false,\n                    IsBadRequest = true,\n                    ErrorMessage = \"Unable to resolve host.\"\n                };\n            }\n\n            if (addresses.Length == 0)\n            {\n                return new DataExtractionResult\n                {\n                    IsSuccess = false,\n                    IsBadRequest = true,\n                    ErrorMessage = \"Host resolves to no address.\"\n                };\n            }\n\n            foreach (var ip in addresses)\n            {\n                if (IsPrivateOrLoopback(ip))\n                {\n                    return new DataExtractionResult\n                    {\n                        IsSuccess = false,\n                        IsBadRequest = true,\n                        ErrorMessage = \"Host resolves to a private or loopback address.\"\n                    };\n                }\n            }\n\n            // Extraction logic: protocol, host, path\n            var pattern = @\"^(https?):\\/\\/([^\\/:]+)(?::\\d+)?\\/([^\\/]+)\";\n            var match = Regex.Match(url, pattern, RegexOptions.IgnoreCase);\n\n            if (match.Success)\n            {\n                var protocol = match.Groups[1].Value;\n                var matchedHost = match.Groups[2].Value;\n                var path = match.Groups[3].Value;\n\n                var extracted = $\"{protocol}://{matchedHost}/{path}\";\n                return new DataExtractionResult\n                {\n                    IsSuccess = true,\n                    ExtractedData = extracted\n                };\n            }\n            else\n            {\n                return new DataExtractionResult\n                {\n                    IsSuccess = false,\n                    IsBadRequest = true,\n                    ErrorMessage = \"Unable to extract data from URL.\"\n                };\n            }\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var octets = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (octets[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (octets[0] == 172 && octets[1] >= 16 && octets[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (octets[0] == 192 && octets[1] == 168)\n                {\n                    return true;\n                }\n                // Link-local 169.254.0.0/16\n                if (octets[0] == 169 && octets[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n", "orig": "```csharp\n[Controllers/DataExtractionController.cs]\nusing Microsoft.AspNetCore.Mvc;\nusing System.Text.RegularExpressions;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DataExtractionController : ControllerBase\n    {\n        [HttpPost]\n        public ActionResult<string> ExtractDataFromUrl(string url)\n        {\n            var pattern = @\"(https?:\\/\\/[^\\/]+)\\/([^\\/]+)\\/([^\\/]+)\";\n            var match = Regex.Match(url, pattern);\n\n            if (match.Success)\n            {\n                var protocol = match.Groups[1].Value;\n                var host = match.Groups[2].Value;\n                var path = match.Groups[3].Value;\n\n                return $\"{protocol}://{host}/{path}\";\n            }\n            else\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n        }\n    }\n}\n```"}
{"prompt": "Develop a C# function that accepts a URL as input and retrieves its content.", "response": "```csharp\n// Controllers/UrlContentController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, configure it in Program.cs or Startup.cs:\n    // options.AddPolicy(\"TrustedUrlReader\", policy => policy.RequireClaim(\"TrustedUrlReader\"));\n\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"TrustedUrlReader\")]\n    public class UrlContentController : ControllerBase\n    {\n        private readonly IUrlContentFetcher _urlContentFetcher;\n        private readonly ILogger<UrlContentController> _logger;\n\n        public UrlContentController(IUrlContentFetcher urlContentFetcher, ILogger<UrlContentController> logger)\n        {\n            _urlContentFetcher = urlContentFetcher;\n            _logger = logger;\n        }\n\n        [HttpPost(\"fetch\")]\n        [Authorize(Policy = \"TrustedUrlReader\")]\n        public async Task<IActionResult> FetchUrlContent([FromBody] UrlContentRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid input\", details = ModelState });\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Fetching content for URL: {Url}\", request.Url);\n\n                var fetchResult = await _urlContentFetcher.TryFetchUrlContentAsync(request.Url);\n\n                if (!fetchResult.Success)\n                {\n                    _logger.LogWarning(\"Failed to fetch content for URL: {Url}. Reason: {Reason}\", request.Url, fetchResult.ErrorReason);\n                    return BadRequest(new { error = fetchResult.ErrorReason });\n                }\n\n                _logger.LogInformation(\"Fetched content for URL: {Url} successfully.\", request.Url);\n\n                return Ok(new { content = fetchResult.Content });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error fetching content for URL: {Url}\", request.Url);\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlContentRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class UrlContentRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlContentFetcher.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlContentFetcher\n    {\n        Task<UrlContentFetchResult> TryFetchUrlContentAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlContentFetcher.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlContentFetcher : IUrlContentFetcher\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlContentFetcher> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlContentFetcher(\n            IHttpClientFactory httpClientFactory,\n            ILogger<UrlContentFetcher> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _trustedDomains = configuration.GetSection(\"TrustedDomains\")\n                                           .Get<string[]>()\n                                           ?.Select(d => d.ToLowerInvariant())\n                                           .ToHashSet() ?? new HashSet<string>();\n        }\n\n        public async Task<UrlContentFetchResult> TryFetchUrlContentAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return UrlContentFetchResult.Failure(\"Malformed URL\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return UrlContentFetchResult.Failure(\"Only HTTPS URLs are allowed\");\n            }\n\n            if (!IsHostTrusted(uri.Host))\n            {\n                return UrlContentFetchResult.Failure(\"Domain is not trusted\");\n            }\n\n            IPAddress[] resolvedAddresses;\n            try\n            {\n                resolvedAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n            }\n            catch\n            {\n                return UrlContentFetchResult.Failure(\"Failed to resolve host\");\n            }\n\n            var validIp = resolvedAddresses.FirstOrDefault(ip => IsPublicIp(ip));\n            if (validIp == null)\n            {\n                return UrlContentFetchResult.Failure(\"No valid public IP found for host\");\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = validIp.ToString()\n            };\n\n            var requestUri = builder.Uri;\n\n            var handler = new HttpClientHandler\n            {\n                ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => true\n            };\n\n            using var client = new HttpClient(handler);\n\n            client.DefaultRequestHeaders.Host = uri.Host;\n\n            try\n            {\n                var response = await client.GetAsync(requestUri);\n                if (!response.IsSuccessStatusCode)\n                {\n                    return UrlContentFetchResult.Failure($\"Remote server returned {(int)response.StatusCode}\");\n                }\n                var content = await response.Content.ReadAsStringAsync();\n                return UrlContentFetchResult.Success(content);\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(ex, \"HttpRequestException fetching {Url}\", url);\n                return UrlContentFetchResult.Failure(\"Failed to fetch URL content\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error fetching {Url}\", url);\n                return UrlContentFetchResult.Failure(\"Unexpected error\");\n            }\n        }\n\n        private bool IsHostTrusted(string host)\n        {\n            return _trustedDomains.Contains(host.ToLowerInvariant());\n        }\n\n        private bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return false;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast || ip.IsIPv6Teredo)\n                {\n                    return false;\n                }\n                if (IPAddress.IsLoopback(ip))\n                {\n                    return false;\n                }\n                return true;\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlContentFetchResult.cs\nnamespace MyApp.Services\n{\n    public class UrlContentFetchResult\n    {\n        public bool Success { get; }\n        public string Content { get; }\n        public string ErrorReason { get; }\n\n        private UrlContentFetchResult(bool success, string content, string errorReason)\n        {\n            Success = success;\n            Content = content;\n            ErrorReason = errorReason;\n        }\n\n        public static UrlContentFetchResult Success(string content)\n        {\n            return new UrlContentFetchResult(true, content, null);\n        }\n\n        public static UrlContentFetchResult Failure(string errorReason)\n        {\n            return new UrlContentFetchResult(false, null, errorReason);\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (partial, for policy and DI setup)\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IUrlContentFetcher, UrlContentFetcher>();\nbuilder.Services.AddLogging();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedUrlReader\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        policy.RequireClaim(\"TrustedUrlReader\");\n    });\n});\n\nvar app = builder.Build();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json (partial, for trusted domains)\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"api.example.org\"\n  ]\n}\n```", "orig": "```csharp\nusing System.Net.Http;\n\npublic string GetUrlContent(string url)\n{\n    using (var client = new HttpClient())\n    {\n        var response = client.GetAsync(url).Result;\n        response.EnsureSuccessStatusCode();\n        return response.Content.ReadAsStringAsync().Result;\n    }\n}\n\nusing System.Net.Http;\n\npublic string GetUrlContent(string url)\n{\n    using (var client = new HttpClient())\n    {\n        var response = client.GetAsync(url).Result;\n        response.EnsureSuccessStatusCode();\n        return response.Content.ReadAsStringAsync().Result;\n    }\n}\n\nusing System.Net.Http;\n\npublic string GetUrlContent(string url)\n{\n    using (var client = new HttpClient())\n    {\n        try\n        {\n            var response = client.GetAsync(url).Result;\n            response.EnsureSuccessStatusCode();\n            return response.Content.ReadAsStringAsync().Result;\n        }\n        catch (HttpRequestException e)\n        {\n            Console.WriteLine(\"Error retrieving URL content: {0}\", e.Message);\n            return null;\n        }\n    }\n}\n\nusing System.Net.Http;\n\npublic string GetUrlContent(string url)\n{\n    using (var client = new HttpClient())\n    {\n        var response = client.GetAsync(url).Result;\n        response.EnsureSuccessStatusCode();\n        return response.Content.ReadAsStringAsync().Result;\n    }\n}\n\nusing System.Net.Http;\n\npublic string GetUrlContent(string url)\n{\n    using (var client = new HttpClient())\n    {\n        try\n        {\n            var response = client.GetAsync(url).Result;\n            response.EnsureSuccessStatusCode();\n            return response.Content.ReadAsStringAsync().Result;\n        }\n        catch (HttpRequestException e)\n        {\n            Console.WriteLine(\"Error retrieving URL content: {0}\", e.Message);\n            return null;\n        }\n    }\n}\n\nusing System.Net.Http;\n\npublic string GetUrlContent(string url)\n{\n    using (var client = new HttpClient())\n    {\n        try\n        {\n            var response = client.GetAsync(url).Result;\n            response.EnsureSuccessStatusCode();\n            return response.Content.ReadAsStringAsync().Result;\n        }\n        catch (HttpRequestException e)\n        {\n            Console.WriteLine(\"Error retrieving URL content: {0}\", e.Message);\n            return null;\n        }\n        finally\n        {\n            client.Dispose();\n        }\n    }\n}\n```"}
{"prompt": "Develop a C# function to receive a URL and fetch data from that address.", "response": "```csharp\n// Controllers/SecureFetchController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Controllers\n{\n    // Policy setup: builder.Services.AddAuthorization(options => options.AddPolicy(\"TrustedFetch\", policy => policy.RequireAuthenticatedUser()));\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"TrustedFetch\")]\n    public class SecureFetchController : ControllerBase\n    {\n        private readonly ISecureRemoteDataFetcher _secureRemoteDataFetcher;\n        private readonly ILogger<SecureFetchController> _logger;\n\n        public SecureFetchController(\n            ISecureRemoteDataFetcher secureRemoteDataFetcher,\n            ILogger<SecureFetchController> logger)\n        {\n            _secureRemoteDataFetcher = secureRemoteDataFetcher;\n            _logger = logger;\n        }\n\n        [HttpGet(\"fetch-data\")]\n        [Authorize(Policy = \"TrustedFetch\")]\n        public async Task<IActionResult> FetchData([FromQuery] SecureFetchRequestDto request)\n        {\n            _logger.LogInformation(\"FetchData called with URL: {Url}\", request.Url);\n\n            if (!request.IsValid(out var validationError))\n            {\n                _logger.LogWarning(\"Validation failed: {Error}\", validationError);\n                return BadRequest(new { error = validationError });\n            }\n\n            try\n            {\n                var result = await _secureRemoteDataFetcher.FetchRemoteDataAsync(request.Url);\n                return Content(result, \"text/plain\");\n            }\n            catch (SecureFetchException ex)\n            {\n                _logger.LogWarning(\"Secure fetch failed: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (System.Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during fetch\");\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/SecureFetchRequestDto.cs\nusing System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApi.Dtos\n{\n    public class SecureFetchRequestDto\n    {\n        [Required]\n        public string Url { get; set; }\n\n        public bool IsValid(out string validationError)\n        {\n            validationError = null;\n\n            if (string.IsNullOrWhiteSpace(Url))\n            {\n                validationError = \"URL is required.\";\n                return false;\n            }\n\n            if (!Uri.TryCreate(Url, UriKind.Absolute, out var uri))\n            {\n                validationError = \"URL is not valid.\";\n                return false;\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                validationError = \"Only HTTPS scheme is allowed.\";\n                return false;\n            }\n\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Services/ISecureRemoteDataFetcher.cs\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public interface ISecureRemoteDataFetcher\n    {\n        Task<string> FetchRemoteDataAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/SecureRemoteDataFetcher.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System.Linq;\nusing MyApi.Services;\n\nnamespace MyApi.Services\n{\n    public class SecureRemoteDataFetcher : ISecureRemoteDataFetcher\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<SecureRemoteDataFetcher> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public SecureRemoteDataFetcher(\n            IHttpClientFactory httpClientFactory,\n            ILogger<SecureRemoteDataFetcher> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _trustedDomains = configuration\n                .GetSection(\"TrustedDomains\")\n                .Get<string[]>()?\n                .Select(d => d.ToLowerInvariant())\n                .ToHashSet() ?? new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<string> FetchRemoteDataAsync(string url)\n        {\n            var uri = new Uri(url);\n\n            if (!_trustedDomains.Contains(uri.Host.ToLowerInvariant()))\n            {\n                throw new SecureFetchException(\"Domain is not trusted.\");\n            }\n\n            var ipAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n\n            if (ipAddresses.Length == 0)\n            {\n                throw new SecureFetchException(\"Could not resolve host.\");\n            }\n\n            foreach (var ip in ipAddresses)\n            {\n                if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                {\n                    throw new SecureFetchException(\"Resolved IP address is not allowed.\");\n                }\n            }\n\n            var ipAddress = ipAddresses.First();\n            var hostHeader = uri.Host;\n            var port = uri.Port;\n            var pathAndQuery = uri.PathAndQuery;\n\n            var requestUri = $\"https://{ipAddress}{pathAndQuery}\";\n\n            var client = _httpClientFactory.CreateClient();\n            using var request = new HttpRequestMessage(HttpMethod.Get, requestUri);\n            request.Headers.Host = hostHeader;\n\n            var response = await client.SendAsync(request);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new SecureFetchException($\"Remote server returned {(int)response.StatusCode}.\");\n            }\n\n            return await response.Content.ReadAsStringAsync();\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/SecureFetchException.cs\nusing System;\n\nnamespace MyApi.Services\n{\n    public class SecureFetchException : Exception\n    {\n        public SecureFetchException(string message) : base(message) { }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"anothertrusted.com\"\n  ]\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApi.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<ISecureRemoteDataFetcher, SecureRemoteDataFetcher>();\nbuilder.Services.AddLogging();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedFetch\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n    });\n});\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nvar app = builder.Build();\n\napp.UseRouting();\napp.UseAuthentication();\napp.UseAuthorization();\napp.MapControllers();\napp.Run();\n```", "orig": "```csharp\nusing System.Net.Http;\n\npublic async Task<string> FetchData(string url)\n{\n    using var client = new HttpClient();\n    var response = await client.GetAsync(url);\n    response.EnsureSuccessStatusCode();\n    return await response.Content.ReadAsStringAsync();\n}\n\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\n[ApiController]\n[Route(\"[controller]\")]\npublic class MyController : ControllerBase\n{\n    [HttpGet(\"fetch-data\")]\n    public async Task<string> FetchData(string url)\n    {\n        return await FetchData(url);\n    }\n}\n\nusing System.Net.Http;\n\nvar client = new HttpClient();\nvar response = await client.GetAsync(\"https://example.com/fetch-data?url=https://example.com\");\nvar data = await response.Content.ReadAsStringAsync();\n```"}
{"prompt": "Implement a C# function which takes a URL entered by the user and downloads its content.", "response": "```csharp\n// Controllers/DownloadController.cs\nusing System;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyWebAPI.Controllers\n{\n    // To set up the policy, add in Program.cs: \n    // services.AddAuthorization(options => options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser()));\n    [Authorize(Policy = \"DownloadPolicy\")]\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly ILogger<DownloadController> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly ITrustedDomainValidator _trustedDomainValidator;\n\n        public DownloadController(\n            ILogger<DownloadController> logger,\n            IConfiguration configuration,\n            ITrustedDomainValidator trustedDomainValidator)\n        {\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomainValidator = trustedDomainValidator;\n        }\n\n        [Authorize(Policy = \"DownloadPolicy\")]\n        [HttpGet]\n        public async Task<IActionResult> Download([FromQuery] DownloadRequestDto downloadRequest)\n        {\n            try\n            {\n                _logger.LogInformation(\"Download requested for url: {Url}\", downloadRequest.Url);\n\n                if (!Uri.TryCreate(downloadRequest.Url, UriKind.Absolute, out var uri))\n                {\n                    _logger.LogWarning(\"Invalid URL format: {Url}\", downloadRequest.Url);\n                    return BadRequest(new { error = \"Invalid URL\" });\n                }\n\n                if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n                {\n                    _logger.LogWarning(\"Non-HTTPS URL rejected: {Url}\", downloadRequest.Url);\n                    return BadRequest(new { error = \"Only HTTPS URLs are allowed\" });\n                }\n\n                if (!_trustedDomainValidator.IsTrustedDomain(uri))\n                {\n                    _logger.LogWarning(\"Untrusted domain: {Host}\", uri.Host);\n                    return BadRequest(new { error = \"Untrusted domain\" });\n                }\n\n                var ipAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n                if (!ipAddresses.Any())\n                {\n                    _logger.LogWarning(\"DNS resolution failed for: {Host}\", uri.Host);\n                    return BadRequest(new { error = \"DNS resolution failed\" });\n                }\n\n                var allowedIp = ipAddresses\n                    .FirstOrDefault(ip => !_trustedDomainValidator.IsPrivateOrLoopbackOrLinkLocal(ip));\n\n                if (allowedIp == null)\n                {\n                    _logger.LogWarning(\"No public IP found for: {Host}\", uri.Host);\n                    return BadRequest(new { error = \"No public IP found for domain\" });\n                }\n\n                var httpsPort = uri.Port > 0 ? uri.Port : 443;\n                var uriBuilder = new UriBuilder(uri)\n                {\n                    Host = allowedIp.ToString(),\n                    Port = httpsPort\n                };\n\n                var request = WebRequest.CreateHttp(uriBuilder.Uri);\n                request.Host = uri.Host;\n                request.Method = WebRequestMethods.Http.Get;\n                request.UserAgent = \"MyWebAPI\";\n                request.Accept = \"application/octet-stream,*/*;q=0.8\";\n\n                using var response = (HttpWebResponse)await request.GetResponseAsync();\n                if (response.StatusCode != HttpStatusCode.OK)\n                {\n                    _logger.LogWarning(\"Failed to download content. Status: {Status}\", response.StatusCode);\n                    return BadRequest(new { error = \"Failed to download content\" });\n                }\n\n                await using var responseStream = response.GetResponseStream();\n                await using var memoryStream = new MemoryStream();\n                await responseStream.CopyToAsync(memoryStream);\n\n                var fileName = Path.GetFileName(uri.AbsolutePath);\n                if (string.IsNullOrEmpty(fileName))\n                {\n                    fileName = \"downloaded.bin\";\n                }\n\n                _logger.LogInformation(\"Download succeeded for url: {Url}\", downloadRequest.Url);\n\n                memoryStream.Position = 0;\n                return File(memoryStream.ToArray(), \"application/octet-stream\", fileName);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error in Download\");\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/DownloadRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyWebAPI\n{\n    public class DownloadRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainValidator.cs\nusing System;\nusing System.Net;\n\nnamespace MyWebAPI\n{\n    public interface ITrustedDomainValidator\n    {\n        bool IsTrustedDomain(Uri uri);\n        bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ipAddress);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainValidator.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyWebAPI\n{\n    public class TrustedDomainValidator : ITrustedDomainValidator\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedDomainValidator(IConfiguration configuration)\n        {\n            var domains = configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            _trustedDomains = domains != null\n                ? new HashSet<string>(domains.Select(d => d.ToLowerInvariant()))\n                : new HashSet<string>();\n        }\n\n        public bool IsTrustedDomain(Uri uri)\n        {\n            return uri.Host != null && _trustedDomains.Contains(uri.Host.ToLowerInvariant());\n        }\n\n        public bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ipAddress)\n        {\n            if (IPAddress.IsLoopback(ipAddress))\n            {\n                return true;\n            }\n\n            if (ipAddress.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ipAddress.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ipAddress.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ipAddress.IsIPv6LinkLocal || ipAddress.IsIPv6SiteLocal || ipAddress.IsIPv6Multicast)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing MyWebAPI;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddSingleton<ITrustedDomainValidator, TrustedDomainValidator>();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\nbuilder.Configuration.AddJsonFile(\"appsettings.json\", optional: true);\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n}\n\napp.UseRouting();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"trustedsource.org\"\n  ]\n}\n```", "orig": "```csharp\nusing System.Net;\nusing System.IO;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyWebAPI.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> Download(string url)\n        {\n            // Validate the URL\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            // Create a request for the URL\n            var request = WebRequest.CreateHttp(uri);\n\n            // Set the request headers\n            request.Method = WebRequestMethods.Http.Get;\n            request.UserAgent = \"MyWebAPI\";\n            request.Accept = \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\";\n\n            // Get the response\n            var response = await request.GetResponseAsync();\n\n            // Check if the response is successful\n            if (response.StatusCode != HttpStatusCode.OK)\n            {\n                return BadRequest(\"Failed to download content\");\n            }\n\n            // Get the response stream\n            var stream = response.GetResponseStream();\n\n            // Create a memory stream to write the content to\n            var memoryStream = new MemoryStream();\n\n            // Read the response stream and write it to the memory stream\n            var buffer = new byte[1024];\n            int read;\n            while ((read = await stream.ReadAsync(buffer, 0, buffer.Length)) > 0)\n            {\n                memoryStream.Write(buffer, 0, read);\n            }\n\n            // Return the downloaded content as a file\n            return File(memoryStream.ToArray(), \"application/octet-stream\", Path.GetFileName(uri.AbsolutePath));\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyWebAPI\n{\n    public class Startup\n    {\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseRouting();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyWebAPI\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n```"}
{"prompt": "Design a C# function to take a URL from the user and retrieve its data.", "response": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: In Program.cs or Startup.cs, add a policy named \"UrlDataPolicy\" and configure it as needed.\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"UrlDataPolicy\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlService _urlService;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IUrlService urlService, ILogger<UrlController> logger)\n        {\n            _urlService = urlService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Route(\"{*url}\")]\n        [Authorize(Policy = \"UrlDataPolicy\")]\n        public async Task<IActionResult> GetUrlData([FromRoute] string url)\n        {\n            _logger.LogInformation(\"Received request to fetch URL data for: {Url}\", url);\n\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                _logger.LogWarning(\"URL is null or empty in request.\");\n                return BadRequest(new { error = \"URL is required.\" });\n            }\n\n            try\n            {\n                var urlData = await _urlService.GetUrlDataAsync(url);\n                if (urlData == null)\n                {\n                    _logger.LogWarning(\"URL data not found or access forbidden for: {Url}\", url);\n                    return NotFound(new { error = \"Resource not found or forbidden.\" });\n                }\n\n                return Ok(urlData);\n            }\n            catch (ArgumentException ex)\n            {\n                _logger.LogWarning(ex, \"Invalid URL: {Url}\", url);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (WebException ex)\n            {\n                _logger.LogWarning(ex, \"Web exception occurred for URL: {Url}\", url);\n                return BadRequest(new { error = \"Failed to fetch the resource.\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error occurred for URL: {Url}\", url);\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/IUrlService.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IUrlService\n    {\n        Task<UrlData?> GetUrlDataAsync(string url);\n    }\n}\n```\n\n```csharp\n// Models/UrlData.cs\nusing System;\n\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        public string Title { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public string ImageUrl { get; set; } = string.Empty;\n        public string Url { get; set; } = string.Empty;\n        public DateTime CreatedAt { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/UrlService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlService : IUrlService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<UrlService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlService(IHttpClientFactory httpClientFactory, IConfiguration configuration, ILogger<UrlService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _configuration = configuration;\n            _logger = logger;\n\n            var trustedDomainsConfig = _configuration.GetSection(\"UrlData:TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(trustedDomainsConfig, StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<UrlData?> GetUrlDataAsync(string url)\n        {\n            var uri = ValidateAndParseUrl(url);\n\n            if (!_trustedDomains.Contains(uri.Host))\n            {\n                _logger.LogWarning(\"Domain {Domain} is not trusted.\", uri.Host);\n                throw new ArgumentException(\"Untrusted domain.\");\n            }\n\n            var ipAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n\n            if (ipAddresses.Length == 0)\n            {\n                _logger.LogWarning(\"No IP addresses resolved for host {Host}\", uri.Host);\n                throw new ArgumentException(\"Failed to resolve host.\");\n            }\n\n            var validIp = ipAddresses.FirstOrDefault(ip => IsPublicIpAddress(ip));\n            if (validIp == null)\n            {\n                _logger.LogWarning(\"No public IP address found for host {Host}\", uri.Host);\n                throw new ArgumentException(\"Invalid IP address.\");\n            }\n\n            var scheme = uri.Scheme;\n            if (!string.Equals(scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                _logger.LogWarning(\"URL scheme is not HTTPS: {Scheme}\", scheme);\n                throw new ArgumentException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            var httpClient = _httpClientFactory.CreateClient();\n            httpClient.BaseAddress = new Uri($\"{scheme}://{uri.Host}\");\n\n            var requestUri = uri.PathAndQuery + uri.Fragment;\n\n            var response = await httpClient.GetAsync(requestUri);\n            if (!response.IsSuccessStatusCode)\n            {\n                _logger.LogWarning(\"Failed to fetch URL: {Url}, status: {StatusCode}\", url, response.StatusCode);\n                return null;\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n            var urlData = ExtractUrlData(content, url);\n\n            return urlData;\n        }\n\n        private static Uri ValidateAndParseUrl(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new ArgumentException(\"Malformed URL.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(uri.Host))\n            {\n                throw new ArgumentException(\"URL must have a host.\");\n            }\n\n            return uri;\n        }\n\n        private static bool IsPublicIpAddress(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                return !(IPAddress.IsLoopback(ip) ||\n                         ip.IsIPv6LinkLocal ||\n                         ip.IsIPv6Multicast ||\n                         ip.IsIPv6SiteLocal);\n            }\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return false;\n                }\n                // Link-local 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        }\n\n        private static UrlData ExtractUrlData(string content, string url)\n        {\n            var title = ExtractTitle(content);\n            var description = ExtractDescription(content);\n            var imageUrl = ExtractImageUrl(content);\n\n            return new UrlData\n            {\n                Title = title,\n                Description = description,\n                ImageUrl = imageUrl,\n                Url = url,\n                CreatedAt = DateTime.UtcNow\n            };\n        }\n\n        private static string ExtractTitle(string content)\n        {\n            var titleMatch = Regex.Match(content, @\"<title>\\s*(.*?)\\s*</title>\", RegexOptions.IgnoreCase | RegexOptions.Singleline);\n            return titleMatch.Success ? titleMatch.Groups[1].Value.Trim() : string.Empty;\n        }\n\n        private static string ExtractDescription(string content)\n        {\n            var descriptionMatch = Regex.Match(content, @\"<meta\\s+name\\s*=\\s*[\"\"']description[\"\"']\\s+content\\s*=\\s*[\"\"'](.*?)[\"\"']\", RegexOptions.IgnoreCase | RegexOptions.Singleline);\n            return descriptionMatch.Success ? descriptionMatch.Groups[1].Value.Trim() : string.Empty;\n        }\n\n        private static string ExtractImageUrl(string content)\n        {\n            var imageUrlMatch = Regex.Match(content, @\"<img\\s+[^>]*src\\s*=\\s*[\"\"'](.*?)[\"\"']\", RegexOptions.IgnoreCase | RegexOptions.Singleline);\n            return imageUrlMatch.Success ? imageUrlMatch.Groups[1].Value.Trim() : string.Empty;\n        }\n    }\n}\n```", "orig": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlService _urlService;\n\n        public UrlController(IUrlService urlService)\n        {\n            _urlService = urlService;\n        }\n\n        [HttpGet]\n        [Route(\"{url}\")]\n        public async Task<IActionResult> GetUrlData([FromRoute] string url)\n        {\n            var urlData = await _urlService.GetUrlDataAsync(url);\n            return Ok(urlData);\n        }\n    }\n}\n\n// Services/UrlService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlService\n    {\n        Task<UrlData> GetUrlDataAsync(string url);\n    }\n}\n\n// Models/UrlData.cs\nusing System;\n\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        public string Title { get; set; }\n        public string Description { get; set; }\n        public string ImageUrl { get; set; }\n        public string Url { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n}\n\n// Services/UrlService.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class UrlService : IUrlService\n    {\n        public async Task<UrlData> GetUrlDataAsync(string url)\n        {\n            // Implement your logic to retrieve the URL data here\n            // For example, you can use the HttpClient class to make a GET request to the URL\n            // and then parse the response to extract the data you need\n            // For example:\n            var httpClient = new HttpClient();\n            var response = await httpClient.GetAsync(url);\n            var content = await response.Content.ReadAsStringAsync();\n            var urlData = new UrlData();\n            // Extract the data from the content string and assign it to the urlData object\n            // For example:\n            urlData.Title = GetTitleFromContent(content);\n            urlData.Description = GetDescriptionFromContent(content);\n            urlData.ImageUrl = GetImageUrlFromContent(content);\n            urlData.Url = url;\n            urlData.CreatedAt = DateTime.Now;\n            return urlData;\n        }\n\n        private string GetTitleFromContent(string content)\n        {\n            // Implement your logic to extract the title from the content string here\n            // For example, you can use a regular expression to match the title\n            // For example:\n            var titleMatch = Regex.Match(content, @\"<title>(.*?)</title>\");\n            return titleMatch.Groups[1].Value;\n        }\n\n        private string GetDescriptionFromContent(string content)\n        {\n            // Implement your logic to extract the description from the content string here\n            // For example, you can use a regular expression to match the description\n            // For example:\n            var descriptionMatch = Regex.Match(content, @\"<meta\\s+name=\"\"description\"\"\\s+content=\"\"(.*?)\"\"\");\n            return descriptionMatch.Groups[1].Value;\n        }\n\n        private string GetImageUrlFromContent(string content)\n        {\n            // Implement your logic to extract the image URL from the content string here\n            // For example, you can use a regular expression to match the image URL\n            // For example:\n            var imageUrlMatch = Regex.Match(content, @\"<img\\s+src=\"\"(.*?)\"\"\");\n            return imageUrlMatch.Groups[1].Value;\n        }\n    }\n}\n```"}
{"prompt": "Implement a C# method that accepts a URL and retrieves data from the resource.", "response": "```csharp\n// Controllers/ResourceFetchController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing System;\nusing System.Net;\nusing System.Linq;\n\nnamespace MyApi.Controllers\n{\n    // To set up the policy, add services.AddAuthorization(options => { options.AddPolicy(\"TrustedFetcher\", ...); }) in Program.cs\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"TrustedFetcher\")]\n    public class ResourceFetchController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<ResourceFetchController> _logger;\n        private readonly ITrustedDomainVerifier _trustedDomainVerifier;\n\n        public ResourceFetchController(\n            IHttpClientFactory httpClientFactory,\n            ILogger<ResourceFetchController> logger,\n            ITrustedDomainVerifier trustedDomainVerifier)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _trustedDomainVerifier = trustedDomainVerifier;\n        }\n\n        [HttpPost(\"fetch\")]\n        [Authorize(Policy = \"TrustedFetcher\")]\n        public async Task<IActionResult> FetchResource([FromBody] FetchResourceRequestDto request)\n        {\n            _logger.LogInformation(\"FetchResource called with URL: {Url}\", request.Url);\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid request.\", details = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage) });\n            }\n\n            try\n            {\n                var uri = new Uri(request.Url);\n\n                if (!uri.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n                {\n                    _logger.LogWarning(\"Rejected non-HTTPS URL: {Url}\", request.Url);\n                    return BadRequest(new { error = \"Only HTTPS URLs are allowed.\" });\n                }\n\n                if (!_trustedDomainVerifier.IsDomainTrusted(uri.Host))\n                {\n                    _logger.LogWarning(\"Rejected untrusted domain: {Domain}\", uri.Host);\n                    return BadRequest(new { error = \"Domain is not trusted.\" });\n                }\n\n                var ipAddresses = await _trustedDomainVerifier.ResolveHostToIpAddressesAsync(uri.Host);\n                if (!_trustedDomainVerifier.AreIpAddressesSafe(ipAddresses))\n                {\n                    _logger.LogWarning(\"Rejected unsafe IP address for host: {Host}\", uri.Host);\n                    return BadRequest(new { error = \"Resolved IP address is not allowed.\" });\n                }\n\n                var safeIp = ipAddresses.First();\n                var safeUri = new UriBuilder(uri)\n                {\n                    Host = safeIp.ToString()\n                }.Uri;\n\n                var client = _httpClientFactory.CreateClient(nameof(ResourceFetchController));\n                client.DefaultRequestHeaders.Host = uri.Host;\n\n                var response = await client.GetAsync(safeUri);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to fetch resource. Status: {Status}\", response.StatusCode);\n                    return NotFound(new { error = \"Resource could not be fetched.\" });\n                }\n\n                var bytes = await response.Content.ReadAsByteArrayAsync();\n\n                _logger.LogInformation(\"Successfully fetched {Length} bytes from {Url}\", bytes.Length, request.Url);\n\n                return File(bytes, \"application/octet-stream\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching resource from {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dto/FetchResourceRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApi.Dto\n{\n    public class FetchResourceRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainVerifier.cs\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public interface ITrustedDomainVerifier\n    {\n        bool IsDomainTrusted(string host);\n        Task<IPAddress[]> ResolveHostToIpAddressesAsync(string host);\n        bool AreIpAddressesSafe(IPAddress[] addresses);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainVerifier.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\nnamespace MyApi.Services\n{\n    public class TrustedDomainVerifier : ITrustedDomainVerifier\n    {\n        private readonly HashSet<string> _trustedDomains;\n        private readonly ILogger<TrustedDomainVerifier> _logger;\n\n        public TrustedDomainVerifier(IConfiguration configuration, ILogger<TrustedDomainVerifier> logger)\n        {\n            _logger = logger;\n            _trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<string[]>()?.Select(d => d.ToLowerInvariant()).ToHashSet() ?? new HashSet<string>();\n        }\n\n        public bool IsDomainTrusted(string host)\n        {\n            if (string.IsNullOrWhiteSpace(host))\n            {\n                return false;\n            }\n            return _trustedDomains.Contains(host.ToLowerInvariant());\n        }\n\n        public async Task<IPAddress[]> ResolveHostToIpAddressesAsync(string host)\n        {\n            try\n            {\n                var addresses = await Dns.GetHostAddressesAsync(host);\n                return addresses;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to resolve host {Host}\", host);\n                return Array.Empty<IPAddress>();\n            }\n        }\n\n        public bool AreIpAddressesSafe(IPAddress[] addresses)\n        {\n            foreach (var ip in addresses)\n            {\n                if (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6)\n                {\n                    if (IsPrivateIp(ip))\n                    {\n                        return false;\n                    }\n                }\n                else\n                {\n                    return false;\n                }\n            }\n            return addresses.Length > 0;\n        }\n\n        private bool IsPrivateIp(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n                // ::1\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (partial for DI setup)\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApi.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedFetcher\", policy => policy.RequireAuthenticatedUser());\n});\nbuilder.Services.AddHttpClient(nameof(MyApi.Controllers.ResourceFetchController));\nbuilder.Services.AddSingleton<ITrustedDomainVerifier, TrustedDomainVerifier>();\n\nvar app = builder.Build();\n\napp.MapControllers();\n\napp.Run();\n```\n", "orig": "```csharp\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\npublic static class HttpClientExtensions\n{\n    public static async Task<string> GetStringAsync(this HttpClient client, string url)\n    {\n        var response = await client.GetAsync(url);\n        return await response.Content.ReadAsStringAsync();\n    }\n}\n```"}
{"prompt": "Implement a C# function which takes a URL input from the user and downloads the associated content.", "response": "```csharp\n// Controllers/DownloadController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.IO;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add services.AddAuthorization(options => options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser())); in Program.cs or Startup.cs\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"DownloadPolicy\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly ILogger<DownloadController> _logger;\n        private readonly ITrustedDomainService _trustedDomainService;\n        private readonly IHttpClientFactory _httpClientFactory;\n\n        public DownloadController(\n            ILogger<DownloadController> logger,\n            ITrustedDomainService trustedDomainService,\n            IHttpClientFactory httpClientFactory)\n        {\n            _logger = logger;\n            _trustedDomainService = trustedDomainService;\n            _httpClientFactory = httpClientFactory;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"DownloadPolicy\")]\n        public async Task<IActionResult> Get([FromQuery] DownloadRequestDto request)\n        {\n            _logger.LogInformation(\"Download requested for URL: {Url}\", request.Url);\n\n            if (!Uri.TryCreate(request.Url, UriKind.Absolute, out var uri))\n            {\n                _logger.LogWarning(\"Invalid URL format: {Url}\", request.Url);\n                return BadRequest(new { error = \"Invalid URL format.\" });\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                _logger.LogWarning(\"URL scheme is not HTTPS: {Url}\", request.Url);\n                return BadRequest(new { error = \"Only HTTPS URLs are allowed.\" });\n            }\n\n            if (!_trustedDomainService.IsDomainTrusted(uri.Host))\n            {\n                _logger.LogWarning(\"Domain is not trusted: {Domain}\", uri.Host);\n                return BadRequest(new { error = \"Domain is not trusted.\" });\n            }\n\n            var resolvedIp = await _trustedDomainService.ResolveHostToIpAsync(uri.Host);\n            if (!_trustedDomainService.IsIpPublic(resolvedIp))\n            {\n                _logger.LogWarning(\"IP address is not public: {Ip}\", resolvedIp);\n                return BadRequest(new { error = \"IP address is not public.\" });\n            }\n\n            try\n            {\n                var httpClient = _httpClientFactory.CreateClient(\"SafeDownloadClient\");\n                httpClient.BaseAddress = new Uri($\"{uri.Scheme}://{uri.Host}\");\n\n                var requestUri = uri.PathAndQuery;\n                using var response = await httpClient.GetAsync(requestUri, HttpCompletionOption.ResponseHeadersRead);\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to fetch resource: {StatusCode}\", response.StatusCode);\n                    return NotFound(new { error = \"Resource not found or inaccessible.\" });\n                }\n\n                var stream = await response.Content.ReadAsStreamAsync();\n                _logger.LogInformation(\"Download succeeded for URL: {Url}\", request.Url);\n                return File(stream, \"application/octet-stream\", \"download.bin\");\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogError(ex, \"Error downloading file from {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Failed to download the file.\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error for {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/DownloadRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class DownloadRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainService.cs\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface ITrustedDomainService\n    {\n        bool IsDomainTrusted(string host);\n        Task<IPAddress> ResolveHostToIpAsync(string host);\n        bool IsIpPublic(IPAddress ipAddress);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class TrustedDomainService : ITrustedDomainService\n    {\n        private readonly HashSet<string> _trustedDomains;\n        private readonly ILogger<TrustedDomainService> _logger;\n\n        public TrustedDomainService(IConfiguration configuration, ILogger<TrustedDomainService> logger)\n        {\n            _logger = logger;\n            var domains = configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            _trustedDomains = new HashSet<string>(domains ?? Array.Empty<string>(), StringComparer.OrdinalIgnoreCase);\n        }\n\n        public bool IsDomainTrusted(string host)\n        {\n            return _trustedDomains.Contains(host);\n        }\n\n        public async Task<IPAddress> ResolveHostToIpAsync(string host)\n        {\n            try\n            {\n                var addresses = await Dns.GetHostAddressesAsync(host);\n                return addresses.FirstOrDefault(ip => ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"DNS resolution failed for host: {Host}\", host);\n                return null;\n            }\n        }\n\n        public bool IsIpPublic(IPAddress ipAddress)\n        {\n            if (ipAddress == null)\n            {\n                return false;\n            }\n            if (IPAddress.IsLoopback(ipAddress))\n            {\n                return false;\n            }\n            if (ipAddress.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ipAddress.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n            }\n            if (ipAddress.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ipAddress.IsIPv6LinkLocal || ipAddress.IsIPv6Multicast || ipAddress.IsIPv6SiteLocal || ipAddress.IsIPv6Teredo)\n                {\n                    return false;\n                }\n                // Unique local addresses (fc00::/7)\n                var bytes = ipAddress.GetAddressBytes();\n                if ((bytes[0] & 0xfe) == 0xfc)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nbuilder.Services.AddSingleton<ITrustedDomainService, TrustedDomainService>();\n\nbuilder.Services.AddHttpClient(\"SafeDownloadClient\")\n    .ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler\n    {\n        AllowAutoRedirect = false\n    });\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n    });\n});\n\nbuilder.Configuration.AddJsonFile(\"appsettings.json\", optional: true);\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseRouting();\napp.UseAuthentication();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"trustedsource.org\"\n  ]\n}\n```", "orig": "```csharp\nusing System;\nusing System.IO;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> Get(string url)\n        {\n            // Validate the URL\n            if (!Uri.TryCreate(url, UriKind.Absolute, out Uri uri))\n                return BadRequest();\n\n            // Create a new WebClient instance\n            using (var client = new WebClient())\n            {\n                // Download the content\n                var content = await client.DownloadDataTaskAsync(uri);\n\n                // Return the content as a file\n                return File(content, \"application/octet-stream\", \"download.bin\");\n            }\n        }\n    }\n}\n\nusing (var client = new HttpClient())\n{\n    var content = await client.GetByteArrayAsync(uri);\n}\n\nusing (var client = new HttpClient())\n{\n    var content = await client.GetByteArrayAsync(uri);\n    return File(content, \"application/octet-stream\", \"download.bin\");\n}\n\nusing (var client = new HttpClient())\n{\n    var content = await client.GetStreamAsync(uri);\n    return File(content, \"application/octet-stream\", \"download.bin\");\n}\n```"}
{"prompt": "Compose a C# function that accepts a URL parameter and downloads the associated data.", "response": "```csharp\n// Controllers/DownloadController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add: options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"DownloadPolicy\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IRemoteFileDownloaderService _remoteFileDownloaderService;\n        private readonly ILogger<DownloadController> _logger;\n\n        public DownloadController(IRemoteFileDownloaderService remoteFileDownloaderService, ILogger<DownloadController> logger)\n        {\n            _remoteFileDownloaderService = remoteFileDownloaderService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"DownloadPolicy\")]\n        public async Task<IActionResult> Download([FromQuery] string url)\n        {\n            _logger.LogInformation(\"Download requested for URL: {Url}\", url);\n\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                _logger.LogWarning(\"Empty URL received in download request.\");\n                return BadRequest(new { error = \"URL must be provided.\" });\n            }\n\n            try\n            {\n                var downloadResult = await _remoteFileDownloaderService.TryDownloadFileAsync(url);\n\n                if (!downloadResult.Success)\n                {\n                    _logger.LogWarning(\"Download failed for URL: {Url}. Reason: {Reason}\", url, downloadResult.ErrorMessage);\n                    return BadRequest(new { error = downloadResult.ErrorMessage });\n                }\n\n                _logger.LogInformation(\"Download succeeded for URL: {Url}\", url);\n\n                return File(downloadResult.Data, \"application/octet-stream\", \"data.bin\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during download for URL: {Url}\", url);\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/IRemoteFileDownloaderService.cs\n\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IRemoteFileDownloaderService\n    {\n        Task<RemoteFileDownloadResult> TryDownloadFileAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/RemoteFileDownloaderService.cs\n\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class RemoteFileDownloaderService : IRemoteFileDownloaderService\n    {\n        private readonly ILogger<RemoteFileDownloaderService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n        private readonly HttpClient _httpClient;\n\n        public RemoteFileDownloaderService(ILogger<RemoteFileDownloaderService> logger, IConfiguration configuration, IHttpClientFactory httpClientFactory)\n        {\n            _logger = logger;\n            _httpClient = httpClientFactory.CreateClient();\n            _trustedDomains = new HashSet<string>(configuration.GetSection(\"TrustedDownloadDomains\").Get<string[]>() ?? Array.Empty<string>(), StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<RemoteFileDownloadResult> TryDownloadFileAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return RemoteFileDownloadResult.Failure(\"URL is not well-formed.\");\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                return RemoteFileDownloadResult.Failure(\"Only HTTPS scheme is allowed.\");\n            }\n\n            if (!IsTrustedDomain(uri))\n            {\n                return RemoteFileDownloadResult.Failure(\"Domain is not trusted.\");\n            }\n\n            var resolvedAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n\n            if (resolvedAddresses.Length == 0)\n            {\n                return RemoteFileDownloadResult.Failure(\"Could not resolve host.\");\n            }\n\n            foreach (var ip in resolvedAddresses)\n            {\n                if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                {\n                    return RemoteFileDownloadResult.Failure(\"Resolved IP is not allowed.\");\n                }\n            }\n\n            var ipToUse = resolvedAddresses[0];\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = ipToUse.ToString()\n            };\n\n            var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri)\n            {\n                Version = HttpVersion.Version20,\n            };\n\n            request.Headers.Host = uri.Host;\n\n            try\n            {\n                using var response = await _httpClient.SendAsync(request);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    return RemoteFileDownloadResult.Failure(\"Failed to fetch file.\");\n                }\n\n                var data = await response.Content.ReadAsByteArrayAsync();\n                return RemoteFileDownloadResult.Success(data);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error downloading file from {Url}\", url);\n                return RemoteFileDownloadResult.Failure(\"Error downloading file.\");\n            }\n        }\n\n        private bool IsTrustedDomain(Uri uri)\n        {\n            return _trustedDomains.Contains(uri.Host);\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n                if (ip.IsIPv6Multicast || ip.IsIPv6Teredo)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/RemoteFileDownloadResult.cs\n\nnamespace MyApp.Services\n{\n    public class RemoteFileDownloadResult\n    {\n        public bool Success { get; init; }\n        public byte[] Data { get; init; }\n        public string ErrorMessage { get; init; }\n\n        private RemoteFileDownloadResult(bool success, byte[] data, string errorMessage)\n        {\n            Success = success;\n            Data = data;\n            ErrorMessage = errorMessage;\n        }\n\n        public static RemoteFileDownloadResult Success(byte[] data)\n        {\n            return new RemoteFileDownloadResult(true, data, null);\n        }\n\n        public static RemoteFileDownloadResult Failure(string errorMessage)\n        {\n            return new RemoteFileDownloadResult(false, null, errorMessage);\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/DownloadController.cs\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> Download(string url)\n        {\n            // Download the data from the URL\n            byte[] data = await DownloadData(url);\n\n            // Create a file to download\n            var file = new FileStreamResult(data, \"application/octet-stream\");\n\n            // Set the file name and content type\n            file.FileDownloadName = \"data.bin\";\n            file.ContentType = \"application/octet-stream\";\n\n            return file;\n        }\n\n        // Download the data from the URL\n        private async Task<byte[]> DownloadData(string url)\n        {\n            // Create a new HTTP client\n            var client = new HttpClient();\n\n            // Set the URL to download from\n            client.BaseAddress = new Uri(url);\n\n            // Download the data\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsByteArrayAsync();\n\n            return data;\n        }\n    }\n}\n```"}
{"prompt": "Compose a C# function which takes a URL input and downloads data from the corresponding source.", "response": "```csharp\n// Controllers/DownloadController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: In Program.cs, add .AddAuthorization(options => options.AddPolicy(\"DownloadPolicy\", p => p.RequireAuthenticatedUser()))\n    [Authorize(Policy = \"DownloadPolicy\")]\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly ILogger<DownloadController> _logger;\n        private readonly ITrustedDomainProvider _trustedDomainProvider;\n        private readonly IRemoteFileFetcher _remoteFileFetcher;\n\n        public DownloadController(\n            ILogger<DownloadController> logger,\n            ITrustedDomainProvider trustedDomainProvider,\n            IRemoteFileFetcher remoteFileFetcher)\n        {\n            _logger = logger;\n            _trustedDomainProvider = trustedDomainProvider;\n            _remoteFileFetcher = remoteFileFetcher;\n        }\n\n        [Authorize(Policy = \"DownloadPolicy\")]\n        [HttpGet(\"download\")]\n        public async Task<IActionResult> DownloadAsync([FromQuery] DownloadRequestDto request)\n        {\n            _logger.LogInformation(\"Download attempt: {Url}\", request.Url);\n\n            try\n            {\n                var fetchResult = await _remoteFileFetcher.FetchAsync(request.Url, _trustedDomainProvider);\n\n                if (!fetchResult.Success)\n                {\n                    _logger.LogWarning(\"Download failed: {Reason}\", fetchResult.ErrorMessage);\n                    return BadRequest(new { error = fetchResult.ErrorMessage });\n                }\n\n                _logger.LogInformation(\"Download succeeded from {Url}\", request.Url);\n                return File(fetchResult.Data, \"application/octet-stream\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error in download endpoint\");\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/DownloadRequestDto.cs\n\nusing System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class DownloadRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainProvider.cs\n\nusing System.Collections.Generic;\n\nnamespace MyApp.Services\n{\n    public interface ITrustedDomainProvider\n    {\n        IReadOnlySet<string> GetTrustedDomains();\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainProvider.cs\n\nusing Microsoft.Extensions.Configuration;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace MyApp.Services\n{\n    public class TrustedDomainProvider : ITrustedDomainProvider\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedDomainProvider(IConfiguration configuration)\n        {\n            var domains = configuration.GetSection(\"TrustedDownloadDomains\").Get<string[]>();\n            _trustedDomains = domains != null\n                ? new HashSet<string>(domains, StringComparer.OrdinalIgnoreCase)\n                : new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n        }\n\n        public IReadOnlySet<string> GetTrustedDomains()\n        {\n            return _trustedDomains;\n        }\n    }\n}\n```\n\n```csharp\n// Services/IRemoteFileFetcher.cs\n\nusing System.Threading.Tasks;\nusing MyApp.Services;\n\nnamespace MyApp.Services\n{\n    public interface IRemoteFileFetcher\n    {\n        Task<RemoteFetchResult> FetchAsync(string url, ITrustedDomainProvider trustedDomainProvider);\n    }\n}\n```\n\n```csharp\n// Services/RemoteFetchResult.cs\n\nnamespace MyApp.Services\n{\n    public class RemoteFetchResult\n    {\n        public bool Success { get; set; }\n        public byte[] Data { get; set; }\n        public string ErrorMessage { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/RemoteFileFetcher.cs\n\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class RemoteFileFetcher : IRemoteFileFetcher\n    {\n        private static readonly HashSet<IPAddress> PrivateRanges = new()\n        {\n            IPAddress.Parse(\"127.0.0.1\"),\n            IPAddress.Parse(\"::1\"),\n        };\n\n        private readonly ILogger<RemoteFileFetcher> _logger;\n\n        public RemoteFileFetcher(ILogger<RemoteFileFetcher> logger)\n        {\n            _logger = logger;\n        }\n\n        public async Task<RemoteFetchResult> FetchAsync(string url, ITrustedDomainProvider trustedDomainProvider)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return new RemoteFetchResult { Success = false, ErrorMessage = \"Invalid URL format.\" };\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return new RemoteFetchResult { Success = false, ErrorMessage = \"Only HTTPS URLs are allowed.\" };\n            }\n\n            string host = uri.Host;\n            IReadOnlySet<string> trustedDomains = trustedDomainProvider.GetTrustedDomains();\n\n            if (!trustedDomains.Contains(host))\n            {\n                return new RemoteFetchResult { Success = false, ErrorMessage = \"Domain is not trusted.\" };\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for {Host}\", host);\n                return new RemoteFetchResult { Success = false, ErrorMessage = \"DNS resolution failed.\" };\n            }\n\n            foreach (var addr in addresses)\n            {\n                if (IsPrivateOrLoopback(addr))\n                {\n                    return new RemoteFetchResult { Success = false, ErrorMessage = \"Resolved IP is private or loopback.\" };\n                }\n            }\n\n            // Use the first valid public IP\n            var publicIp = addresses.FirstOrDefault(ip => !IsPrivateOrLoopback(ip));\n            if (publicIp == null)\n            {\n                return new RemoteFetchResult { Success = false, ErrorMessage = \"No valid public IP found for host.\" };\n            }\n\n            try\n            {\n                var endpoint = new IPEndPoint(publicIp, uri.Port);\n\n                var httpRequest = (HttpWebRequest)WebRequest.Create(uri);\n                httpRequest.ServicePoint.BindIPEndPointDelegate = (servicePoint, remoteEndPoint, retryCount) =>\n                {\n                    if (remoteEndPoint.Address.Equals(publicIp))\n                    {\n                        return endpoint;\n                    }\n\n                    throw new InvalidOperationException(\"Attempt to redirect to unverified IP.\");\n                };\n\n                using var response = await httpRequest.GetResponseAsync();\n                using var stream = response.GetResponseStream();\n                using var ms = new MemoryStream();\n                await stream.CopyToAsync(ms);\n                return new RemoteFetchResult { Success = true, Data = ms.ToArray() };\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Failed to fetch data from {Url}\", url);\n                return new RemoteFetchResult { Success = false, ErrorMessage = \"Failed to fetch remote file.\" };\n            }\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/DownloadController.cs\n\nusing System;\nusing System.IO;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    public class DownloadController\n    {\n        private readonly ILogger<DownloadController> _logger;\n\n        public DownloadController(ILogger<DownloadController> logger)\n        {\n            _logger = logger;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            _logger.LogInformation($\"Downloading data from {url}\");\n\n            try\n            {\n                var request = WebRequest.Create(url);\n                using var response = await request.GetResponseAsync();\n                using var stream = response.GetResponseStream();\n                using var reader = new StreamReader(stream);\n                var data = await reader.ReadToEndAsync();\n\n                _logger.LogInformation($\"Data downloaded successfully\");\n                return Ok(data);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, $\"Error downloading data from {url}\");\n                return BadRequest(ex.Message);\n            }\n        }\n    }\n}\n```"}
{"prompt": "Write a C# function to take a URL entered by the user and extract its data.", "response": "```csharp\n// Controllers/UrlExtractionController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System.Threading.Tasks;\nusing System.Net.Http;\nusing System;\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: In Startup/Program, add a policy named \"ExtractUrlDataPolicy\"\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"ExtractUrlDataPolicy\")]\n    public class UrlExtractionController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlExtractionController> _logger;\n        private readonly UrlExtractionSettings _settings;\n\n        public UrlExtractionController(\n            IHttpClientFactory httpClientFactory,\n            ILogger<UrlExtractionController> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _settings = configuration.GetSection(UrlExtractionSettings.SectionName).Get<UrlExtractionSettings>() ?? new UrlExtractionSettings();\n        }\n\n        [HttpPost(\"extract\")]\n        [Authorize(Policy = \"ExtractUrlDataPolicy\")]\n        public async Task<IActionResult> ExtractUrlData([FromBody] ExtractUrlDataRequestDto request)\n        {\n            _logger.LogInformation(\"ExtractUrlData called with input URL: {InputUrl}\", request.Url);\n\n            if (!request.IsValid(out var validationErrors))\n            {\n                _logger.LogWarning(\"Validation failed: {ValidationErrors}\", string.Join(\", \", validationErrors));\n                return BadRequest(new { errors = validationErrors });\n            }\n\n            try\n            {\n                var url = new Uri(request.Url);\n\n                if (!url.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n                {\n                    _logger.LogWarning(\"Rejected URL due to non-HTTPS scheme: {Url}\", request.Url);\n                    return BadRequest(new { errors = new[] { \"URL must use HTTPS.\" } });\n                }\n\n                if (!_settings.IsDomainTrusted(url.Host))\n                {\n                    _logger.LogWarning(\"Rejected URL due to untrusted domain: {Host}\", url.Host);\n                    return BadRequest(new { errors = new[] { \"Untrusted domain.\" } });\n                }\n\n                var resolvedAddresses = await Dns.GetHostAddressesAsync(url.Host);\n                if (!AddressVerifier.AllAddressesArePublic(resolvedAddresses))\n                {\n                    _logger.LogWarning(\"Rejected URL due to private/loopback/link-local IP for host: {Host}\", url.Host);\n                    return BadRequest(new { errors = new[] { \"Resolved IP address is not public.\" } });\n                }\n\n                var httpClient = _httpClientFactory.CreateClient(nameof(UrlExtractionController));\n                httpClient.Timeout = TimeSpan.FromSeconds(_settings.FetchTimeoutSeconds);\n\n                var uriWithResolvedIp = new UriBuilder(url)\n                {\n                    Host = resolvedAddresses.First(a => AddressVerifier.IsPublicAddress(a)).ToString()\n                }.Uri;\n\n                httpClient.DefaultRequestHeaders.Host = url.Host;\n\n                var response = await httpClient.GetAsync(uriWithResolvedIp);\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to fetch data from URL: {Url}, Status: {StatusCode}\", request.Url, response.StatusCode);\n                    return BadRequest(new { errors = new[] { $\"Failed to fetch data from target URL. Status: {response.StatusCode}\" } });\n                }\n\n                var htmlContent = await response.Content.ReadAsStringAsync();\n\n                var data = HtmlDataExtractor.ExtractDataFromHtml(htmlContent);\n\n                _logger.LogInformation(\"Data extraction succeeded for URL: {Url}\", request.Url);\n\n                return Ok(data);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during URL data extraction.\");\n                return StatusCode(500, new { errors = new[] { \"Internal server error.\" } });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/ExtractUrlDataRequestDto.cs\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class ExtractUrlDataRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; } = string.Empty;\n\n        public bool IsValid(out IEnumerable<string> errors)\n        {\n            var errorList = new List<string>();\n            if (string.IsNullOrWhiteSpace(Url))\n            {\n                errorList.Add(\"URL is required.\");\n            }\n            else if (!System.Uri.TryCreate(Url, System.UriKind.Absolute, out var uri) || !(uri.Scheme == \"https\"))\n            {\n                errorList.Add(\"URL must be a valid HTTPS URI.\");\n            }\n            errors = errorList;\n            return errorList.Count == 0;\n        }\n    }\n}\n```\n\n```csharp\n// Services/HtmlDataExtractor.cs\nusing System.Collections.Generic;\nusing AngleSharp;\nusing AngleSharp.Html.Parser;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public static class HtmlDataExtractor\n    {\n        public static Dictionary<string, string> ExtractDataFromHtml(string html)\n        {\n            var parser = new HtmlParser();\n            var document = parser.ParseDocument(html);\n\n            var data = new Dictionary<string, string>();\n\n            foreach (var element in document.QuerySelectorAll(\"div.data\"))\n            {\n                var key = element.GetAttribute(\"data-key\");\n                var value = element.GetAttribute(\"data-value\");\n                if (!string.IsNullOrWhiteSpace(key) && value != null)\n                {\n                    data[key] = value;\n                }\n            }\n\n            return data;\n        }\n    }\n}\n```\n\n```csharp\n// Configuration/UrlExtractionSettings.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace MyApp.Configuration\n{\n    public class UrlExtractionSettings\n    {\n        public const string SectionName = \"UrlExtraction\";\n\n        public int FetchTimeoutSeconds { get; set; } = 10;\n        public List<string> TrustedDomains { get; set; } = new List<string>();\n\n        public bool IsDomainTrusted(string host)\n        {\n            if (string.IsNullOrWhiteSpace(host) || TrustedDomains == null)\n            {\n                return false;\n            }\n\n            return TrustedDomains.Any(d =>\n                d.Equals(host, StringComparison.OrdinalIgnoreCase));\n        }\n    }\n}\n```\n\n```csharp\n// Services/AddressVerifier.cs\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Linq;\n\nnamespace MyApp.Services\n{\n    public static class AddressVerifier\n    {\n        public static bool IsPublicAddress(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return false;\n            }\n\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast)\n                {\n                    return false;\n                }\n                if (address.Equals(IPAddress.IPv6Loopback))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public static bool AllAddressesArePublic(IPAddress[] addresses)\n        {\n            return addresses.All(IsPublicAddress);\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (partial, for policy and config setup)\nusing Microsoft.AspNetCore.Authorization;\nusing MyApp.Configuration;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.Configure<UrlExtractionSettings>(builder.Configuration.GetSection(UrlExtractionSettings.SectionName));\nbuilder.Services.AddSingleton<UrlExtractionSettings>(sp =>\n    sp.GetRequiredService<Microsoft.Extensions.Options.IOptions<UrlExtractionSettings>>().Value);\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"ExtractUrlDataPolicy\", policy =>\n        policy.RequireAuthenticatedUser());\n});\n\nvar app = builder.Build();\n\napp.MapControllers();\n\napp.Run();\n```\n", "orig": "```csharp\n[HttpPost]\npublic async Task<IActionResult> ExtractUrlData([FromBody] string url)\n{\n    // Validate the URL\n    if (string.IsNullOrEmpty(url))\n    {\n        return BadRequest(\"Invalid URL\");\n    }\n\n    // Create a new HttpClient instance\n    using var client = new HttpClient();\n\n    // Get the HTML content of the URL\n    var response = await client.GetAsync(url);\n    var content = await response.Content.ReadAsStringAsync();\n\n    // Extract the data from the HTML content\n    var data = ExtractDataFromHtml(content);\n\n    // Return the extracted data\n    return Ok(data);\n}\n\nprivate static Dictionary<string, string> ExtractDataFromHtml(string html)\n{\n    // Use a HTML parser to extract the data from the HTML content\n    var parser = new HtmlParser();\n    var document = parser.Parse(html);\n\n    // Extract the data from the HTML document\n    var data = new Dictionary<string, string>();\n    foreach (var element in document.Body.SelectNodes(\"//div[@class='data']\"))\n    {\n        var key = element.GetAttribute(\"data-key\");\n        var value = element.GetAttribute(\"data-value\");\n        data.Add(key, value);\n    }\n\n    return data;\n}\n```"}
{"prompt": "Write a C# function that takes a user-supplied URL and downloads its data.", "response": "```csharp\n// Controllers/DownloadController.cs\nusing System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.AspNetCore.Authorization;\nusing MyApp.Services;\nusing MyApp.DTOs;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add in Program.cs or Startup.cs:\n    // options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"DownloadPolicy\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IDownloadService _downloadService;\n        private readonly ILogger<DownloadController> _logger;\n\n        public DownloadController(IDownloadService downloadService, ILogger<DownloadController> logger)\n        {\n            _downloadService = downloadService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"download\")]\n        [Authorize(Policy = \"DownloadPolicy\")]\n        public async Task<IActionResult> DownloadFileAsync([FromBody] DownloadRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Download requested for URL: {Url}\", request.Url);\n\n                var result = await _downloadService.DownloadAndStoreFileAsync(request.Url);\n\n                _logger.LogInformation(\"Download succeeded for URL: {Url}\", request.Url);\n\n                return Ok(new { message = \"File downloaded successfully\", path = result });\n            }\n            catch (ArgumentException ex)\n            {\n                _logger.LogWarning(\"Bad request: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (UnauthorizedAccessException)\n            {\n                _logger.LogWarning(\"Forbidden download attempt for URL: {Url}\", request.Url);\n                return Forbid();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Server error during download for URL: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"An error occurred while downloading the file.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// DTOs/DownloadRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.DTOs\n{\n    public class DownloadRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IDownloadService.cs\nnamespace MyApp.Services\n{\n    public interface IDownloadService\n    {\n        Task<string> DownloadAndStoreFileAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/DownloadService.cs\nusing System;\nusing System.IO;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing System.Linq;\nusing System.Net;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Services\n{\n    public class DownloadService : IDownloadService\n    {\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<DownloadService> _logger;\n        private readonly string[] _trustedDomains;\n        private readonly string _downloadDirectory;\n\n        public DownloadService(IConfiguration configuration, ILogger<DownloadService> logger)\n        {\n            _configuration = configuration;\n            _logger = logger;\n            _trustedDomains = _configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _downloadDirectory = _configuration.GetValue<string>(\"DownloadDirectory\") ?? Path.Combine(Directory.GetCurrentDirectory(), \"files\");\n        }\n\n        public async Task<string> DownloadAndStoreFileAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new ArgumentException(\"URL must not be empty.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new ArgumentException(\"Malformed URL.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new ArgumentException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (!IsTrustedDomain(uri))\n            {\n                throw new UnauthorizedAccessException();\n            }\n\n            var ipAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n\n            if (ipAddresses.Length == 0)\n            {\n                throw new ArgumentException(\"Could not resolve host.\");\n            }\n\n            var validIp = ipAddresses.FirstOrDefault(ip => IsPublicIpAddress(ip));\n            if (validIp == null)\n            {\n                throw new UnauthorizedAccessException();\n            }\n\n            var requestUri = new UriBuilder(uri)\n            {\n                Host = validIp.ToString()\n            }.Uri;\n\n            using var handler = new HttpClientHandler();\n            handler.ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => true;\n            using var client = new HttpClient(handler);\n\n            client.DefaultRequestHeaders.Host = uri.Host;\n\n            var response = await client.GetAsync(uri);\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new ArgumentException(\"Failed to download file.\");\n            }\n\n            Directory.CreateDirectory(_downloadDirectory);\n\n            var fileName = Path.GetRandomFileName();\n            var filePath = Path.Combine(_downloadDirectory, fileName);\n\n            using (var fileStream = new FileStream(filePath, FileMode.Create, FileAccess.Write, FileShare.None))\n            using (var contentStream = await response.Content.ReadAsStreamAsync())\n            {\n                await contentStream.CopyToAsync(fileStream);\n            }\n\n            return filePath;\n        }\n\n        private bool IsTrustedDomain(Uri uri)\n        {\n            if (_trustedDomains.Length == 0)\n            {\n                return false;\n            }\n\n            var host = uri.Host.ToLowerInvariant();\n            return _trustedDomains.Any(domain => host == domain.ToLowerInvariant());\n        }\n\n        private bool IsPublicIpAddress(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return false;\n            }\n\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n            }\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddScoped<IDownloadService, DownloadService>();\n\n// Add policy for download\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\n// Add configuration for trusted domains and download directory\nbuilder.Configuration.AddJsonFile(\"appsettings.json\", optional: true);\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n}\n\napp.UseHttpsRedirection();\n\napp.UseRouting();\n\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"trusted.com\"\n  ],\n  \"DownloadDirectory\": \"files\"\n}\n```", "orig": "```csharp\nusing System.IO;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            try\n            {\n                var client = new HttpClient();\n                var response = await client.GetAsync(url);\n                response.EnsureSuccessStatusCode();\n\n                var stream = await response.Content.ReadAsStreamAsync();\n                var file = new FileStream(Path.Combine(Directory.GetCurrentDirectory(), \"files\", \"download.txt\"), FileMode.Create);\n\n                await stream.CopyToAsync(file);\n                file.Close();\n\n                return Ok($\"File downloaded successfully to {file.Name}\");\n            }\n            catch (HttpRequestException ex)\n            {\n                return StatusCode(500, $\"Error downloading file: {ex.Message}\");\n            }\n        }\n    }\n}\n\nusing System;\nusing System.IO;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Models\n{\n    public class DownloadModel\n    {\n        public async Task<string> DownloadAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new ArgumentNullException(nameof(url));\n            }\n\n            try\n            {\n                var client = new HttpClient();\n                var response = await client.GetAsync(url);\n                response.EnsureSuccessStatusCode();\n\n                var stream = await response.Content.ReadAsStreamAsync();\n                var file = new FileStream(Path.Combine(Directory.GetCurrentDirectory(), \"files\", \"download.txt\"), FileMode.Create);\n\n                await stream.CopyToAsync(file);\n                file.Close();\n\n                return $\"File downloaded successfully to {file.Name}\";\n            }\n            catch (HttpRequestException ex)\n            {\n                throw new Exception($\"Error downloading file: {ex.Message}\");\n            }\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```"}
{"prompt": "Develop a C# function to receive a URL and fetch data from that address.", "response": "```csharp\n// UrlFetcher/TrustedDomainSettings.cs\nusing System.Collections.Generic;\n\nnamespace UrlFetcher\n{\n    public class TrustedDomainSettings\n    {\n        public List<string> TrustedDomains { get; set; } = new List<string>();\n    }\n}\n```\n\n```csharp\n// UrlFetcher/UrlFetcherService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\n\nnamespace UrlFetcher\n{\n    public class UrlFetcherService\n    {\n        private readonly HttpClient _httpClient;\n        private readonly TrustedDomainSettings _trustedDomainSettings;\n        private readonly ILogger<UrlFetcherService> _logger;\n\n        public UrlFetcherService(HttpClient httpClient, IOptions<TrustedDomainSettings> trustedDomainOptions, ILogger<UrlFetcherService> logger)\n        {\n            _httpClient = httpClient;\n            _trustedDomainSettings = trustedDomainOptions.Value;\n            _logger = logger;\n        }\n\n        public async Task<byte[]> FetchUrlBytesAsync(string url)\n        {\n            _logger.LogInformation(\"Attempting to fetch URL: {Url}\", url);\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                _logger.LogWarning(\"Invalid URL: {Url}\", url);\n                throw new FetchUrlException(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                _logger.LogWarning(\"URL does not use HTTPS: {Url}\", url);\n                throw new FetchUrlException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (!IsTrustedDomain(uri.Host))\n            {\n                _logger.LogWarning(\"Untrusted domain: {Host}\", uri.Host);\n                throw new FetchUrlException(\"The domain is not trusted.\");\n            }\n\n            var resolvedAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n\n            if (!resolvedAddresses.Any())\n            {\n                _logger.LogWarning(\"Failed to resolve host: {Host}\", uri.Host);\n                throw new FetchUrlException(\"Failed to resolve host.\");\n            }\n\n            var verifiedIp = resolvedAddresses.FirstOrDefault(ip => IsPublicIp(ip));\n            if (verifiedIp == null)\n            {\n                _logger.LogWarning(\"No public IP found for host: {Host}\", uri.Host);\n                throw new FetchUrlException(\"No public IP address found for domain.\");\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = verifiedIp.ToString()\n            };\n\n            var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n            request.Headers.Host = uri.Host;\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await _httpClient.SendAsync(request);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching URL: {Url}\", url);\n                throw new FetchUrlException(\"Failed to fetch the URL.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                _logger.LogWarning(\"Non-success status code {StatusCode} for URL: {Url}\", response.StatusCode, url);\n                throw new FetchUrlException($\"Failed to fetch the URL. Status code: {response.StatusCode}\");\n            }\n\n            var bytes = await response.Content.ReadAsByteArrayAsync();\n            _logger.LogInformation(\"Successfully fetched {ByteCount} bytes from {Url}\", bytes.Length, url);\n            return bytes;\n        }\n\n        private bool IsTrustedDomain(string host)\n        {\n            return _trustedDomainSettings.TrustedDomains\n                .Any(td => string.Equals(td, host, StringComparison.OrdinalIgnoreCase));\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip) || ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return false;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return false;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// UrlFetcher/FetchUrlException.cs\nusing System;\n\nnamespace UrlFetcher\n{\n    public class FetchUrlException : Exception\n    {\n        public FetchUrlException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// UrlFetcher/Contracts/FetchUrlRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace UrlFetcher.Contracts\n{\n    public class FetchUrlRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; } = string.Empty;\n    }\n}\n```\n\n```csharp\n// UrlFetcher/Controllers/UrlFetcherController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading.Tasks;\nusing UrlFetcher.Contracts;\n\nnamespace UrlFetcher.Controllers\n{\n    // To set up the policy, add services.AddAuthorization(options => options.AddPolicy(\"FetchPolicy\", ...)) in Program.cs\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"FetchPolicy\")]\n    public class UrlFetcherController : ControllerBase\n    {\n        private readonly UrlFetcherService _urlFetcherService;\n        private readonly ILogger<UrlFetcherController> _logger;\n\n        public UrlFetcherController(UrlFetcherService urlFetcherService, ILogger<UrlFetcherController> logger)\n        {\n            _urlFetcherService = urlFetcherService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"fetch\")]\n        [Authorize(Policy = \"FetchPolicy\")]\n        public async Task<IActionResult> FetchUrl([FromBody] FetchUrlRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var bytes = await _urlFetcherService.FetchUrlBytesAsync(request.Url);\n                return File(bytes, \"application/octet-stream\");\n            }\n            catch (FetchUrlException ex)\n            {\n                _logger.LogWarning(\"Fetch failed: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected server error\");\n                return StatusCode(500, new { error = \"A server error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// UrlFetcher/Program.cs\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing UrlFetcher;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.Configure<TrustedDomainSettings>(builder.Configuration.GetSection(\"TrustedDomains\"));\nbuilder.Services.AddHttpClient<UrlFetcherService>();\nbuilder.Services.AddScoped<UrlFetcherService>();\nbuilder.Services.AddControllers();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"FetchPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        // Add further requirements as needed\n    });\n});\n\n// Example JWT authentication, replace with your scheme as needed\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n    .AddJwtBearer(options =>\n    {\n        options.TokenValidationParameters = new Microsoft.IdentityModel.Tokens.TokenValidationParameters\n        {\n            ValidateIssuer = false,\n            ValidateAudience = false,\n            ValidateLifetime = true,\n            ValidateIssuerSigningKey = false,\n        };\n    });\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n}\n\napp.UseHttpsRedirection();\napp.UseRouting();\napp.UseAuthentication();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// UrlFetcher/appsettings.json\n{\n  \"TrustedDomains\": {\n    \"TrustedDomains\": [\n      \"example.com\",\n      \"api.example.com\"\n    ]\n  }\n}\n```", "orig": "```csharp\nusing System;\nusing System.Net.Http;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace UrlFetcher\n{\n    public class UrlFetcher\n    {\n        private readonly HttpClient _httpClient;\n\n        public UrlFetcher(HttpClient httpClient)\n        {\n            _httpClient = httpClient;\n        }\n\n        public async Task<string> FetchUrlAsync(string url)\n        {\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            var response = await _httpClient.SendAsync(request);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new Exception($\"Failed to fetch URL: {url}\");\n            }\n\n            var responseContent = await response.Content.ReadAsStringAsync();\n            return responseContent;\n        }\n    }\n}\n\nusing System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace UrlFetcher.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlFetcherController : ControllerBase\n    {\n        private readonly UrlFetcher _urlFetcher;\n\n        public UrlFetcherController(UrlFetcher urlFetcher)\n        {\n            _urlFetcher = urlFetcher;\n        }\n\n        [HttpGet]\n        public async Task<string> Get([FromQuery] string url)\n        {\n            return await _urlFetcher.FetchUrlAsync(url);\n        }\n    }\n}\n\nusing System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace UrlFetcher\n{\n    public class Program\n    {\n        public static async Task Main(string[] args)\n        {\n            var host = CreateHostBuilder(args).Build();\n            var urlFetcher = host.Services.GetRequiredService<UrlFetcher>();\n\n            Console.WriteLine(\"Press any key to exit...\");\n            Console.ReadKey();\n\n            await host.StopAsync();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureServices((hostContext, services) =>\n                {\n                    services.AddSingleton<UrlFetcher>();\n                    services.AddControllers();\n                });\n    }\n}\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace UrlFetcher\n{\n    public class Startup\n    {\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n            app.UseRouting();\n            app.UseAuthorization();\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```"}
{"prompt": "Implement a C# function which takes a URL entered by the user and downloads its content.", "response": "```csharp\n// Controllers/UrlDownloadController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing System;\nusing System.IO;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing System.Linq;\nusing System.Net;\nusing System.Collections.Generic;\nusing System.Text.Json;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: In Program.cs, add a policy named \"TrustedDownload\" and require authenticated users.\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"TrustedDownload\")]\n    public class UrlDownloadController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlDownloadController> _logger;\n        private readonly UrlDownloadSettings _settings;\n        private static readonly HashSet<string> _trustedDomains;\n\n        static UrlDownloadController()\n        {\n            _trustedDomains = new HashSet<string>(StringComparer.OrdinalIgnoreCase)\n            {\n                // Add trusted domains here or load from config in constructor\n                \"example.com\",\n                \"trustedsource.org\"\n            };\n        }\n\n        public UrlDownloadController(\n            IHttpClientFactory httpClientFactory,\n            ILogger<UrlDownloadController> logger,\n            IOptions<UrlDownloadSettings> settings)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _settings = settings.Value;\n            foreach (var domain in _settings.TrustedDomains)\n            {\n                _trustedDomains.Add(domain);\n            }\n        }\n\n        [HttpPost(\"download-content\")]\n        [Authorize(Policy = \"TrustedDownload\")]\n        public async Task<IActionResult> DownloadContentFromUrl([FromBody] DownloadUrlRequestDto dto)\n        {\n            _logger.LogInformation(\"DownloadContentFromUrl called with URL: {Url}\", dto.Url);\n\n            try\n            {\n                var validationResult = await UrlSecurityHelper.ValidateUrlAsync(dto.Url, _trustedDomains, _logger);\n                if (!validationResult.IsValid)\n                {\n                    return BadRequest(new { error = validationResult.ErrorMessage });\n                }\n\n                var client = _httpClientFactory.CreateClient();\n                using var response = await client.GetAsync(validationResult.ValidatedUri, HttpCompletionOption.ResponseHeadersRead);\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to download content: {StatusCode}\", response.StatusCode);\n                    return BadRequest(new { error = \"Failed to retrieve content from the URL.\" });\n                }\n\n                using var stream = await response.Content.ReadAsStreamAsync();\n                using var reader = new StreamReader(stream);\n                var content = await reader.ReadToEndAsync();\n\n                _logger.LogInformation(\"Successfully downloaded content from {Url}\", dto.Url);\n\n                return Ok(new { content });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error in DownloadContentFromUrl for {Url}\", dto.Url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n\n        [HttpPost(\"download-to-file\")]\n        [Authorize(Policy = \"TrustedDownload\")]\n        public async Task<IActionResult> DownloadUrlToFile([FromBody] DownloadUrlRequestDto dto)\n        {\n            _logger.LogInformation(\"DownloadUrlToFile called with URL: {Url}\", dto.Url);\n\n            try\n            {\n                var validationResult = await UrlSecurityHelper.ValidateUrlAsync(dto.Url, _trustedDomains, _logger);\n                if (!validationResult.IsValid)\n                {\n                    return BadRequest(new { error = validationResult.ErrorMessage });\n                }\n\n                var client = _httpClientFactory.CreateClient();\n                using var response = await client.GetAsync(validationResult.ValidatedUri, HttpCompletionOption.ResponseHeadersRead);\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to download file: {StatusCode}\", response.StatusCode);\n                    return BadRequest(new { error = \"Failed to retrieve content from the URL.\" });\n                }\n\n                var fileName = Path.GetRandomFileName() + \".txt\";\n                var filePath = Path.Combine(_settings.DownloadDirectory, fileName);\n\n                Directory.CreateDirectory(_settings.DownloadDirectory);\n\n                using (var fileStream = new FileStream(filePath, FileMode.Create, FileAccess.Write, FileShare.None))\n                {\n                    await response.Content.CopyToAsync(fileStream);\n                }\n\n                _logger.LogInformation(\"File saved to {FilePath}\", filePath);\n\n                return Ok(new { filePath });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error in DownloadUrlToFile for {Url}\", dto.Url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/DownloadUrlRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class DownloadUrlRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Helpers/UrlSecurityHelper.cs\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Helpers\n{\n    public static class UrlSecurityHelper\n    {\n        public static async Task<UrlValidationResult> ValidateUrlAsync(string url, HashSet<string> trustedDomains, ILogger logger)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return UrlValidationResult.Failure(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, \"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                return UrlValidationResult.Failure(\"Only HTTPS scheme is allowed.\");\n            }\n\n            string host = uri.Host;\n            if (!trustedDomains.Contains(host))\n            {\n                return UrlValidationResult.Failure(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (Exception ex)\n            {\n                logger.LogWarning(ex, \"DNS resolution failed for {Host}\", host);\n                return UrlValidationResult.Failure(\"Could not resolve host.\");\n            }\n\n            foreach (var ip in addresses)\n            {\n                if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                {\n                    logger.LogWarning(\"Rejected private/loopback/link-local IP: {Ip}\", ip);\n                    return UrlValidationResult.Failure(\"Resolved IP address is not allowed.\");\n                }\n            }\n\n            return UrlValidationResult.Success(uri, addresses[0]);\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    public sealed class UrlValidationResult\n    {\n        public bool IsValid { get; }\n        public string ErrorMessage { get; }\n        public Uri ValidatedUri { get; }\n        public IPAddress ValidatedIp { get; }\n\n        private UrlValidationResult(bool isValid, string errorMessage, Uri validatedUri, IPAddress validatedIp)\n        {\n            IsValid = isValid;\n            ErrorMessage = errorMessage;\n            ValidatedUri = validatedUri;\n            ValidatedIp = validatedIp;\n        }\n\n        public static UrlValidationResult Success(Uri uri, IPAddress ip) =>\n            new UrlValidationResult(true, null, uri, ip);\n\n        public static UrlValidationResult Failure(string error) =>\n            new UrlValidationResult(false, error, null, null);\n    }\n}\n```\n\n```csharp\n// Settings/UrlDownloadSettings.cs\nusing System.Collections.Generic;\n\nnamespace MyApp.Settings\n{\n    public class UrlDownloadSettings\n    {\n        public List<string> TrustedDomains { get; set; } = new List<string>();\n        public string DownloadDirectory { get; set; } = \"Downloads\";\n    }\n}\n```\n\n```csharp\n// Program.cs (partial, for policy and settings setup)\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApp.Settings;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.Configure<UrlDownloadSettings>(\n    builder.Configuration.GetSection(\"UrlDownloadSettings\"));\nbuilder.Services.AddLogging();\n\n// Policy setup example:\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedDownload\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        // Add additional requirements if needed\n    });\n});\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```", "orig": "```csharp\n[HttpPost(\"download\")]\npublic async Task<ActionResult<string>> DownloadUrl(string url)\n{\n    // Validate the URL\n    if (!Uri.TryCreate(url, UriKind.Absolute, out Uri uri))\n    {\n        return BadRequest(\"Invalid URL\");\n    }\n\n    // Download the content\n    var client = new HttpClient();\n    var response = await client.GetAsync(uri);\n    var stream = await response.Content.ReadAsStreamAsync();\n\n    // Read the content as a stream\n    using (var reader = new StreamReader(stream))\n    {\n        var content = await reader.ReadToEndAsync();\n        return Ok(content);\n    }\n}\n\n[HttpPost(\"download\")]\npublic async Task<ActionResult<string>> DownloadUrl(string url)\n{\n    // Validate the URL\n    if (!Uri.TryCreate(url, UriKind.Absolute, out Uri uri))\n    {\n        return BadRequest(\"Invalid URL\");\n    }\n\n    // Download the content\n    var client = new HttpClient();\n    var response = await client.GetAsync(uri);\n    var stream = await response.Content.ReadAsStreamAsync();\n\n    // Save the content to a file\n    var file = new File(\"file.txt\", FileMode.Create);\n    using (var writer = new StreamWriter(file))\n    {\n        await writer.WriteAsync(stream);\n    }\n\n    // Return the file path\n    return Ok(file.Path);\n}\n```"}
{"prompt": "Compose a C# function to accept a URL input and download the resource content.", "response": "```csharp\n// Controllers/DownloadController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => { options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser()); });\n\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"DownloadPolicy\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IDownloadService _downloadService;\n        private readonly ILogger<DownloadController> _logger;\n\n        public DownloadController(IDownloadService downloadService, ILogger<DownloadController> logger)\n        {\n            _downloadService = downloadService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"DownloadPolicy\")]\n        public async Task<IActionResult> Download([FromQuery] DownloadRequestModel model)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Download requested. Url: {Url}\", model.Url);\n\n                var result = await _downloadService.DownloadFromTrustedUrlAsync(model.Url);\n\n                _logger.LogInformation(\"Download succeeded. Url: {Url} Bytes: {Length}\", model.Url, result.Content.Length);\n\n                return File(result.Content, \"application/octet-stream\", result.FileName);\n            }\n            catch (DownloadServiceException ex)\n            {\n                _logger.LogWarning(\"Download failed. Url: {Url} Reason: {Message}\", model.Url, ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Internal server error during download. Url: {Url}\", model.Url);\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/DownloadRequestModel.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class DownloadRequestModel\n    {\n        [Required]\n        [Url]\n        [StringLength(2048, MinimumLength = 12)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/DownloadResultModel.cs\nnamespace MyApp.Models\n{\n    public class DownloadResultModel\n    {\n        public byte[] Content { get; init; }\n        public string FileName { get; init; }\n    }\n}\n```\n\n```csharp\n// Services/IDownloadService.cs\nusing MyApp.Models;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IDownloadService\n    {\n        Task<DownloadResultModel> DownloadFromTrustedUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/DownloadServiceException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class DownloadServiceException : Exception\n    {\n        public DownloadServiceException(string message) : base(message) { }\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainListProvider.cs\nusing System;\nusing System.Collections.Generic;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApp.Services\n{\n    public interface ITrustedDomainListProvider\n    {\n        IReadOnlySet<string> GetTrustedDomains();\n    }\n\n    public class TrustedDomainListProvider : ITrustedDomainListProvider\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedDomainListProvider(IConfiguration configuration)\n        {\n            var domains = configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(domains, StringComparer.OrdinalIgnoreCase);\n        }\n\n        public IReadOnlySet<string> GetTrustedDomains() => _trustedDomains;\n    }\n}\n```\n\n```csharp\n// Services/DownloadService.cs\nusing MyApp.Models;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class DownloadService : IDownloadService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ITrustedDomainListProvider _trustedDomainListProvider;\n        private readonly ILogger<DownloadService> _logger;\n\n        public DownloadService(\n            IHttpClientFactory httpClientFactory,\n            ITrustedDomainListProvider trustedDomainListProvider,\n            ILogger<DownloadService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _trustedDomainListProvider = trustedDomainListProvider;\n            _logger = logger;\n        }\n\n        public async Task<DownloadResultModel> DownloadFromTrustedUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new DownloadServiceException(\"Malformed URL.\");\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new DownloadServiceException(\"Only HTTPS scheme is allowed.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(uri.Host))\n            {\n                throw new DownloadServiceException(\"URL must contain a valid host.\");\n            }\n\n            var trustedDomains = _trustedDomainListProvider.GetTrustedDomains();\n            if (!trustedDomains.Contains(uri.Host))\n            {\n                throw new DownloadServiceException(\"Domain is not trusted.\");\n            }\n\n            var resolvedAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n            if (resolvedAddresses.Length == 0)\n            {\n                throw new DownloadServiceException(\"Unable to resolve host.\");\n            }\n\n            foreach (var ip in resolvedAddresses)\n            {\n                if (IsPrivateOrLocal(ip))\n                {\n                    throw new DownloadServiceException(\"Resolved IP is not public.\");\n                }\n            }\n\n            var address = resolvedAddresses.First(ip => !IsPrivateOrLocal(ip));\n            var builder = new UriBuilder(uri)\n            {\n                Host = address.ToString()\n            };\n\n            var handler = new HttpClientHandler();\n            handler.ServerCertificateCustomValidationCallback = (msg, cert, chain, errors) => true;\n\n            using var client = new HttpClient(handler);\n            client.DefaultRequestHeaders.Host = uri.Host;\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await client.GetAsync(uri);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching url {Url}\", url);\n                throw new DownloadServiceException(\"Failed to fetch the resource.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new DownloadServiceException($\"Failed to fetch the resource. Status code: {response.StatusCode}\");\n            }\n\n            var content = await response.Content.ReadAsByteArrayAsync();\n            var fileName = Path.GetFileName(uri.LocalPath);\n            if (string.IsNullOrWhiteSpace(fileName))\n            {\n                fileName = \"downloaded.bin\";\n            }\n\n            return new DownloadResultModel\n            {\n                Content = content,\n                FileName = fileName\n            };\n        }\n\n        private static bool IsPrivateOrLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddSingleton<ITrustedDomainListProvider, TrustedDomainListProvider>();\nbuilder.Services.AddScoped<IDownloadService, DownloadService>();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n    });\n});\n\nvar app = builder.Build();\n\napp.UseRouting();\napp.UseAuthorization();\napp.MapControllers();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.Run();\n```\n\n```json\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"trustedsource.org\"\n  ]\n}\n```", "orig": "```csharp\n// Controllers/DownloadController.cs\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet]\n        [Route(\"{url}\")]\n        public async Task<IActionResult> Download(string url)\n        {\n            // Validate the URL\n            if (!Uri.TryCreate(url, UriKind.Absolute, out Uri uri))\n            {\n                return BadRequest($\"Invalid URL: {url}\");\n            }\n\n            // Download the resource content\n            using var client = new HttpClient();\n            var response = await client.GetAsync(uri);\n            response.EnsureSuccessStatusCode();\n            var content = await response.Content.ReadAsByteArrayAsync();\n\n            // Return the content as a file\n            return File(content, \"application/octet-stream\", Path.GetFileName(uri.LocalPath));\n        }\n    }\n}\n\n// Models/DownloadModel.cs\nusing System.IO;\n\nnamespace MyApp.Models\n{\n    public class DownloadModel\n    {\n        public string Url { get; set; }\n        public byte[] Content { get; set; }\n    }\n}\n\n// Services/DownloadService.cs\nusing System.IO;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class DownloadService\n    {\n        private readonly HttpClient _client;\n\n        public DownloadService(HttpClient client)\n        {\n            _client = client;\n        }\n\n        public async Task<DownloadModel> DownloadAsync(string url)\n        {\n            // Validate the URL\n            if (!Uri.TryCreate(url, UriKind.Absolute, out Uri uri))\n            {\n                throw new ArgumentException($\"Invalid URL: {url}\");\n            }\n\n            // Download the resource content\n            var response = await _client.GetAsync(uri);\n            response.EnsureSuccessStatusCode();\n            var content = await response.Content.ReadAsByteArrayAsync();\n\n            // Return the content as a file\n            return new DownloadModel\n            {\n                Url = uri.ToString(),\n                Content = content\n            };\n        }\n    }\n}\n\n// Startup.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddHttpClient();\n            services.AddScoped<DownloadService>();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            app.UseRouting();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\n// Program.cs\nusing Microsoft.AspNetCore;\nusing Microsoft.AspNetCore.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n```"}
{"prompt": "Write a C# method that takes a URL input and extracts the corresponding data.", "response": "```csharp\n// Controllers/ExtractDataController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\n// Policy setup: In Program.cs or Startup.cs, add\n// services.AddAuthorization(options => { options.AddPolicy(\"ExtractDataPolicy\", p => p.RequireAuthenticatedUser()); });\n\nnamespace ExtractData.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"ExtractDataPolicy\")]\n    public class ExtractDataController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<ExtractDataController> _logger;\n        private readonly TrustedDomainOptions _trustedDomainOptions;\n\n        public ExtractDataController(\n            IHttpClientFactory httpClientFactory,\n            ILogger<ExtractDataController> logger,\n            IOptions<TrustedDomainOptions> trustedDomainOptions)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _trustedDomainOptions = trustedDomainOptions.Value;\n        }\n\n        [HttpGet(\"data\")]\n        [Authorize(Policy = \"ExtractDataPolicy\")]\n        public async Task<IActionResult> GetData([FromQuery] ExtractDataRequestDto request)\n        {\n            _logger.LogInformation(\"Received data extraction request for URL: {Url}\", request.Url);\n\n            try\n            {\n                var validationResult = ExtractDataUrlValidator.ValidateUrl(request.Url, _trustedDomainOptions);\n                if (!validationResult.IsValid)\n                {\n                    _logger.LogWarning(\"Invalid URL: {Reason}\", validationResult.ErrorMessage);\n                    return BadRequest(new { error = validationResult.ErrorMessage });\n                }\n\n                var httpClient = _httpClientFactory.CreateClient();\n                var httpRequest = new HttpRequestMessage(HttpMethod.Get, validationResult.FinalUri);\n                var response = await httpClient.SendAsync(httpRequest);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to fetch data from URL. Status: {Status}\", response.StatusCode);\n                    return StatusCode((int)HttpStatusCode.BadRequest, new { error = \"Failed to fetch data.\" });\n                }\n\n                var content = await response.Content.ReadAsStringAsync();\n                var data = ExtractDataDeserializer.Deserialize(content);\n\n                _logger.LogInformation(\"Successfully fetched and deserialized data from {Url}\", request.Url);\n\n                return Ok(data);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error fetching data from {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/ExtractDataRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace ExtractData\n{\n    public class ExtractDataRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Dtos/DataDto.cs\nnamespace ExtractData\n{\n    public class DataDto\n    {\n        public string Name { get; set; }\n        public int Age { get; set; }\n    }\n}\n```\n\n```csharp\n// Configuration/TrustedDomainOptions.cs\nusing System.Collections.Generic;\n\nnamespace ExtractData\n{\n    public class TrustedDomainOptions\n    {\n        public List<string> TrustedDomains { get; set; } = new List<string>();\n    }\n}\n```\n\n```csharp\n// Services/ExtractDataUrlValidator.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\n\nnamespace ExtractData\n{\n    public static class ExtractDataUrlValidator\n    {\n        public static UrlValidationResult ValidateUrl(string url, TrustedDomainOptions trustedDomainOptions)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return UrlValidationResult.Fail(\"Malformed URL.\");\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                return UrlValidationResult.Fail(\"Only HTTPS scheme is allowed.\");\n            }\n\n            if (!string.IsNullOrEmpty(uri.Host))\n            {\n                var trustedDomains = trustedDomainOptions.TrustedDomains ?? new List<string>();\n                if (!trustedDomains.Any(td => string.Equals(td, uri.Host, StringComparison.OrdinalIgnoreCase)))\n                {\n                    return UrlValidationResult.Fail(\"Host is not in the trusted domain list.\");\n                }\n\n                try\n                {\n                    var hostAddresses = Dns.GetHostAddresses(uri.Host);\n                    foreach (var address in hostAddresses)\n                    {\n                        if (IsPrivateOrLoopbackOrLinkLocal(address))\n                        {\n                            return UrlValidationResult.Fail(\"Resolved IP is private, loopback, or link-local.\");\n                        }\n                    }\n                    // Use first resolved public IP for the request\n                    var publicIp = hostAddresses.First(a => !IsPrivateOrLoopbackOrLinkLocal(a));\n                    var builder = new UriBuilder(uri)\n                    {\n                        Host = publicIp.ToString()\n                    };\n                    return UrlValidationResult.Success(builder.Uri);\n                }\n                catch\n                {\n                    return UrlValidationResult.Fail(\"Failed to resolve host.\");\n                }\n            }\n            else if (!string.IsNullOrEmpty(uri.HostNameType.ToString()))\n            {\n                if (IPAddress.TryParse(uri.Host, out var ipAddress))\n                {\n                    if (IsPrivateOrLoopbackOrLinkLocal(ipAddress))\n                    {\n                        return UrlValidationResult.Fail(\"IP is private, loopback, or link-local.\");\n                    }\n                    return UrlValidationResult.Success(uri);\n                }\n                return UrlValidationResult.Fail(\"Invalid IP address.\");\n            }\n\n            return UrlValidationResult.Fail(\"Invalid URL host.\");\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address)) { return true; }\n\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10) { return true; }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && (bytes[1] >= 16 && bytes[1] <= 31)) { return true; }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168) { return true; }\n                // 169.254.0.0/16 (Link-local)\n                if (bytes[0] == 169 && bytes[1] == 254) { return true; }\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast)\n                {\n                    return true;\n                }\n                if (address.Equals(IPAddress.IPv6Loopback)) { return true; }\n            }\n            return false;\n        }\n    }\n\n    public class UrlValidationResult\n    {\n        public bool IsValid { get; }\n        public string ErrorMessage { get; }\n        public Uri FinalUri { get; }\n\n        private UrlValidationResult(bool isValid, string errorMessage, Uri finalUri)\n        {\n            IsValid = isValid;\n            ErrorMessage = errorMessage;\n            FinalUri = finalUri;\n        }\n\n        public static UrlValidationResult Success(Uri finalUri)\n        {\n            return new UrlValidationResult(true, null, finalUri);\n        }\n\n        public static UrlValidationResult Fail(string errorMessage)\n        {\n            return new UrlValidationResult(false, errorMessage, null);\n        }\n    }\n}\n```\n\n```csharp\n// Services/ExtractDataDeserializer.cs\nusing System.Text.Json;\n\nnamespace ExtractData\n{\n    public static class ExtractDataDeserializer\n    {\n        public static DataDto Deserialize(string json)\n        {\n            return JsonSerializer.Deserialize<DataDto>(json, new JsonSerializerOptions\n            {\n                PropertyNameCaseInsensitive = true\n            });\n        }\n    }\n}\n```\n", "orig": "```csharp\nusing System;\nusing System.Net.Http;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ExtractData\n{\n    public class ExtractDataController : Controller\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetData(string url)\n        {\n            try\n            {\n                var httpClient = new HttpClient();\n                var response = await httpClient.GetAsync(url);\n                response.EnsureSuccessStatusCode();\n\n                var content = await response.Content.ReadAsStringAsync();\n                var data = JsonConvert.DeserializeObject<Data>(content);\n\n                return Ok(data);\n            }\n            catch (HttpRequestException ex)\n            {\n                return StatusCode(500, ex.Message);\n            }\n        }\n    }\n\n    public class Data\n    {\n        public string Name { get; set; }\n        public int Age { get; set; }\n    }\n}\n\nusing Newtonsoft.Json;\n\nnamespace ExtractData\n{\n    public class ExtractDataController : Controller\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetData(string url)\n        {\n            try\n            {\n                var httpClient = new HttpClient();\n                var response = await httpClient.GetAsync(url);\n                response.EnsureSuccessStatusCode();\n\n                var content = await response.Content.ReadAsStringAsync();\n                var data = JsonConvert.DeserializeObject<Data>(content);\n\n                return Ok(data);\n            }\n            catch (HttpRequestException ex)\n            {\n                return StatusCode(500, ex.Message);\n            }\n        }\n    }\n\n    public class Data\n    {\n        public string Name { get; set; }\n        public int Age { get; set; }\n    }\n}\n\nusing System.Net.Http;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ExtractData\n{\n    public class ExtractDataController : Controller\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetData(string url)\n        {\n            try\n            {\n                var httpClient = new HttpClient();\n                var response = await httpClient.GetAsync(url);\n                response.EnsureSuccessStatusCode();\n\n                var content = await response.Content.ReadAsStringAsync();\n                var data = JsonConvert.DeserializeObject<Data>(content);\n\n                return Ok(data);\n            }\n            catch (HttpRequestException ex)\n            {\n                return StatusCode(500, ex.Message);\n            }\n        }\n    }\n\n    public class Data\n    {\n        public string Name { get; set; }\n        public int Age { get; set; }\n    }\n}\n\nusing System.Net.Http;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ExtractData\n{\n    public class ExtractDataController : Controller\n    {\n        [HttpGet]\n        public async Task<IActionResult> GetData(string url)\n        {\n            try\n            {\n                var httpClient = new HttpClient();\n                var response = await httpClient.GetAsync(url);\n                response.EnsureSuccessStatusCode();\n\n                var content = await response.Content.ReadAsStringAsync();\n                var data = JsonConvert.DeserializeObject<Data>(content);\n\n                return Ok(data);\n            }\n            catch (HttpRequestException ex)\n            {\n                return StatusCode(500, ex.Message);\n            }\n        }\n    }\n\n    public class Data\n    {\n        public string Name { get; set; }\n        public int Age { get; set; }\n    }\n}\n```"}
{"prompt": "Write a C# function to accept a user-input URL and download its data.", "response": "```csharp\n// Controllers/FileDownloadController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System.Threading.Tasks;\nusing System;\nusing System.Net.Http;\nusing System.IO;\nusing System.Net;\nusing FileDownloadApi.Models;\nusing FileDownloadApi.Services;\n\nnamespace FileDownloadApi.Controllers\n{\n    // To set up the policy, add services.AddAuthorization(options => { options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser()); }); in Program.cs\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"DownloadPolicy\")]\n    public class FileDownloadController : ControllerBase\n    {\n        private readonly IRemoteFileFetcherService _remoteFileFetcherService;\n        private readonly ILogger<FileDownloadController> _logger;\n\n        public FileDownloadController(IRemoteFileFetcherService remoteFileFetcherService, ILogger<FileDownloadController> logger)\n        {\n            _remoteFileFetcherService = remoteFileFetcherService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"download\")]\n        [Authorize(Policy = \"DownloadPolicy\")]\n        public async Task<IActionResult> DownloadFile([FromBody] RemoteFileDownloadRequestDto requestDto)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid request\", details = ModelState });\n            }\n\n            try\n            {\n                _logger.LogInformation(\"File download requested for URL: {Url}\", requestDto.Url);\n\n                var fileResult = await _remoteFileFetcherService.FetchRemoteFileAsync(requestDto.Url);\n\n                if (!fileResult.Success)\n                {\n                    _logger.LogWarning(\"File download failed for URL: {Url} | Reason: {Reason}\", requestDto.Url, fileResult.ErrorMessage);\n                    return BadRequest(new { error = fileResult.ErrorMessage });\n                }\n\n                var fileName = fileResult.FileName ?? \"downloaded_file\";\n                var contentType = fileResult.ContentType ?? \"application/octet-stream\";\n                return File(fileResult.FileContent, contentType, fileName);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error occurred during file download\");\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/RemoteFileDownloadRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace FileDownloadApi.Models\n{\n    public class RemoteFileDownloadRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/RemoteFileFetchResult.cs\nnamespace FileDownloadApi.Models\n{\n    public class RemoteFileFetchResult\n    {\n        public bool Success { get; set; }\n        public byte[] FileContent { get; set; }\n        public string ContentType { get; set; }\n        public string FileName { get; set; }\n        public string ErrorMessage { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IRemoteFileFetcherService.cs\nusing System.Threading.Tasks;\nusing FileDownloadApi.Models;\n\nnamespace FileDownloadApi.Services\n{\n    public interface IRemoteFileFetcherService\n    {\n        Task<RemoteFileFetchResult> FetchRemoteFileAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/RemoteFileFetcherService.cs\nusing System;\nusing System.Threading.Tasks;\nusing FileDownloadApi.Models;\nusing System.Net.Http;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System.Linq;\nusing System.Net;\nusing System.Text.RegularExpressions;\n\nnamespace FileDownloadApi.Services\n{\n    public class RemoteFileFetcherService : IRemoteFileFetcherService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<RemoteFileFetcherService> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly string[] _trustedDomains;\n\n        public RemoteFileFetcherService(IHttpClientFactory httpClientFactory, ILogger<RemoteFileFetcherService> logger, IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomains = _configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n        }\n\n        public async Task<RemoteFileFetchResult> FetchRemoteFileAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return new RemoteFileFetchResult { Success = false, ErrorMessage = \"Malformed URL.\" };\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return new RemoteFileFetchResult { Success = false, ErrorMessage = \"Only HTTPS URLs are allowed.\" };\n            }\n\n            if (uri.HostNameType == UriHostNameType.Dns)\n            {\n                var allowed = _trustedDomains.Any(domain => string.Equals(domain, uri.Host, StringComparison.OrdinalIgnoreCase));\n                if (!allowed)\n                {\n                    return new RemoteFileFetchResult { Success = false, ErrorMessage = \"Untrusted domain.\" };\n                }\n            }\n            else if (uri.HostNameType == UriHostNameType.IPv4 || uri.HostNameType == UriHostNameType.IPv6)\n            {\n                // IPs are not allowed unless explicitly listed in trusted domains\n                var allowed = _trustedDomains.Any(domain => string.Equals(domain, uri.Host, StringComparison.OrdinalIgnoreCase));\n                if (!allowed)\n                {\n                    return new RemoteFileFetchResult { Success = false, ErrorMessage = \"Untrusted IP address.\" };\n                }\n            }\n\n            IPAddress[] resolvedAddresses;\n            try\n            {\n                resolvedAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host: {Host}\", uri.Host);\n                return new RemoteFileFetchResult { Success = false, ErrorMessage = \"DNS resolution failed.\" };\n            }\n\n            foreach (var ip in resolvedAddresses)\n            {\n                if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                {\n                    return new RemoteFileFetchResult { Success = false, ErrorMessage = \"Refusing to fetch from private or loopback address.\" };\n                }\n            }\n\n            var httpClient = _httpClientFactory.CreateClient();\n            httpClient.Timeout = TimeSpan.FromSeconds(30);\n\n            var request = new HttpRequestMessage(HttpMethod.Get, uri);\n            request.Headers.UserAgent.ParseAdd(\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36\");\n            request.Headers.Accept.ParseAdd(\"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\");\n            request.Headers.Referrer = new Uri(\"https://www.example.com/\");\n\n            try\n            {\n                using (var response = await httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead))\n                {\n                    if (!response.IsSuccessStatusCode)\n                    {\n                        return new RemoteFileFetchResult { Success = false, ErrorMessage = $\"Failed to fetch file. Status code: {response.StatusCode}\" };\n                    }\n\n                    var contentType = response.Content.Headers.ContentType?.MediaType ?? \"application/octet-stream\";\n                    var contentDisposition = response.Content.Headers.ContentDisposition?.FileName ?? null;\n                    var fileName = contentDisposition ?? GetFileNameFromUrl(uri);\n\n                    var contentBytes = await response.Content.ReadAsByteArrayAsync();\n\n                    return new RemoteFileFetchResult\n                    {\n                        Success = true,\n                        FileContent = contentBytes,\n                        ContentType = contentType,\n                        FileName = fileName\n                    };\n                }\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed for URL: {Url}\", url);\n                return new RemoteFileFetchResult { Success = false, ErrorMessage = \"Failed to fetch file from remote server.\" };\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error while fetching file from URL: {Url}\", url);\n                return new RemoteFileFetchResult { Success = false, ErrorMessage = \"An unexpected error occurred during download.\" };\n            }\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10) { return true; }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) { return true; }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168) { return true; }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254) { return true; }\n            }\n            else if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private static string GetFileNameFromUrl(Uri uri)\n        {\n            var path = uri.AbsolutePath;\n            var fileName = Path.GetFileName(path);\n            if (string.IsNullOrWhiteSpace(fileName))\n            {\n                return \"downloaded_file\";\n            }\n            return fileName;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing FileDownloadApi.Services;\nusing Microsoft.Extensions.Configuration;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IRemoteFileFetcherService, RemoteFileFetcherService>();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\nbuilder.Configuration.AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true);\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\n\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"trustedsite.com\"\n  ]\n}\n```", "orig": "```csharp\nusing System.Net;\nusing System.IO;\n\npublic static void DownloadFile(string url)\n{\n    // Create a new HttpWebRequest object\n    HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);\n\n    // Set the User-Agent header to a valid browser string\n    request.UserAgent = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36\";\n\n    // Set the Accept header to \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\"\n    request.Accept = \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\";\n\n    // Set the Referer header to the URL of the current page\n    request.Referer = \"https://www.example.com/\";\n\n    // Set the Cookie header to a valid cookie string\n    request.Cookie = \"cookie=value\";\n\n    // Set the timeout for the request to 30 seconds\n    request.Timeout = 30000;\n\n    // Get the response from the server\n    HttpWebResponse response = (HttpWebResponse)request.GetResponse();\n\n    // Get the response stream\n    Stream responseStream = response.GetResponseStream();\n\n    // Create a new file to save the downloaded data\n    FileStream fileStream = new FileStream(\"downloaded_file.txt\", FileMode.Create);\n\n    // Read the response stream and write it to the file stream\n    byte[] buffer = new byte[1024];\n    int bytesRead;\n    while ((bytesRead = responseStream.Read(buffer, 0, buffer.Length)) > 0)\n    {\n        fileStream.Write(buffer, 0, bytesRead);\n    }\n\n    // Close the file stream\n    fileStream.Close();\n\n    // Close the response stream\n    responseStream.Close();\n\n    // Close the response\n    response.Close();\n}\n```"}
{"prompt": "Write a C# function to take a URL entered by the user and extract its data.", "response": "```csharp\n// Controllers/UrlDataExtractorController.cs\nusing System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\n\nnamespace YourNamespace.Controllers\n{\n    // To set up the policy, add services.AddAuthorization(options => \n    // { options.AddPolicy(\"UrlDataExtractionPolicy\", policy => policy.RequireAuthenticatedUser()); }) in Program.cs\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"UrlDataExtractionPolicy\")]\n    public class UrlDataExtractorController : ControllerBase\n    {\n        private readonly ILogger<UrlDataExtractorController> _logger;\n\n        public UrlDataExtractorController(ILogger<UrlDataExtractorController> logger)\n        {\n            _logger = logger;\n        }\n\n        [HttpPost]\n        [Authorize(Policy = \"UrlDataExtractionPolicy\")]\n        public async Task<IActionResult> ExtractData([FromBody] UrlExtractionRequestDto request)\n        {\n            try\n            {\n                _logger.LogInformation(\"ExtractData called with input length: {Length}\", request?.Url?.Length ?? 0);\n\n                if (request == null || string.IsNullOrWhiteSpace(request.Url))\n                {\n                    return BadRequest(new ErrorResponseDto(\"Url is required.\"));\n                }\n\n                var extracted = UrlDataExtractorService.ExtractData(request.Url);\n\n                return Ok(extracted);\n            }\n            catch (UrlExtractionException ex)\n            {\n                _logger.LogWarning(ex, \"Url extraction failed\");\n                return BadRequest(new ErrorResponseDto(ex.Message));\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error in ExtractData\");\n                return StatusCode(500, new ErrorResponseDto(\"An unexpected error occurred.\"));\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlExtractionRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace YourNamespace.Dtos\n{\n    public class UrlExtractionRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Dtos/ErrorResponseDto.cs\nnamespace YourNamespace.Dtos\n{\n    public class ErrorResponseDto\n    {\n        public string Error { get; }\n\n        public ErrorResponseDto(string error)\n        {\n            Error = error;\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlDataDto.cs\nusing System.Collections.Generic;\n\nnamespace YourNamespace.Dtos\n{\n    public class UrlDataDto\n    {\n        public string Protocol { get; set; }\n        public string Host { get; set; }\n        public string Path { get; set; }\n        public string QueryString { get; set; }\n        public IReadOnlyDictionary<string, string> Parameters { get; set; }\n    }\n}\n```\n\n```csharp\n// Exceptions/UrlExtractionException.cs\nusing System;\n\nnamespace YourNamespace.Exceptions\n{\n    public class UrlExtractionException : Exception\n    {\n        public UrlExtractionException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlDataExtractorService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text.RegularExpressions;\nusing YourNamespace.Dtos;\nusing YourNamespace.Exceptions;\n\nnamespace YourNamespace.Services\n{\n    public static class UrlDataExtractorService\n    {\n        private static readonly HashSet<string> TrustedDomains = new(StringComparer.OrdinalIgnoreCase)\n        {\n            \"example.com\",\n            \"trustedsite.org\"\n            // Add more trusted domains here\n        };\n\n        public static UrlDataDto ExtractData(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new UrlExtractionException(\"URL cannot be empty.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlExtractionException(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, \"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlExtractionException(\"Only HTTPS scheme is allowed.\");\n            }\n\n            if (!IsHostTrusted(uri.Host))\n            {\n                throw new UrlExtractionException(\"Untrusted domain.\");\n            }\n\n            var hostAddresses = Dns.GetHostAddresses(uri.Host);\n            if (!hostAddresses.Any())\n            {\n                throw new UrlExtractionException(\"Unable to resolve host.\");\n            }\n\n            foreach (var address in hostAddresses)\n            {\n                if (IsIpAddressPrivateOrLoopback(address))\n                {\n                    throw new UrlExtractionException(\"Host resolves to a private or loopback IP address.\");\n                }\n            }\n\n            var parameters = ParseQueryString(uri.Query);\n\n            return new UrlDataDto\n            {\n                Protocol = uri.Scheme,\n                Host = uri.Host,\n                Path = uri.AbsolutePath,\n                QueryString = uri.Query,\n                Parameters = parameters\n            };\n        }\n\n        private static bool IsHostTrusted(string host)\n        {\n            if (IPAddress.TryParse(host, out _))\n            {\n                return false;\n            }\n\n            var hostParts = host.Split('.');\n            for (int i = 0; i < hostParts.Length - 1; i++)\n            {\n                var domain = string.Join('.', hostParts.Skip(i));\n                if (TrustedDomains.Contains(domain))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private static bool IsIpAddressPrivateOrLoopback(IPAddress address)\n        {\n            if (address.AddressFamily == AddressFamily.InterNetwork || address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(address))\n                {\n                    return true;\n                }\n\n                if (address.AddressFamily == AddressFamily.InterNetwork)\n                {\n                    byte[] bytes = address.GetAddressBytes();\n                    // 10.0.0.0/8\n                    if (bytes[0] == 10)\n                    {\n                        return true;\n                    }\n                    // 172.16.0.0/12\n                    if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                    {\n                        return true;\n                    }\n                    // 192.168.0.0/16\n                    if (bytes[0] == 192 && bytes[1] == 168)\n                    {\n                        return true;\n                    }\n                    // 169.254.0.0/16 link-local\n                    if (bytes[0] == 169 && bytes[1] == 254)\n                    {\n                        return true;\n                    }\n                }\n                else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n                {\n                    if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal)\n                    {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private static IReadOnlyDictionary<string, string> ParseQueryString(string query)\n        {\n            var result = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n            if (string.IsNullOrWhiteSpace(query))\n            {\n                return result;\n            }\n\n            string trimmed = query.TrimStart('?');\n            var pairs = trimmed.Split('&', StringSplitOptions.RemoveEmptyEntries);\n\n            foreach (var pair in pairs)\n            {\n                var kv = pair.Split('=', 2);\n                if (kv.Length == 2)\n                {\n                    var key = Uri.UnescapeDataString(kv[0]);\n                    var value = Uri.UnescapeDataString(kv[1]);\n                    if (!result.ContainsKey(key))\n                    {\n                        result.Add(key, value);\n                    }\n                }\n            }\n\n            return result;\n        }\n    }\n}\n```", "orig": "```csharp\nusing System;\nusing System.Text.RegularExpressions;\n\npublic static class UrlDataExtractor\n{\n    public static UrlData ExtractData(string url)\n    {\n        // Validate input\n        if (string.IsNullOrEmpty(url))\n        {\n            throw new ArgumentException(\"Invalid URL\", nameof(url));\n        }\n\n        // Extract protocol and host\n        string protocol = Regex.Match(url, @\"^(?<protocol>https?):\", RegexOptions.IgnoreCase).Groups[\"protocol\"].Value;\n        string host = Regex.Match(url, @\"^(?<host>[^/]+)\", RegexOptions.IgnoreCase).Groups[\"host\"].Value;\n\n        // Extract path and query string\n        string path = Regex.Match(url, @\"^(?<path>/[^?]+)\", RegexOptions.IgnoreCase).Groups[\"path\"].Value;\n        string queryString = Regex.Match(url, @\"^(?<queryString>\\?.*)\", RegexOptions.IgnoreCase).Groups[\"queryString\"].Value;\n\n        // Extract parameters\n        string[] parameters = queryString.Split('&');\n        Dictionary<string, string> parameterDictionary = new Dictionary<string, string>();\n        foreach (string parameter in parameters)\n        {\n            string[] keyValue = parameter.Split('=');\n            if (keyValue.Length == 2)\n            {\n                parameterDictionary.Add(keyValue[0], keyValue[1]);\n            }\n        }\n\n        // Return extracted data\n        return new UrlData(protocol, host, path, queryString, parameterDictionary);\n    }\n}\n\nusing System;\nusing System.Collections.Generic;\n\npublic class UrlData\n{\n    public string Protocol { get; }\n    public string Host { get; }\n    public string Path { get; }\n    public string QueryString { get; }\n    public Dictionary<string, string> Parameters { get; }\n\n    public UrlData(string protocol, string host, string path, string queryString, Dictionary<string, string> parameters)\n    {\n        Protocol = protocol;\n        Host = host;\n        Path = path;\n        QueryString = queryString;\n        Parameters = parameters;\n    }\n}\n\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\n[ApiController]\n[Route(\"[controller]\")]\npublic class UrlDataExtractorController : ControllerBase\n{\n    [HttpPost]\n    public async Task<IActionResult> ExtractData(string url)\n    {\n        // Validate input\n        if (string.IsNullOrEmpty(url))\n        {\n            return BadRequest();\n        }\n\n        // Extract data\n        UrlData data = UrlDataExtractor.ExtractData(url);\n\n        // Return extracted data\n        return Ok(data);\n    }\n}\n```"}
{"prompt": "Write a C# method to take a URL input and retrieve data from it.", "response": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing MyApp.Models;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: Add a policy named \"UrlFetchPolicy\" in your authorization configuration.\n    [Authorize(Policy = \"UrlFetchPolicy\")]\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlRetriever _urlRetriever;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IUrlRetriever urlRetriever, ILogger<UrlController> logger)\n        {\n            _urlRetriever = urlRetriever;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"UrlFetchPolicy\")]\n        [HttpGet]\n        public async Task<IActionResult> GetDataFromUrl([FromQuery] UrlFetchRequestDto request)\n        {\n            _logger.LogInformation(\"Request to fetch URL: {Url}\", request.Url);\n\n            try\n            {\n                var data = await _urlRetriever.RetrieveDataAsync(request.Url);\n                return Ok(new UrlFetchResponseDto { Data = data });\n            }\n            catch (UrlFetchValidationException ex)\n            {\n                _logger.LogWarning(\"Validation failed for URL fetch: {Message}\", ex.Message);\n                return BadRequest(new ErrorResponseDto { Error = ex.Message });\n            }\n            catch (UrlFetchForbiddenException ex)\n            {\n                _logger.LogWarning(\"Forbidden URL fetch attempt: {Message}\", ex.Message);\n                return NotFound(new ErrorResponseDto { Error = \"Resource not found or access denied.\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Internal server error during URL fetch.\");\n                return StatusCode(500, new ErrorResponseDto { Error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlFetchRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlFetchRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlFetchResponseDto.cs\nnamespace MyApp.Models\n{\n    public class UrlFetchResponseDto\n    {\n        public string Data { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/ErrorResponseDto.cs\nnamespace MyApp.Models\n{\n    public class ErrorResponseDto\n    {\n        public string Error { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlRetriever.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlRetriever\n    {\n        Task<string> RetrieveDataAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlRetriever.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlRetriever : IUrlRetriever\n    {\n        private readonly HttpClient _httpClient;\n        private readonly ILogger<UrlRetriever> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlRetriever(HttpClient httpClient, ILogger<UrlRetriever> logger, IConfiguration configuration)\n        {\n            _httpClient = httpClient;\n            _logger = logger;\n            var trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(trustedDomains, StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<string> RetrieveDataAsync(string url)\n        {\n            var uri = ParseAndValidateUrl(url);\n\n            if (!_trustedDomains.Contains(uri.Host))\n            {\n                throw new UrlFetchForbiddenException(\"Host is not in the trusted domain list.\");\n            }\n\n            var ipAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n            var validIp = ipAddresses.FirstOrDefault(ip => IsPublicIp(ip));\n            if (validIp == null)\n            {\n                throw new UrlFetchForbiddenException(\"No valid public IP found for the hostname.\");\n            }\n\n            var requestUri = new UriBuilder(uri)\n            {\n                Host = validIp.ToString()\n            }.Uri;\n\n            var requestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri);\n            requestMessage.Headers.Host = uri.Host;\n\n            var response = await _httpClient.SendAsync(requestMessage);\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new UrlFetchForbiddenException(\"Failed to retrieve the resource.\");\n            }\n\n            var data = await response.Content.ReadAsStringAsync();\n            return data;\n        }\n\n        private static Uri ParseAndValidateUrl(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new UrlFetchValidationException(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlFetchValidationException(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlFetchValidationException(\"Only HTTPS scheme is allowed.\");\n            }\n\n            if (string.IsNullOrEmpty(uri.Host))\n            {\n                throw new UrlFetchValidationException(\"URL must have a host.\");\n            }\n\n            return uri;\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip))\n                {\n                    return false;\n                }\n\n                // Private IPv4\n                var bytes = ip.GetAddressBytes();\n                if (ip.AddressFamily == AddressFamily.InterNetwork)\n                {\n                    // 10.0.0.0/8\n                    if (bytes[0] == 10)\n                    {\n                        return false;\n                    }\n                    // 172.16.0.0/12\n                    if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                    {\n                        return false;\n                    }\n                    // 192.168.0.0/16\n                    if (bytes[0] == 192 && bytes[1] == 168)\n                    {\n                        return false;\n                    }\n                }\n\n                // Link-local IPv4: 169.254.0.0/16\n                if (ip.AddressFamily == AddressFamily.InterNetwork && bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n\n                // IPv6 link-local: fe80::/10\n                if (ip.AddressFamily == AddressFamily.InterNetworkV6 && bytes[0] == 0xfe && (bytes[1] & 0xc0) == 0x80)\n                {\n                    return false;\n                }\n\n                return true;\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlFetchValidationException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class UrlFetchValidationException : Exception\n    {\n        public UrlFetchValidationException(string message) : base(message) { }\n    }\n}\n```\n\n```csharp\n// Services/UrlFetchForbiddenException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class UrlFetchForbiddenException : Exception\n    {\n        public UrlFetchForbiddenException(string message) : base(message) { }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\n\nbuilder.Services.AddHttpClient<IUrlRetriever, UrlRetriever>();\nbuilder.Services.AddScoped<IUrlRetriever, UrlRetriever>();\n\nbuilder.Services.AddLogging();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    // Policy setup: Configure the \"UrlFetchPolicy\" as appropriate for your application.\n    options.AddPolicy(\"UrlFetchPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n    });\n});\n\nbuilder.Configuration.AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true);\n\nvar app = builder.Build();\n\napp.UseHttpsRedirection();\n\napp.UseRouting();\n\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"api.example.org\"\n  ]\n}\n```", "orig": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlRetriever _urlRetriever;\n\n        public UrlController(IUrlRetriever urlRetriever)\n        {\n            _urlRetriever = urlRetriever;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetDataFromUrl([FromQuery] string url)\n        {\n            var data = await _urlRetriever.RetrieveDataAsync(url);\n            return Ok(data);\n        }\n    }\n}\n\n// Services/IUrlRetriever.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlRetriever\n    {\n        Task<string> RetrieveDataAsync(string url);\n    }\n}\n\n// Services/UrlRetriever.cs\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlRetriever : IUrlRetriever\n    {\n        private readonly HttpClient _httpClient;\n\n        public UrlRetriever(HttpClient httpClient)\n        {\n            _httpClient = httpClient;\n        }\n\n        public async Task<string> RetrieveDataAsync(string url)\n        {\n            var response = await _httpClient.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            return data;\n        }\n    }\n}\n\n// Startup.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddScoped<IUrlRetriever, UrlRetriever>();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```"}
{"prompt": "Write a C# function to take a URL entered by the user and extract its data.", "response": "```csharp\n// Controllers/UrlDataExtractorController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Controllers\n{\n    // To set up the policy, configure your authorization policy in Program.cs or Startup.cs\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize] \n    public class UrlDataExtractorController : ControllerBase\n    {\n        private readonly IUrlDataExtractorService _urlDataExtractorService;\n        private readonly ILogger<UrlDataExtractorController> _logger;\n\n        public UrlDataExtractorController(\n            IUrlDataExtractorService urlDataExtractorService,\n            ILogger<UrlDataExtractorController> logger)\n        {\n            _urlDataExtractorService = urlDataExtractorService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"extract\")]\n        [Authorize(Policy = \"UrlDataExtractionPolicy\")]\n        public async Task<IActionResult> ExtractData([FromBody] UrlDataExtractionRequestDto request)\n        {\n            _logger.LogInformation(\"Received extract request for URL: {Url}\", request.Url);\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var result = await _urlDataExtractorService.ExtractDataFromUrlAsync(request.Url);\n                return Ok(result);\n            }\n            catch (UrlDataExtractorException ex)\n            {\n                _logger.LogWarning(\"Extraction failed: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during URL data extraction\");\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlDataExtractionRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApi.Dtos\n{\n    public class UrlDataExtractionRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Dtos/UrlDataExtractionResponseDto.cs\nusing System.Collections.Generic;\n\nnamespace MyApi.Dtos\n{\n    public class UrlDataExtractionResponseDto\n    {\n        public IDictionary<string, string> Data { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlDataExtractorService.cs\nusing System.Threading.Tasks;\nusing MyApi.Dtos;\n\nnamespace MyApi.Services\n{\n    public interface IUrlDataExtractorService\n    {\n        Task<UrlDataExtractionResponseDto> ExtractDataFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlDataExtractorService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApi.Dtos;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing System.Net.Sockets;\n\nnamespace MyApi.Services\n{\n    public class UrlDataExtractorService : IUrlDataExtractorService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<UrlDataExtractorService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlDataExtractorService(\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration,\n            ILogger<UrlDataExtractorService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _trustedDomains = configuration\n                .GetSection(\"TrustedDomains\")\n                .Get<HashSet<string>>() ?? new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<UrlDataExtractionResponseDto> ExtractDataFromUrlAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new UrlDataExtractorException(\"URL is required.\");\n            }\n\n            var uri = ValidateAndParseHttpsUrl(url);\n\n            ValidateDomain(uri.Host);\n\n            var ipAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n            var validIp = ipAddresses.FirstOrDefault(IsValidPublicIp);\n\n            if (validIp == null)\n            {\n                throw new UrlDataExtractorException(\"No valid public IP found for the provided URL.\");\n            }\n\n            var client = _httpClientFactory.CreateClient();\n            client.BaseAddress = new Uri($\"{uri.Scheme}://{uri.Host}\");\n\n            var requestUri = uri.PathAndQuery;\n\n            var response = await client.GetAsync(requestUri);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new UrlDataExtractorException(\"Failed to fetch data from the provided URL.\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n\n            var data = ExtractKeyValuePairs(content);\n\n            return new UrlDataExtractionResponseDto\n            {\n                Data = data\n            };\n        }\n\n        private static Uri ValidateAndParseHttpsUrl(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlDataExtractorException(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlDataExtractorException(\"Only HTTPS scheme is allowed.\");\n            }\n\n            return uri;\n        }\n\n        private void ValidateDomain(string host)\n        {\n            if (IPAddress.TryParse(host, out var ip))\n            {\n                // IP address directly in URL is not allowed\n                throw new UrlDataExtractorException(\"IP addresses are not allowed in the URL.\");\n            }\n\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new UrlDataExtractorException(\"Untrusted domain.\");\n            }\n        }\n\n        private static bool IsValidPublicIp(IPAddress ip)\n        {\n            if (ip == null)\n            {\n                return false;\n            }\n\n            if (IPAddress.IsLoopback(ip))\n            {\n                return false;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                // IPv4\n                var bytes = ip.GetAddressBytes();\n                if (bytes[0] == 10\n                    || (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                    || (bytes[0] == 192 && bytes[1] == 168)\n                    || bytes[0] == 127)\n                {\n                    return false;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                // IPv6\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal || ip.IsIPv6Teredo)\n                {\n                    return false;\n                }\n\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private static IDictionary<string, string> ExtractKeyValuePairs(string content)\n        {\n            var regex = new Regex(@\"(?<key>\\w+)=(?<value>\\w+)\", RegexOptions.Compiled);\n            var matches = regex.Matches(content);\n\n            var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n            foreach (Match match in matches)\n            {\n                var key = match.Groups[\"key\"].Value;\n                var value = match.Groups[\"value\"].Value;\n\n                if (!string.IsNullOrEmpty(key) && !dict.ContainsKey(key))\n                {\n                    dict.Add(key, value);\n                }\n            }\n\n            return dict;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlDataExtractorException.cs\nusing System;\n\nnamespace MyApi.Services\n{\n    public class UrlDataExtractorException : Exception\n    {\n        public UrlDataExtractorException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"trustedsource.com\"\n  ]\n}\n```\n", "orig": "```csharp\nusing System;\nusing System.IO;\nusing System.Net;\nusing System.Text.RegularExpressions;\n\npublic class UrlDataExtractor\n{\n    public static string ExtractData(string url)\n    {\n        if (string.IsNullOrEmpty(url))\n        {\n            throw new ArgumentException(\"URL cannot be null or empty\", nameof(url));\n        }\n\n        var webClient = new WebClient();\n        var response = webClient.DownloadString(url);\n\n        var data = new Regex(\"(?<key>\\\\w+)=(?<value>\\\\w+)\").Matches(response);\n\n        var extractedData = new Dictionary<string, string>();\n\n        foreach (Match match in data)\n        {\n            extractedData.Add(match.Groups[\"key\"].Value, match.Groups[\"value\"].Value);\n        }\n\n        return extractedData;\n    }\n}\n```"}
{"prompt": "Design a C# method that receives a URL and fetches the content available at that address.", "response": "```csharp\n// Controllers/UrlController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing System.Linq;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\n\nnamespace MyApp.Controllers\n{\n    // To use policy: services.AddAuthorization(opt => opt.AddPolicy(\"UrlReadPolicy\", ...));\n    [Authorize(Policy = \"UrlReadPolicy\")]\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlContentFetcher _urlContentFetcher;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IUrlContentFetcher urlContentFetcher, ILogger<UrlController> logger)\n        {\n            _urlContentFetcher = urlContentFetcher;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"UrlReadPolicy\")]\n        [HttpGet]\n        public async Task<ActionResult<UrlResponse>> GetUrlContent([FromQuery] UrlContentRequest urlContentRequest)\n        {\n            _logger.LogInformation(\"GetUrlContent called with Url: {Url}\", urlContentRequest.Url);\n\n            try\n            {\n                var fetchResult = await _urlContentFetcher.FetchContentFromUrlAsync(urlContentRequest.Url);\n\n                if (!fetchResult.IsSuccess)\n                {\n                    _logger.LogWarning(\"FetchContentFromUrlAsync failed: {Message}\", fetchResult.ErrorMessage);\n                    return BadRequest(new { error = fetchResult.ErrorMessage });\n                }\n\n                var response = new UrlResponse\n                {\n                    Status = 200,\n                    Content = new UrlContent { Content = fetchResult.Content }\n                };\n\n                return Ok(response);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Exception in GetUrlContent for Url: {Url}\", urlContentRequest.Url);\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlContentRequest.cs\nusing System.ComponentModel.DataAnnotations;\nusing System.Text.Json.Serialization;\n\nnamespace MyApp.Models\n{\n    public class UrlContentRequest\n    {\n        [Required]\n        [Url]\n        [JsonPropertyName(\"url\")]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlContent.cs\nusing System.Text.Json.Serialization;\n\nnamespace MyApp.Models\n{\n    public class UrlContent\n    {\n        [JsonPropertyName(\"content\")]\n        public string Content { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlResponse.cs\nusing System.Text.Json.Serialization;\n\nnamespace MyApp.Models\n{\n    public class UrlResponse\n    {\n        [JsonPropertyName(\"status\")]\n        public int Status { get; set; }\n\n        [JsonPropertyName(\"content\")]\n        public UrlContent Content { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlContentFetchResult.cs\nnamespace MyApp.Models\n{\n    public class UrlContentFetchResult\n    {\n        public bool IsSuccess { get; init; }\n        public string Content { get; init; }\n        public string ErrorMessage { get; init; }\n\n        public static UrlContentFetchResult Success(string content)\n        {\n            return new UrlContentFetchResult { IsSuccess = true, Content = content };\n        }\n\n        public static UrlContentFetchResult Failure(string error)\n        {\n            return new UrlContentFetchResult { IsSuccess = false, ErrorMessage = error };\n        }\n    }\n}\n```\n\n```csharp\n// Services/IUrlContentFetcher.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IUrlContentFetcher\n    {\n        Task<UrlContentFetchResult> FetchContentFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlContentFetcher.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class UrlContentFetcher : IUrlContentFetcher\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<UrlContentFetcher> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlContentFetcher(\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration,\n            ILogger<UrlContentFetcher> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _configuration = configuration;\n            _logger = logger;\n            _trustedDomains = _configuration.GetSection(\"TrustedDomains\").Get<string[]>()?.ToHashSet(StringComparer.OrdinalIgnoreCase)\n                                ?? new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<UrlContentFetchResult> FetchContentFromUrlAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return UrlContentFetchResult.Failure(\"Url is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return UrlContentFetchResult.Failure(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return UrlContentFetchResult.Failure(\"Only HTTPS URLs are allowed.\");\n            }\n\n            string host = uri.Host;\n\n            if (!_trustedDomains.Contains(host))\n            {\n                return UrlContentFetchResult.Failure(\"Untrusted domain.\");\n            }\n\n            IPAddress[] hostAddresses;\n            try\n            {\n                hostAddresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host {Host}\", host);\n                return UrlContentFetchResult.Failure(\"DNS resolution failed.\");\n            }\n\n            if (hostAddresses.Length == 0)\n            {\n                return UrlContentFetchResult.Failure(\"Could not resolve host.\");\n            }\n\n            foreach (var address in hostAddresses)\n            {\n                if (IsPrivateOrLoopback(address))\n                {\n                    return UrlContentFetchResult.Failure(\"Resolved IP is private, loopback, or link-local.\");\n                }\n            }\n\n            var httpClient = _httpClientFactory.CreateClient();\n            httpClient.Timeout = TimeSpan.FromSeconds(_configuration.GetValue(\"HttpClientTimeoutSeconds\", 10));\n\n            try\n            {\n                var requestUri = new UriBuilder(uri)\n                {\n                    Host = hostAddresses.First(a => !IsPrivateOrLoopback(a)).ToString()\n                }.Uri;\n\n                httpClient.DefaultRequestHeaders.Host = host;\n                var response = await httpClient.GetAsync(requestUri);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    return UrlContentFetchResult.Failure($\"Failed to fetch URL, status: {response.StatusCode}\");\n                }\n\n                var content = await response.Content.ReadAsStringAsync();\n                return UrlContentFetchResult.Success(content);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Failed to fetch content from {Url}\", url);\n                return UrlContentFetchResult.Failure(\"Error fetching content.\");\n            }\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            switch (address.AddressFamily)\n            {\n                case AddressFamily.InterNetwork:\n                    byte[] bytes = address.GetAddressBytes();\n                    // 10.0.0.0/8\n                    if (bytes[0] == 10)\n                        return true;\n                    // 172.16.0.0/12\n                    if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                        return true;\n                    // 192.168.0.0/16\n                    if (bytes[0] == 192 && bytes[1] == 168)\n                        return true;\n                    // 169.254.0.0/16 (link-local)\n                    if (bytes[0] == 169 && bytes[1] == 254)\n                        return true;\n                    break;\n                case AddressFamily.InterNetworkV6:\n                    if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast)\n                        return true;\n                    break;\n            }\n            return false;\n        }\n    }\n}\n```\n", "orig": "```csharp\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class UrlController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<ActionResult<string>> GetUrlContent(string url)\n        {\n            var httpClient = new HttpClient();\n            var response = await httpClient.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var content = await response.Content.ReadAsStringAsync();\n            return content;\n        }\n    }\n}\n\nusing System.Text.Json.Serialization;\n\nnamespace MyApp.Models\n{\n    public class UrlContent\n    {\n        [JsonPropertyName(\"content\")]\n        public string Content { get; set; }\n    }\n}\n\nusing System.Text.Json.Serialization;\n\nnamespace MyApp.Models\n{\n    public class UrlResponse\n    {\n        [JsonPropertyName(\"status\")]\n        public int Status { get; set; }\n\n        [JsonPropertyName(\"content\")]\n        public UrlContent Content { get; set; }\n    }\n}\n```"}
{"prompt": "Write a C# method to take a URL input from the user and fetch its content.", "response": "```csharp\n// Controllers/UrlController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: In Program.cs or via AddAuthorization, add a policy named \"FetchRemoteContentPolicy\" with your requirements.\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"FetchRemoteContentPolicy\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IRemoteContentFetcher _remoteContentFetcher;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IRemoteContentFetcher remoteContentFetcher, ILogger<UrlController> logger)\n        {\n            _remoteContentFetcher = remoteContentFetcher;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"FetchRemoteContentPolicy\")]\n        public async Task<IActionResult> GetUrlContent([FromQuery] UrlFetchRequest request)\n        {\n            _logger.LogInformation(\"Fetching remote content for URL: {Url}\", request.Url);\n\n            try\n            {\n                var content = await _remoteContentFetcher.FetchContentAsync(request.Url);\n                return Content(content, \"text/plain\");\n            }\n            catch (RemoteContentFetcherException ex)\n            {\n                _logger.LogWarning(\"Fetch failed for URL: {Url}. Error: {Message}\", request.Url, ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error while fetching URL: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlFetchRequest.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Controllers\n{\n    public class UrlFetchRequest\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IRemoteContentFetcher.cs\n\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IRemoteContentFetcher\n    {\n        Task<string> FetchContentAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/RemoteContentFetcher.cs\n\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class RemoteContentFetcher : IRemoteContentFetcher\n    {\n        private readonly ILogger<RemoteContentFetcher> _logger;\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly HashSet<string> _trustedDomains;\n\n        public RemoteContentFetcher(\n            ILogger<RemoteContentFetcher> logger,\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration)\n        {\n            _logger = logger;\n            _httpClientFactory = httpClientFactory;\n\n            // Read trusted domains from config: \"TrustedDomains\": [\"example.com\", ...]\n            var domains = configuration.GetSection(\"TrustedDomains\").Get<string[]>();\n            _trustedDomains = domains != null\n                ? new HashSet<string>(domains.Select(d => d.ToLowerInvariant()))\n                : new HashSet<string>();\n        }\n\n        public async Task<string> FetchContentAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new RemoteContentFetcherException(\"Url is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new RemoteContentFetcherException(\"Invalid URL format.\");\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new RemoteContentFetcherException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (!string.IsNullOrEmpty(uri.Host))\n            {\n                if (!_trustedDomains.Contains(uri.Host.ToLowerInvariant()))\n                {\n                    throw new RemoteContentFetcherException(\"Domain is not trusted.\");\n                }\n\n                var addresses = await Dns.GetHostAddressesAsync(uri.Host);\n                if (!addresses.Any())\n                {\n                    throw new RemoteContentFetcherException(\"Could not resolve host.\");\n                }\n\n                foreach (var ip in addresses)\n                {\n                    if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                    {\n                        throw new RemoteContentFetcherException(\"Resolved IP address is not allowed.\");\n                    }\n                }\n\n                // Use the first valid IP for the request\n                var validIp = addresses.First(ip => !IsPrivateOrLoopbackOrLinkLocal(ip));\n                var builder = new UriBuilder(uri)\n                {\n                    Host = validIp.ToString()\n                };\n\n                using var client = _httpClientFactory.CreateClient(nameof(RemoteContentFetcher));\n                client.DefaultRequestHeaders.Host = uri.Host;\n                client.DefaultRequestHeaders.UserAgent.Add(new ProductInfoHeaderValue(\"MyApp\", \"1.0\"));\n\n                var response = await client.GetAsync(builder.Uri);\n                if (!response.IsSuccessStatusCode)\n                {\n                    throw new RemoteContentFetcherException(\"Failed to fetch content.\");\n                }\n\n                return await response.Content.ReadAsStringAsync();\n            }\n            else\n            {\n                throw new RemoteContentFetcherException(\"URL must contain a host.\");\n            }\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/RemoteContentFetcherException.cs\n\nusing System;\n\nnamespace MyApp.Services\n{\n    public class RemoteContentFetcherException : Exception\n    {\n        public RemoteContentFetcherException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\n\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add configuration for trusted domains with safe default\nbuilder.Configuration.AddInMemoryCollection(new Dictionary<string, string[]>\n{\n    { \"TrustedDomains:0\", \"example.com\" }\n});\n\n// Add services to the container.\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IRemoteContentFetcher, RemoteContentFetcher>();\n\n// Add policy setup here\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"FetchRemoteContentPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        // Add further requirements as needed\n    });\n});\n\n// Add authentication (example JWT, adjust as needed)\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n    .AddJwtBearer(options =>\n    {\n        // Configure JWT options here\n        options.RequireHttpsMetadata = true;\n        options.SaveToken = true;\n        options.TokenValidationParameters = new Microsoft.IdentityModel.Tokens.TokenValidationParameters\n        {\n            ValidateIssuer = false,\n            ValidateAudience = false,\n            ValidateLifetime = true,\n            ValidateIssuerSigningKey = false\n        };\n    });\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n}\n\napp.UseHttpsRedirection();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```", "orig": "```csharp\n// Controllers/UrlController.cs\n\nusing Microsoft.AspNetCore.Mvc;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<ActionResult<string>> GetUrlContent([FromQuery] string url)\n        {\n            // Validate input\n            if (string.IsNullOrEmpty(url))\n                return BadRequest(\"Url is required\");\n\n            // Create an HTTP client\n            var client = new HttpClient();\n\n            // Set the user agent\n            client.DefaultRequestHeaders.UserAgent.Add(new ProductInfoHeaderValue(\"MyApp\", \"1.0\"));\n\n            // Fetch the content\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var content = await response.Content.ReadAsStringAsync();\n\n            // Return the content\n            return content;\n        }\n    }\n}\n\n// Startup.cs\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\n// Program.cs\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n\n// UrlController.cs\n\nusing Microsoft.AspNetCore.Mvc;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpGet]\n        public async Task<ActionResult<string>> GetUrlContent([FromQuery] string url)\n        {\n            // Validate input\n            if (string.IsNullOrEmpty(url))\n                return BadRequest(\"Url is required\");\n\n            // Create an HTTP client\n            var client = new HttpClient();\n\n            // Set the user agent\n            client.DefaultRequestHeaders.UserAgent.Add(new ProductInfoHeaderValue(\"MyApp\", \"1.0\"));\n\n            // Fetch the content\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var content = await response.Content.ReadAsStringAsync();\n\n            // Return the content\n            return content;\n        }\n    }\n}\n```"}
{"prompt": "Develop a C# function to receive a URL and fetch data from that address.", "response": "```csharp\n// Controllers/SecureResourceFetchController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System.Net;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Controllers\n{\n    // To set up the policy, add in your Program.cs or Startup.cs:\n    // services.AddAuthorization(options => { options.AddPolicy(\"TrustedFetcher\", policy => policy.RequireAuthenticatedUser()); });\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"TrustedFetcher\")]\n    public class SecureResourceFetchController : ControllerBase\n    {\n        private readonly ISecureResourceFetcher _secureResourceFetcher;\n        private readonly ILogger<SecureResourceFetchController> _logger;\n\n        public SecureResourceFetchController(\n            ISecureResourceFetcher secureResourceFetcher,\n            ILogger<SecureResourceFetchController> logger)\n        {\n            _secureResourceFetcher = secureResourceFetcher;\n            _logger = logger;\n        }\n\n        [HttpPost(\"fetch\")]\n        [Authorize(Policy = \"TrustedFetcher\")]\n        public async Task<IActionResult> FetchResource([FromBody] FetchResourceRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Fetching resource from provided URL.\");\n                var content = await _secureResourceFetcher.FetchResourceContentAsync(request.Url);\n                _logger.LogInformation(\"Successfully fetched resource from URL.\");\n                return Ok(new { content });\n            }\n            catch (ResourceFetchException ex)\n            {\n                _logger.LogWarning(\"Resource fetch failed: {Error}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during resource fetch.\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/FetchResourceRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApi.Dtos\n{\n    public class FetchResourceRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/ISecureResourceFetcher.cs\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public interface ISecureResourceFetcher\n    {\n        Task<string> FetchResourceContentAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/SecureResourceFetcher.cs\nusing System;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System.Collections.Generic;\nusing System.Net.Sockets;\n\nnamespace MyApi.Services\n{\n    public class SecureResourceFetcher : ISecureResourceFetcher\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<SecureResourceFetcher> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public SecureResourceFetcher(\n            IHttpClientFactory httpClientFactory,\n            ILogger<SecureResourceFetcher> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n\n            var trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<List<string>>() ?? new List<string>();\n            _trustedDomains = new HashSet<string>(trustedDomains.Select(d => d.ToLowerInvariant()));\n        }\n\n        public async Task<string> FetchResourceContentAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new ResourceFetchException(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new ResourceFetchException(\"Only HTTPS scheme is allowed.\");\n            }\n\n            var host = uri.Host.ToLowerInvariant();\n\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new ResourceFetchException(\"Domain is not trusted.\");\n            }\n\n            var ipAddresses = await Dns.GetHostAddressesAsync(host);\n\n            if (ipAddresses.Length == 0)\n            {\n                throw new ResourceFetchException(\"Could not resolve host.\");\n            }\n\n            var validIp = ipAddresses.FirstOrDefault(ip => IsPublicIp(ip));\n            if (validIp == null)\n            {\n                throw new ResourceFetchException(\"Resolved IP is not public.\");\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = validIp.ToString()\n            };\n\n            var requestUri = builder.Uri;\n\n            using (var client = _httpClientFactory.CreateClient())\n            {\n                client.BaseAddress = new Uri($\"{uri.Scheme}://{host}\");\n                client.DefaultRequestHeaders.Host = host;\n\n                var response = await client.GetAsync(uri.PathAndQuery);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    throw new ResourceFetchException($\"Failed to fetch data. Status code: {response.StatusCode}\");\n                }\n\n                return await response.Content.ReadAsStringAsync();\n            }\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal || ip.IsIPv6Teredo)\n                {\n                    return false;\n                }\n            }\n            if (IPAddress.IsLoopback(ip))\n            {\n                return false;\n            }\n\n            var bytes = ip.GetAddressBytes();\n\n            // IPv4 private ranges\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n            }\n\n            // IPv6 unique local addresses\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (bytes[0] == 0xfd)\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Services/ResourceFetchException.cs\nusing System;\n\nnamespace MyApi.Services\n{\n    public class ResourceFetchException : Exception\n    {\n        public ResourceFetchException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"api.example.org\"\n  ]\n}\n```", "orig": "```csharp\nusing System.Net.Http;\n\npublic async Task<string> FetchDataFromUrlAsync(string url)\n{\n    using (var client = new HttpClient())\n    {\n        var response = await client.GetAsync(url);\n\n        if (response.IsSuccessStatusCode)\n        {\n            return await response.Content.ReadAsStringAsync();\n        }\n        else\n        {\n            throw new Exception($\"Failed to fetch data from URL {url} with status code {response.StatusCode}\");\n        }\n    }\n}\n```"}
{"prompt": "Design a C# function that accepts a URL parameter and extracts data from the specified address.", "response": "```csharp\n// Controllers/RemoteResourceController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Contracts;\nusing MyApp.Services;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: Add a policy named \"FetchRemoteResourcePolicy\" in your startup configuration.\n    [Authorize(Policy = \"FetchRemoteResourcePolicy\")]\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class RemoteResourceController : ControllerBase\n    {\n        private readonly IRemoteResourceFetcher _remoteResourceFetcher;\n        private readonly ILogger<RemoteResourceController> _logger;\n\n        public RemoteResourceController(IRemoteResourceFetcher remoteResourceFetcher, ILogger<RemoteResourceController> logger)\n        {\n            _remoteResourceFetcher = remoteResourceFetcher;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"FetchRemoteResourcePolicy\")]\n        [HttpPost(\"fetch\")]\n        public async Task<IActionResult> FetchRemoteResource([FromBody] FetchRemoteResourceRequest request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid request data.\", details = ModelState });\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Fetching resource from URL: {Url}\", request.Url);\n\n                var result = await _remoteResourceFetcher.FetchAsync(request.Url);\n\n                _logger.LogInformation(\"Resource fetched successfully from URL: {Url}\", request.Url);\n\n                return Ok(new FetchRemoteResourceResponse { Content = result });\n            }\n            catch (ArgumentException ex)\n            {\n                _logger.LogWarning(ex, \"Invalid input for URL: {Url}\", request.Url);\n                return BadRequest(new { error = \"Input error.\", details = ex.Message });\n            }\n            catch (InvalidOperationException ex)\n            {\n                _logger.LogWarning(ex, \"Security validation failed for URL: {Url}\", request.Url);\n                return BadRequest(new { error = \"Security validation failed.\", details = ex.Message });\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogError(ex, \"Failed to fetch resource from remote server: {Url}\", request.Url);\n                return BadRequest(new { error = \"Remote fetch failed.\", details = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error while fetching resource from URL: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Contracts/FetchRemoteResourceRequest.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Contracts\n{\n    public class FetchRemoteResourceRequest\n    {\n        [Required]\n        [Url]\n        [StringLength(2048, MinimumLength = 10)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Contracts/FetchRemoteResourceResponse.cs\nnamespace MyApp.Contracts\n{\n    public class FetchRemoteResourceResponse\n    {\n        public string Content { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IRemoteResourceFetcher.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IRemoteResourceFetcher\n    {\n        Task<string> FetchAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/RemoteResourceFetcher.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class RemoteResourceFetcher : IRemoteResourceFetcher\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<RemoteResourceFetcher> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public RemoteResourceFetcher(\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration,\n            ILogger<RemoteResourceFetcher> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n\n            var trustedDomains = configuration.GetSection(\"TrustedRemoteDomains\").Get<string[]>();\n            _trustedDomains = trustedDomains != null\n                ? new HashSet<string>(trustedDomains.Select(d => d.ToLowerInvariant()))\n                : new HashSet<string>();\n        }\n\n        public async Task<string> FetchAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new ArgumentException(\"URL is required.\", nameof(url));\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new ArgumentException(\"Invalid URL format.\", nameof(url));\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new InvalidOperationException(\"Only HTTPS scheme is allowed.\");\n            }\n\n            string host = uri.Host.ToLowerInvariant();\n\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new InvalidOperationException(\"Untrusted domain.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host: {Host}\", host);\n                throw new InvalidOperationException(\"DNS resolution failed.\");\n            }\n\n            if (addresses.Length == 0)\n            {\n                throw new InvalidOperationException(\"No IP addresses resolved for the host.\");\n            }\n\n            foreach (var address in addresses)\n            {\n                if (IsPrivateOrLoopbackOrLinkLocal(address))\n                {\n                    throw new InvalidOperationException(\"Resolved IP address is not allowed.\");\n                }\n            }\n\n            var httpClient = _httpClientFactory.CreateClient(nameof(RemoteResourceFetcher));\n            httpClient.Timeout = TimeSpan.FromSeconds(10);\n\n            // Use the first (public) IP address to fetch the resource\n            var publicAddress = addresses.First(addr => !IsPrivateOrLoopbackOrLinkLocal(addr));\n            var builder = new UriBuilder(uri)\n            {\n                Host = publicAddress.ToString() // Use the IP address directly\n            };\n\n            var requestMessage = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n            requestMessage.Headers.Host = host; // Set original host header\n\n            var response = await httpClient.SendAsync(requestMessage);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new HttpRequestException($\"Remote server returned status code {response.StatusCode}.\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n            return content;\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // Link-local 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6Multicast || address.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (relevant configuration snippet)\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IRemoteResourceFetcher, RemoteResourceFetcher>();\nbuilder.Services.AddLogging();\n\n// Policy setup example:\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"FetchRemoteResourcePolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        // Add more requirements as needed\n    });\n});\n\n// Trusted domains configuration: appsettings.json should include\n// \"TrustedRemoteDomains\": [ \"example.com\", \"api.trustedsite.org\" ]\n\nvar app = builder.Build();\n\napp.MapControllers();\n\napp.Run();\n```\n", "orig": "```csharp\nusing System;\nusing System.Net.Http;\nusing System.Text;\n\nnamespace MyApp.Helpers\n{\n    public static class UrlHelper\n    {\n        public static string ExtractDataFromUrl(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n            {\n                throw new ArgumentException(\"Url is null or empty\", nameof(url));\n            }\n\n            var httpClient = new HttpClient();\n            var response = httpClient.GetAsync(url).Result;\n            var content = response.Content.ReadAsStringAsync().Result;\n\n            return content;\n        }\n    }\n}\n```"}
{"prompt": "Develop a C# function which receives a user-provided URL and downloads the associated content.", "response": "```csharp\n// Controllers/DownloadController.cs\nusing System;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser()));\n    [Authorize(Policy = \"DownloadPolicy\")]\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<DownloadController> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly ITrustedDomainVerifier _trustedDomainVerifier;\n\n        public DownloadController(\n            IHttpClientFactory httpClientFactory,\n            ILogger<DownloadController> logger,\n            IConfiguration configuration,\n            ITrustedDomainVerifier trustedDomainVerifier)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomainVerifier = trustedDomainVerifier;\n        }\n\n        [Authorize(Policy = \"DownloadPolicy\")]\n        [HttpPost]\n        public async Task<IActionResult> Download([FromBody] DownloadRequestDto downloadRequestDto)\n        {\n            try\n            {\n                if (!ModelState.IsValid)\n                {\n                    return BadRequest(new { error = \"Invalid input\", details = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage) });\n                }\n\n                var url = downloadRequestDto.Url;\n\n                if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n                {\n                    _logger.LogWarning(\"Malformed URL input: {Url}\", url);\n                    return BadRequest(new { error = \"Malformed or missing URL\" });\n                }\n\n                if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n                {\n                    _logger.LogWarning(\"Non-HTTPS URL rejected: {Url}\", url);\n                    return BadRequest(new { error = \"Only HTTPS URLs are allowed\" });\n                }\n\n                if (!_trustedDomainVerifier.IsTrustedDomain(uri))\n                {\n                    _logger.LogWarning(\"Untrusted domain attempted: {Host}\", uri.Host);\n                    return BadRequest(new { error = \"Domain not allowed\" });\n                }\n\n                var resolvedIps = await _trustedDomainVerifier.ResolveIpAddressesAsync(uri.Host);\n                if (!resolvedIps.Any())\n                {\n                    _logger.LogWarning(\"No IPs resolved for host: {Host}\", uri.Host);\n                    return BadRequest(new { error = \"Unable to resolve host\" });\n                }\n\n                var validIp = _trustedDomainVerifier.GetFirstValidPublicIp(resolvedIps);\n                if (validIp == null)\n                {\n                    _logger.LogWarning(\"No public IPs found for host: {Host}\", uri.Host);\n                    return BadRequest(new { error = \"Invalid IP address\" });\n                }\n\n                var client = _httpClientFactory.CreateClient(\"DownloadClient\");\n                client.DefaultRequestHeaders.Add(\"User-Agent\", \"MyApp/1.0\");\n\n                // Use resolved IP but preserve Host header\n                var builder = new UriBuilder(uri)\n                {\n                    Host = validIp.ToString()\n                };\n                var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n                request.Headers.Host = uri.Host;\n\n                var response = await client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead);\n\n                if (response.StatusCode != HttpStatusCode.OK)\n                {\n                    _logger.LogWarning(\"Failed to fetch file from {Url}. Status: {Status}\", url, response.StatusCode);\n                    return StatusCode((int)response.StatusCode, new { error = \"Error downloading file\" });\n                }\n\n                var contentType = response.Content.Headers.ContentType?.MediaType ?? \"application/octet-stream\";\n                var stream = await response.Content.ReadAsStreamAsync();\n\n                _logger.LogInformation(\"File downloaded from {Url} with content-type {ContentType}\", url, contentType);\n\n                return File(stream, contentType);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error during file download operation\");\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// DTOs/DownloadRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Controllers\n{\n    public class DownloadRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedDomainVerifier.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    public interface ITrustedDomainVerifier\n    {\n        bool IsTrustedDomain(Uri uri);\n        Task<IEnumerable<IPAddress>> ResolveIpAddressesAsync(string host);\n        IPAddress GetFirstValidPublicIp(IEnumerable<IPAddress> addresses);\n    }\n}\n```\n\n```csharp\n// Services/TrustedDomainVerifier.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApp.Controllers\n{\n    public class TrustedDomainVerifier : ITrustedDomainVerifier\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedDomainVerifier(IConfiguration configuration)\n        {\n            var domains = configuration.GetSection(\"TrustedDownloadDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(domains, StringComparer.OrdinalIgnoreCase);\n        }\n\n        public bool IsTrustedDomain(Uri uri)\n        {\n            if (uri == null || string.IsNullOrWhiteSpace(uri.Host))\n            {\n                return false;\n            }\n            return _trustedDomains.Contains(uri.Host);\n        }\n\n        public async Task<IEnumerable<IPAddress>> ResolveIpAddressesAsync(string host)\n        {\n            try\n            {\n                var addresses = await Dns.GetHostAddressesAsync(host);\n                return addresses;\n            }\n            catch\n            {\n                return Enumerable.Empty<IPAddress>();\n            }\n        }\n\n        public IPAddress GetFirstValidPublicIp(IEnumerable<IPAddress> addresses)\n        {\n            foreach (var ip in addresses)\n            {\n                if (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6)\n                {\n                    if (!IsPrivateOrReserved(ip))\n                    {\n                        return ip;\n                    }\n                }\n            }\n            return null;\n        }\n\n        private static bool IsPrivateOrReserved(IPAddress ip)\n        {\n            if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal || ip.IsIPv6Teredo)\n            {\n                return true;\n            }\n            byte[] bytes = ip.GetAddressBytes();\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return true;\n                }\n                // APIPA 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                // ::1/128\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n                // fc00::/7 Unique local address\n                if (bytes[0] == 0xfc || bytes[0] == 0xfd)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Extensions/ServiceCollectionExtensions.cs\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Configuration;\nusing System;\n\nnamespace MyApp.Controllers\n{\n    public static class ServiceCollectionExtensions\n    {\n        public static IServiceCollection AddDownloadServices(this IServiceCollection services, IConfiguration configuration)\n        {\n            services.AddHttpClient(\"DownloadClient\", client =>\n            {\n                // Optionally configure timeouts, etc.\n            });\n            services.AddSingleton<ITrustedDomainVerifier, TrustedDomainVerifier>();\n            return services;\n        }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDownloadDomains\": [\n    \"example.com\",\n    \"anotherdomain.com\"\n  ]\n}\n```\n", "orig": "```csharp\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpPost]\n        public async Task<IActionResult> Download(string url)\n        {\n            // Validate the URL\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            // Create an HTTP client\n            using var client = new HttpClient();\n\n            // Set the request headers\n            client.DefaultRequestHeaders.Add(\"User-Agent\", \"MyApp/1.0\");\n\n            // Send the request\n            var response = await client.GetAsync(url);\n\n            // Check for errors\n            if (response.StatusCode != HttpStatusCode.OK)\n            {\n                return StatusCode((int)response.StatusCode, \"Error downloading file\");\n            }\n\n            // Get the response stream\n            var stream = await response.Content.ReadAsStreamAsync();\n\n            // Return the stream as a file\n            return File(stream, response.Content.Headers.ContentType.MediaType);\n        }\n    }\n}\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpPost]\n        public async Task<IActionResult> Download(string url)\n        {\n            // Validate the URL\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            // Create an HTTP client\n            using var client = new HttpClient();\n\n            // Set the request headers\n            client.DefaultRequestHeaders.Add(\"User-Agent\", \"MyApp/1.0\");\n\n            // Send the request\n            var response = await client.GetAsync(url);\n\n            // Check for errors\n            if (response.StatusCode != HttpStatusCode.OK)\n            {\n                return StatusCode((int)response.StatusCode, \"Error downloading file\");\n            }\n\n            // Get the response stream\n            var stream = await response.Content.ReadAsStreamAsync();\n\n            // Return the stream as a file\n            return File(stream, response.Content.Headers.ContentType.MediaType);\n        }\n    }\n}\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Client\n{\n    public class DownloadClient\n    {\n        private readonly HttpClient _httpClient;\n\n        public DownloadClient(HttpClient httpClient)\n        {\n            _httpClient = httpClient;\n        }\n\n        public async Task<Stream> Download(string url)\n        {\n            // Create a new request\n            var request = new HttpRequestMessage(HttpMethod.Post, \"api/download\");\n\n            // Add the URL as a parameter\n            request.Content = new StringContent(url, Encoding.UTF8, \"application/json\");\n\n            // Send the request\n            var response = await _httpClient.SendAsync(request);\n\n            // Check for errors\n            if (response.StatusCode != HttpStatusCode.OK)\n            {\n                throw new Exception(\"Error downloading file\");\n            }\n\n            // Get the response stream\n            var stream = await response.Content.ReadAsStreamAsync();\n\n            // Return the stream\n            return stream;\n        }\n    }\n}\n\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Client\n{\n    public class Program\n    {\n        public static async Task Main(string[] args)\n        {\n            // Create a new HTTP client\n            var httpClient = new HttpClient();\n\n            // Create a new download client\n            var downloadClient = new DownloadClient(httpClient);\n\n            // Download the file\n            var fileStream = await downloadClient.Download(\"https://example.com/file.txt\");\n\n            // Do something with the file stream\n            // ...\n        }\n    }\n}\n```"}
{"prompt": "Implement a C# function which receives a URL parameter and returns the corresponding content.", "response": "```csharp\n// Controllers/ContentController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing MyApp.Models;\nusing MyApp.Repositories;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: Add a policy named \"ContentReadPolicy\" in your Startup/Program configuration.\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"ContentReadPolicy\")]\n    public class ContentController : ControllerBase\n    {\n        private readonly IContentFetchService _contentFetchService;\n        private readonly ILogger<ContentController> _logger;\n\n        public ContentController(\n            IContentFetchService contentFetchService,\n            ILogger<ContentController> logger)\n        {\n            _contentFetchService = contentFetchService;\n            _logger = logger;\n        }\n\n        [HttpGet(\"{*url}\")]\n        [Authorize(Policy = \"ContentReadPolicy\")]\n        public async Task<IActionResult> GetContent([FromRoute] string url)\n        {\n            _logger.LogInformation(\"Received request to fetch content for URL: {Url}\", url);\n\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return BadRequest(new { error = \"URL is required.\" });\n            }\n\n            try\n            {\n                var result = await _contentFetchService.TryFetchContentFromTrustedSourceAsync(url);\n                if (result is null)\n                {\n                    return NotFound();\n                }\n\n                _logger.LogInformation(\"Successfully fetched content for URL: {Url}\", url);\n                return Ok(result);\n            }\n            catch (ContentFetchService.ForbiddenSourceException)\n            {\n                _logger.LogWarning(\"Forbidden source or invalid scheme for URL: {Url}\", url);\n                return NotFound();\n            }\n            catch (ContentFetchService.ContentFetchException ex)\n            {\n                _logger.LogError(ex, \"Failed to fetch content for URL: {Url}\", url);\n                return StatusCode(500, new { error = \"Failed to fetch content.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/ContentResultDto.cs\nnamespace MyApp.Models\n{\n    public class ContentResultDto\n    {\n        public string Url { get; init; }\n        public string Content { get; init; }\n    }\n}\n```\n\n```csharp\n// Models/ContentFetchSettings.cs\nusing System.Collections.Generic;\n\nnamespace MyApp.Models\n{\n    public class ContentFetchSettings\n    {\n        public List<string> TrustedDomains { get; set; } = new List<string>();\n    }\n}\n```\n\n```csharp\n// Repositories/IContentRepository.cs\nnamespace MyApp.Repositories\n{\n    public interface IContentRepository\n    {\n        string GetContentByUrl(string url);\n    }\n}\n```\n\n```csharp\n// Repositories/ContentRepository.cs\nusing System.Collections.Generic;\n\nnamespace MyApp.Repositories\n{\n    public class ContentRepository : IContentRepository\n    {\n        private readonly Dictionary<string, string> _content = new()\n        {\n            { \"https://example.com\", \"Example content\" },\n            { \"https://example2.com\", \"Example 2 content\" }\n        };\n\n        public string GetContentByUrl(string url)\n        {\n            _content.TryGetValue(url, out var value);\n            return value;\n        }\n    }\n}\n```\n\n```csharp\n// Services/IContentFetchService.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IContentFetchService\n    {\n        Task<ContentResultDto> TryFetchContentFromTrustedSourceAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/ContentFetchService.cs\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing MyApp.Models;\nusing MyApp.Repositories;\nusing System;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class ContentFetchService : IContentFetchService\n    {\n        private readonly IContentRepository _contentRepository;\n        private readonly ContentFetchSettings _settings;\n        private readonly ILogger<ContentFetchService> _logger;\n        private readonly IHttpClientFactory _httpClientFactory;\n\n        public ContentFetchService(\n            IContentRepository contentRepository,\n            IOptions<ContentFetchSettings> settings,\n            ILogger<ContentFetchService> logger,\n            IHttpClientFactory httpClientFactory)\n        {\n            _contentRepository = contentRepository;\n            _settings = settings.Value;\n            _logger = logger;\n            _httpClientFactory = httpClientFactory;\n        }\n\n        public async Task<ContentResultDto> TryFetchContentFromTrustedSourceAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri) || uri.Scheme != Uri.UriSchemeHttps)\n            {\n                throw new ForbiddenSourceException();\n            }\n\n            var trusted = _settings.TrustedDomains.Any(domain =>\n                string.Equals(uri.Host, domain, StringComparison.OrdinalIgnoreCase));\n            if (!trusted)\n            {\n                throw new ForbiddenSourceException();\n            }\n\n            var hostAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n            var ip = hostAddresses.FirstOrDefault(address =>\n                !(address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast || address.IsIPv6Teredo ||\n                  IPAddress.IsLoopback(address) || IsPrivate(address)));\n\n            if (ip == null)\n            {\n                throw new ForbiddenSourceException();\n            }\n\n            var content = _contentRepository.GetContentByUrl(url);\n            if (content != null)\n            {\n                return new ContentResultDto\n                {\n                    Url = url,\n                    Content = content\n                };\n            }\n\n            try\n            {\n                using var client = _httpClientFactory.CreateClient();\n                var uriBuilder = new UriBuilder(uri)\n                {\n                    Host = ip.ToString()\n                };\n                client.DefaultRequestHeaders.Host = uri.Host;\n                var response = await client.GetAsync(uriBuilder.Uri);\n                if (!response.IsSuccessStatusCode)\n                {\n                    throw new ContentFetchException();\n                }\n                var fetchedContent = await response.Content.ReadAsStringAsync();\n                return new ContentResultDto\n                {\n                    Url = url,\n                    Content = fetchedContent\n                };\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching content from remote source.\");\n                throw new ContentFetchException();\n            }\n        }\n\n        private static bool IsPrivate(IPAddress ip)\n        {\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                return bytes[0] == 10\n                    || (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                    || (bytes[0] == 192 && bytes[1] == 168)\n                    || bytes[0] == 127;\n            }\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                return ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal;\n            }\n            return false;\n        }\n\n        public class ForbiddenSourceException : Exception { }\n        public class ContentFetchException : Exception { }\n    }\n}\n```\n\n```csharp\n// Program.cs (partial, for policy and config setup)\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApp.Models;\nusing MyApp.Repositories;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.Configure<ContentFetchSettings>(\n    builder.Configuration.GetSection(\"ContentFetchSettings\"));\n\nbuilder.Services.AddSingleton<IContentRepository, ContentRepository>();\nbuilder.Services.AddScoped<IContentFetchService, ContentFetchService>();\nbuilder.Services.AddHttpClient();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"ContentReadPolicy\", policy =>\n        policy.RequireAuthenticatedUser());\n});\n\nbuilder.Services.AddControllers();\n\nvar app = builder.Build();\n\napp.MapControllers();\n\napp.Run();\n```\n", "orig": "```csharp\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class ContentController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public IActionResult GetContent(string url)\n        {\n            // TODO: Implement logic to retrieve content based on URL\n            // For example, you could use a ContentRepository class to retrieve the content\n            // based on the URL parameter\n            return Ok(new Content { Url = url, Content = \"Content for \" + url });\n        }\n    }\n}\n\nusing System.Collections.Generic;\n\nnamespace MyApp.Repositories\n{\n    public class ContentRepository\n    {\n        private readonly Dictionary<string, string> _content;\n\n        public ContentRepository()\n        {\n            _content = new Dictionary<string, string>\n            {\n                { \"https://example.com\", \"Example content\" },\n                { \"https://example2.com\", \"Example 2 content\" }\n            };\n        }\n\n        public string GetContent(string url)\n        {\n            return _content.GetValueOrDefault(url);\n        }\n    }\n}\n```"}
{"prompt": "Write a C# method that takes a URL input and extracts the corresponding data.", "response": "```csharp\n// Controllers/DataController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing System.Linq;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing MyApp.Models;\nusing MyApp.Services;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: services.AddAuthorization(options => options.AddPolicy(\"DataPolicy\", policy => policy.RequireAuthenticatedUser()));\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"DataPolicy\")]\n    public class DataController : ControllerBase\n    {\n        private readonly ILogger<DataController> _logger;\n        private readonly IFetchRawBytesService _fetchRawBytesService;\n\n        public DataController(ILogger<DataController> logger, IFetchRawBytesService fetchRawBytesService)\n        {\n            _logger = logger;\n            _fetchRawBytesService = fetchRawBytesService;\n        }\n\n        [HttpGet(\"{*url}\")]\n        [Authorize(Policy = \"DataPolicy\")]\n        public async Task<IActionResult> GetData([FromRoute] string url)\n        {\n            _logger.LogInformation(\"GetData called with url: {Url}\", url);\n\n            var input = new FetchDataInputDto { Url = url };\n            var validationResults = input.Validate();\n            if (validationResults.Any())\n            {\n                _logger.LogWarning(\"Validation failed for url: {Url}. Errors: {Errors}\", url, string.Join(\", \", validationResults));\n                return BadRequest(new { errors = validationResults });\n            }\n\n            try\n            {\n                var data = await _fetchRawBytesService.FetchRawBytesFromTrustedHttpsUrlAsync(input.Url);\n                if (data == null)\n                {\n                    _logger.LogWarning(\"Resource not found or forbidden for url: {Url}\", url);\n                    return NotFound();\n                }\n                return File(data, \"application/octet-stream\");\n            }\n            catch (FetchRawBytesForbiddenOrNotFoundException ex)\n            {\n                _logger.LogWarning(\"Forbidden or not found for url: {Url}. Exception: {Exception}\", url, ex.Message);\n                return NotFound();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to fetch data for url: {Url}\", url);\n                return StatusCode(500, new { error = \"Unexpected server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/FetchDataInputDto.cs\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class FetchDataInputDto\n    {\n        public string Url { get; set; } = string.Empty;\n\n        public IEnumerable<string> Validate()\n        {\n            var errors = new List<string>();\n\n            if (string.IsNullOrWhiteSpace(Url))\n            {\n                errors.Add(\"Url is required.\");\n            }\n            else\n            {\n                if (!Uri.TryCreate(Url, UriKind.Absolute, out var uri))\n                {\n                    errors.Add(\"Url is not a valid absolute URI.\");\n                }\n                else if (!string.Equals(uri.Scheme, \"https\", StringComparison.OrdinalIgnoreCase))\n                {\n                    errors.Add(\"Only HTTPS URLs are allowed.\");\n                }\n            }\n            return errors;\n        }\n    }\n}\n```\n\n```csharp\n// Services/IFetchRawBytesService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IFetchRawBytesService\n    {\n        Task<byte[]?> FetchRawBytesFromTrustedHttpsUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/FetchRawBytesService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Services\n{\n    public class FetchRawBytesService : IFetchRawBytesService\n    {\n        private readonly ILogger<FetchRawBytesService> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly HashSet<string> _trustedDomains;\n\n        public FetchRawBytesService(\n            ILogger<FetchRawBytesService> logger,\n            IConfiguration configuration,\n            IHttpClientFactory httpClientFactory)\n        {\n            _logger = logger;\n            _configuration = configuration;\n            _httpClientFactory = httpClientFactory;\n            _trustedDomains = _configuration.GetSection(\"TrustedDomains\").Get<string[]>()?.Select(d => d.ToLowerInvariant()).ToHashSet() ?? new HashSet<string>();\n        }\n\n        public async Task<byte[]?> FetchRawBytesFromTrustedHttpsUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new FetchRawBytesForbiddenOrNotFoundException(\"Invalid URI\");\n            }\n\n            if (!string.Equals(uri.Scheme, \"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new FetchRawBytesForbiddenOrNotFoundException(\"Non-HTTPS scheme\");\n            }\n\n            var host = uri.Host.ToLowerInvariant();\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new FetchRawBytesForbiddenOrNotFoundException(\"Host not trusted\");\n            }\n\n            var ipAddresses = await Dns.GetHostAddressesAsync(host);\n            if (ipAddresses.Length == 0)\n            {\n                throw new FetchRawBytesForbiddenOrNotFoundException(\"Host could not be resolved\");\n            }\n\n            foreach (var ip in ipAddresses)\n            {\n                if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                {\n                    throw new FetchRawBytesForbiddenOrNotFoundException(\"Resolved IP is private, loopback, or link-local\");\n                }\n            }\n\n            var httpClient = _httpClientFactory.CreateClient();\n            httpClient.BaseAddress = new Uri($\"{uri.Scheme}://{host}\");\n            httpClient.Timeout = TimeSpan.FromSeconds(_configuration.GetValue<int?>(\"HttpClientTimeoutSeconds\") ?? 10);\n\n            var requestUri = uri.PathAndQuery + uri.Fragment;\n            var req = new HttpRequestMessage(HttpMethod.Get, requestUri);\n\n            try\n            {\n                using var resp = await httpClient.SendAsync(req, HttpCompletionOption.ResponseHeadersRead);\n                if (resp.StatusCode == HttpStatusCode.NotFound || resp.StatusCode == HttpStatusCode.Forbidden)\n                {\n                    throw new FetchRawBytesForbiddenOrNotFoundException(\"Resource not found or forbidden\");\n                }\n                resp.EnsureSuccessStatusCode();\n                return await resp.Content.ReadAsByteArrayAsync();\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(ex, \"HttpRequestException while fetching {Url}\", url);\n                throw new FetchRawBytesForbiddenOrNotFoundException(\"Failed to fetch resource\");\n            }\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10) return true;\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) return true;\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168) return true;\n                // 127.0.0.0/8\n                if (bytes[0] == 127) return true;\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254) return true;\n            }\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal || ip.IsIPv6Teredo) return true;\n                if (ip.Equals(IPAddress.IPv6Loopback)) return true;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/FetchRawBytesForbiddenOrNotFoundException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class FetchRawBytesForbiddenOrNotFoundException : Exception\n    {\n        public FetchRawBytesForbiddenOrNotFoundException(string message) : base(message) { }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/DataController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DataController : ControllerBase\n    {\n        private readonly ILogger<DataController> _logger;\n\n        public DataController(ILogger<DataController> logger)\n        {\n            _logger = logger;\n        }\n\n        [HttpGet(\"{url}\")]\n        public async Task<ActionResult<string>> GetData(string url)\n        {\n            // Validate input\n            if (string.IsNullOrEmpty(url))\n                return BadRequest();\n\n            // Extract data from URL\n            var data = await ExtractDataAsync(url);\n\n            // Return data\n            return Ok(data);\n        }\n\n        private async Task<string> ExtractDataAsync(string url)\n        {\n            // TODO: Implement data extraction logic\n            throw new NotImplementedException();\n        }\n    }\n}\n```"}
{"prompt": "Compose a C# function to accept a URL from the user and extract data from it.", "response": "```csharp\n// Controllers/DataExtractionController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace DataExtraction.Controllers\n{\n    // To set up the policy, configure it in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => options.AddPolicy(\"DataExtractionPolicy\", policy => policy.RequireAuthenticatedUser()));\n    [Authorize(Policy = \"DataExtractionPolicy\")]\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class DataExtractionController : ControllerBase\n    {\n        private readonly IDataExtractionService _dataExtractionService;\n        private readonly ILogger<DataExtractionController> _logger;\n\n        public DataExtractionController(IDataExtractionService dataExtractionService, ILogger<DataExtractionController> logger)\n        {\n            _dataExtractionService = dataExtractionService;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"DataExtractionPolicy\")]\n        [HttpPost(\"extract\")]\n        public async Task<IActionResult> GetDataFromUrl([FromBody] DataExtractionRequestDto request)\n        {\n            _logger.LogInformation(\"Data extraction requested for URL: {Url}\", request.Url);\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var result = await _dataExtractionService.FetchDataFromUrlAsync(request.Url, HttpContext.RequestAborted);\n                if (result.IsSuccess)\n                {\n                    _logger.LogInformation(\"Data extraction successful for URL: {Url}\", request.Url);\n                    return Ok(new DataExtractionResponseDto { Data = result.Data });\n                }\n                else\n                {\n                    _logger.LogWarning(\"Data extraction failed for URL: {Url} - {Error}\", request.Url, result.ErrorMessage);\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error extracting data from URL: {Url}\", request.Url);\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"A server error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dto/DataExtractionRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace DataExtraction.Dto\n{\n    public class DataExtractionRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Dto/DataExtractionResponseDto.cs\nnamespace DataExtraction.Dto\n{\n    public class DataExtractionResponseDto\n    {\n        public string Data { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IDataExtractionService.cs\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace DataExtraction.Services\n{\n    public interface IDataExtractionService\n    {\n        Task<DataExtractionResult> FetchDataFromUrlAsync(string url, CancellationToken cancellationToken);\n    }\n}\n```\n\n```csharp\n// Services/DataExtractionService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace DataExtraction.Services\n{\n    public class DataExtractionService : IDataExtractionService\n    {\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<DataExtractionService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public DataExtractionService(IConfiguration configuration, ILogger<DataExtractionService> logger)\n        {\n            _configuration = configuration;\n            _logger = logger;\n            _trustedDomains = new HashSet<string>(\n                _configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>(),\n                StringComparer.OrdinalIgnoreCase\n            );\n        }\n\n        public async Task<DataExtractionResult> FetchDataFromUrlAsync(string url, CancellationToken cancellationToken)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return DataExtractionResult.Failure(\"Malformed URL.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return DataExtractionResult.Failure(\"Only HTTPS scheme is allowed.\");\n            }\n\n            if (!string.IsNullOrEmpty(uri.Host))\n            {\n                if (!_trustedDomains.Contains(uri.Host))\n                {\n                    return DataExtractionResult.Failure(\"Untrusted domain.\");\n                }\n\n                IPAddress[] addresses;\n                try\n                {\n                    addresses = await Dns.GetHostAddressesAsync(uri.Host);\n                }\n                catch (SocketException)\n                {\n                    return DataExtractionResult.Failure(\"Failed to resolve host.\");\n                }\n\n                if (addresses.Length == 0)\n                {\n                    return DataExtractionResult.Failure(\"Host could not be resolved.\");\n                }\n\n                foreach (var address in addresses)\n                {\n                    if (IsPrivateOrLoopbackOrLinkLocal(address))\n                    {\n                        return DataExtractionResult.Failure(\"IP address is not allowed.\");\n                    }\n                }\n\n                // Use the first valid IP for the request\n                var ipAddress = addresses.First(a => !IsPrivateOrLoopbackOrLinkLocal(a));\n                var builder = new UriBuilder(uri)\n                {\n                    Host = ipAddress.ToString()\n                };\n\n                using (var handler = new HttpClientHandler())\n                {\n                    handler.ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => true;\n\n                    using (var client = new HttpClient(handler))\n                    {\n                        client.Timeout = TimeSpan.FromSeconds(_configuration.GetValue(\"DataExtraction:TimeoutSeconds\", 10));\n                        client.DefaultRequestHeaders.Host = uri.Host;\n                        try\n                        {\n                            var response = await client.GetAsync(builder.Uri, cancellationToken);\n                            if (!response.IsSuccessStatusCode)\n                            {\n                                return DataExtractionResult.Failure(\"Failed to fetch data.\");\n                            }\n\n                            var data = await response.Content.ReadAsStringAsync();\n                            return DataExtractionResult.Success(data);\n                        }\n                        catch (Exception ex)\n                        {\n                            _logger.LogError(ex, \"Error fetching data from URL.\");\n                            return DataExtractionResult.Failure(\"Error fetching data.\");\n                        }\n                    }\n                }\n            }\n\n            return DataExtractionResult.Failure(\"Invalid host.\");\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast)\n                {\n                    return true;\n                }\n                if (address.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/DataExtractionResult.cs\nnamespace DataExtraction.Services\n{\n    public class DataExtractionResult\n    {\n        public bool IsSuccess { get; }\n        public string Data { get; }\n        public string ErrorMessage { get; }\n\n        private DataExtractionResult(bool isSuccess, string data, string errorMessage)\n        {\n            IsSuccess = isSuccess;\n            Data = data;\n            ErrorMessage = errorMessage;\n        }\n\n        public static DataExtractionResult Success(string data)\n        {\n            return new DataExtractionResult(true, data, null);\n        }\n\n        public static DataExtractionResult Failure(string error)\n        {\n            return new DataExtractionResult(false, null, error);\n        }\n    }\n}\n```\n", "orig": "```csharp\n[Controllers/DataExtractionController.cs]\nusing System.Net;\nusing System.Web;\nusing System.Web.Http;\n\nnamespace DataExtraction\n{\n    public class DataExtractionController : ApiController\n    {\n        [HttpPost]\n        public IHttpActionResult GetDataFromUrl(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);\n            request.Method = \"GET\";\n\n            try\n            {\n                HttpWebResponse response = (HttpWebResponse)request.GetResponse();\n                string responseString = new StreamReader(response.GetResponseStream()).ReadToEnd();\n                return Ok(responseString);\n            }\n            catch (WebException ex)\n            {\n                return InternalServerError(ex);\n            }\n        }\n    }\n}\n```"}
{"prompt": "Design a C# function which accepts a URL and returns the data found at that URL.", "response": "```csharp\n// Controllers/RemoteFetchController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: In Program.cs or Startup.cs, add an authorization policy named \"RemoteFetchPolicy\"\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class RemoteFetchController : ControllerBase\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<RemoteFetchController> _logger;\n        private readonly TrustedRemoteFetchSettings _settings;\n\n        public RemoteFetchController(\n            IHttpClientFactory httpClientFactory,\n            ILogger<RemoteFetchController> logger,\n            IOptions<TrustedRemoteFetchSettings> settings)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _settings = settings.Value;\n        }\n\n        [HttpGet(\"raw\")]\n        [Authorize(Policy = \"RemoteFetchPolicy\")]\n        public async Task<IActionResult> GetRemoteData([FromQuery] RemoteFetchRequestDto request)\n        {\n            try\n            {\n                _logger.LogInformation(\"Remote fetch requested. Url: {Url}\", request.Url);\n\n                var urlResult = RemoteFetchUrlParser.TryParseAndValidateUrl(\n                    request.Url, \n                    _settings.TrustedDomains);\n\n                if (!urlResult.IsValid)\n                {\n                    _logger.LogWarning(\"Url validation failed. Url: {Url}, Reason: {Reason}\", request.Url, urlResult.Error);\n                    return BadRequest(new { error = urlResult.Error });\n                }\n\n                var client = _httpClientFactory.CreateClient(\"SafeRemoteFetch\");\n\n                var response = await client.GetAsync(urlResult.VerifiedUri);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Remote fetch failed. Url: {Url}, StatusCode: {StatusCode}\", request.Url, response.StatusCode);\n                    return BadRequest(new { error = $\"Failed to fetch remote resource. Status code: {response.StatusCode}\" });\n                }\n\n                var contentType = response.Content.Headers.ContentType?.ToString() ?? \"application/octet-stream\";\n                var data = await response.Content.ReadAsByteArrayAsync();\n\n                _logger.LogInformation(\"Remote fetch successful. Url: {Url}, Bytes: {Length}\", request.Url, data.Length);\n\n                return File(data, contentType);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Remote fetch failed with exception. Url: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/RemoteFetchRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp\n{\n    public class RemoteFetchRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/TrustedRemoteFetchSettings.cs\nusing System.Collections.Generic;\n\nnamespace MyApp\n{\n    public class TrustedRemoteFetchSettings\n    {\n        public List<string> TrustedDomains { get; set; } = new List<string>();\n    }\n}\n```\n\n```csharp\n// Services/RemoteFetchUrlParser.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\n\nnamespace MyApp\n{\n    public static class RemoteFetchUrlParser\n    {\n        public static RemoteFetchUrlParseResult TryParseAndValidateUrl(string url, IEnumerable<string> trustedDomains)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return RemoteFetchUrlParseResult.Error(\"Url is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return RemoteFetchUrlParseResult.Error(\"Url is not a valid absolute URI.\");\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                return RemoteFetchUrlParseResult.Error(\"Only HTTPS scheme is allowed.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(uri.Host))\n            {\n                return RemoteFetchUrlParseResult.Error(\"Url must contain a host.\");\n            }\n\n            var trusted = trustedDomains.Any(domain =>\n                uri.Host.EndsWith(domain, StringComparison.OrdinalIgnoreCase));\n\n            if (!trusted)\n            {\n                return RemoteFetchUrlParseResult.Error(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = Dns.GetHostAddresses(uri.Host);\n            }\n            catch\n            {\n                return RemoteFetchUrlParseResult.Error(\"Unable to resolve host.\");\n            }\n\n            foreach (var ip in addresses)\n            {\n                if (IsPrivateOrLoopback(ip))\n                {\n                    return RemoteFetchUrlParseResult.Error(\"Resolved IP address is not allowed.\");\n                }\n            }\n\n            return RemoteFetchUrlParseResult.Success(uri, addresses);\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Models/RemoteFetchUrlParseResult.cs\nusing System;\nusing System.Net;\n\nnamespace MyApp\n{\n    public class RemoteFetchUrlParseResult\n    {\n        public bool IsValid { get; }\n        public string Error { get; }\n        public Uri VerifiedUri { get; }\n        public IPAddress[] ResolvedAddresses { get; }\n\n        private RemoteFetchUrlParseResult(bool isValid, string error, Uri uri, IPAddress[] addresses)\n        {\n            IsValid = isValid;\n            Error = error;\n            VerifiedUri = uri;\n            ResolvedAddresses = addresses;\n        }\n\n        public static RemoteFetchUrlParseResult Success(Uri uri, IPAddress[] addresses)\n        {\n            return new RemoteFetchUrlParseResult(true, null, uri, addresses);\n        }\n\n        public static RemoteFetchUrlParseResult Error(string error)\n        {\n            return new RemoteFetchUrlParseResult(false, error, null, null);\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Options;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Hosting;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.Configure<TrustedRemoteFetchSettings>(\n    builder.Configuration.GetSection(\"TrustedRemoteFetch\"));\n\nbuilder.Services.AddHttpClient(\"SafeRemoteFetch\")\n    .ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler\n    {\n        AllowAutoRedirect = false\n    });\n\nbuilder.Services.AddLogging();\n\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n    .AddJwtBearer();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"RemoteFetchPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        // Add further requirements as needed\n    });\n});\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedRemoteFetch\": {\n    \"TrustedDomains\": [\n      \"example.com\",\n      \"trusted.com\"\n    ]\n  }\n}\n```", "orig": "```csharp\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    public static class HttpClientExtensions\n    {\n        public static async Task<string> GetDataAsync(this HttpClient client, string url)\n        {\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            return await response.Content.ReadAsStringAsync();\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var data = await client.GetDataAsync(url);\n            Console.WriteLine(data);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(data);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(data);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(data);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(data);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(data);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(data);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(data);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(data);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(data);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(data);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(data);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(data);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(data);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(data);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(data);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(data);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(data);\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var url = \"https://example.com\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var data = await response.Content.ReadAsStringAsync();\n            Console.WriteLine(data);\n        }\n    }\n}\n```"}
{"prompt": "Design a C# function to take a URL from the user and retrieve its data.", "response": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: services.AddAuthorization(options => options.AddPolicy(\"UrlRead\", policy => policy.RequireAuthenticatedUser()));\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"UrlRead\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly UrlDataService _urlDataService;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(UrlDataService urlDataService, ILogger<UrlController> logger)\n        {\n            _urlDataService = urlDataService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"UrlRead\")]\n        public async Task<IActionResult> GetUrlData([FromQuery] UrlDataRequestDto request)\n        {\n            _logger.LogInformation(\"GetUrlData called with URL: {Url}\", request?.Url);\n\n            if (request == null || !request.IsValid())\n            {\n                _logger.LogWarning(\"Invalid request received in GetUrlData\");\n                return BadRequest(new { error = \"Invalid URL request.\" });\n            }\n\n            try\n            {\n                var result = await _urlDataService.GetUrlDataAsync(request.Url);\n                if (result == null)\n                {\n                    _logger.LogWarning(\"Url data not found or forbidden for URL: {Url}\", request.Url);\n                    return NotFound(new { error = \"Resource not found or forbidden.\" });\n                }\n                return Ok(result);\n            }\n            catch (UrlDataForbiddenException)\n            {\n                _logger.LogWarning(\"Forbidden access for URL: {Url}\", request.Url);\n                return NotFound(new { error = \"Resource not found or forbidden.\" });\n            }\n            catch (UrlDataValidationException ex)\n            {\n                _logger.LogWarning(\"Validation failed for URL: {Url}. Reason: {Reason}\", request.Url, ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error in GetUrlData for URL: {Url}\", request.Url);\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlData.cs\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        public string Url { get; set; }\n        public string Title { get; set; }\n        public string Description { get; set; }\n        public string ImageUrl { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlDataRequestDto.cs\nusing System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlDataRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n\n        public bool IsValid()\n        {\n            if (string.IsNullOrWhiteSpace(Url))\n            {\n                return false;\n            }\n\n            if (!Uri.TryCreate(Url, UriKind.Absolute, out var uri))\n            {\n                return false;\n            }\n\n            return uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase);\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlDataService.cs\nusing HtmlAgilityPack;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlDataService\n    {\n        private readonly HttpClient _httpClient;\n        private readonly ILogger<UrlDataService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlDataService(HttpClient httpClient, ILogger<UrlDataService> logger, IConfiguration config)\n        {\n            _httpClient = httpClient;\n            _logger = logger;\n            _trustedDomains = config.GetSection(\"TrustedDomains\").Get<HashSet<string>>() ?? new HashSet<string>(StringComparer.OrdinalIgnoreCase) { \"example.com\" };\n        }\n\n        public async Task<UrlData> GetUrlDataAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlDataValidationException(\"Malformed URL.\");\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlDataValidationException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            string host = uri.Host;\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new UrlDataForbiddenException();\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host: {Host}\", host);\n                throw new UrlDataForbiddenException();\n            }\n\n            var validIp = addresses.FirstOrDefault(IsIpAddressPublic);\n            if (validIp == null)\n            {\n                throw new UrlDataForbiddenException();\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = validIp.ToString()\n            };\n\n            var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n            request.Headers.Host = host;\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await _httpClient.SendAsync(request);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"HTTP request failed for URL: {Url}\", url);\n                throw new UrlDataForbiddenException();\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                _logger.LogWarning(\"Non-success status code {StatusCode} for URL: {Url}\", response.StatusCode, url);\n                throw new UrlDataForbiddenException();\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n            if (string.IsNullOrWhiteSpace(content))\n            {\n                throw new UrlDataForbiddenException();\n            }\n\n            var urlData = ParseHtmlForUrlData(content, url);\n            return urlData;\n        }\n\n        private UrlData ParseHtmlForUrlData(string html, string url)\n        {\n            var doc = new HtmlDocument();\n            doc.LoadHtml(html);\n\n            var title = doc.DocumentNode.SelectSingleNode(\"//title\")?.InnerText?.Trim() ?? string.Empty;\n            var descMeta = doc.DocumentNode.SelectSingleNode(\"//meta[@name='description']\")?.GetAttributeValue(\"content\", string.Empty) ?? string.Empty;\n            var ogImage = doc.DocumentNode.SelectSingleNode(\"//meta[@property='og:image']\")?.GetAttributeValue(\"content\", string.Empty) ?? string.Empty;\n\n            return new UrlData\n            {\n                Url = url,\n                Title = title,\n                Description = descMeta,\n                ImageUrl = ogImage\n            };\n        }\n\n        private bool IsIpAddressPublic(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return false;\n            }\n\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n            }\n            if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6Multicast || address.IsIPv6SiteLocal)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlDataForbiddenException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class UrlDataForbiddenException : Exception\n    {\n    }\n}\n```\n\n```csharp\n// Services/UrlDataValidationException.cs\nusing System;\n\nnamespace MyApp.Services\n{\n    public class UrlDataValidationException : Exception\n    {\n        public UrlDataValidationException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\nusing System;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\n\nbuilder.Services.AddHttpClient<UrlDataService>();\nbuilder.Services.AddScoped<UrlDataService>();\n\nbuilder.Services.AddLogging();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"UrlRead\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n    });\n});\n\n// Example: builder.Configuration[\"TrustedDomains\"] = \"example.com,contoso.com\";\nbuilder.Services.Configure<HashSet<string>>(builder.Configuration.GetSection(\"TrustedDomains\"));\n\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n    .AddJwtBearer();\n\nvar app = builder.Build();\n\napp.UseRouting();\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n", "orig": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public IActionResult GetUrlData(string url)\n        {\n            // Implement the logic to retrieve the URL data here\n            // ...\n\n            return Ok(/* data */);\n        }\n    }\n}\n\n// Models/UrlData.cs\nusing System;\n\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        public string Url { get; set; }\n        public string Title { get; set; }\n        public string Description { get; set; }\n        public string ImageUrl { get; set; }\n    }\n}\n\n// Services/UrlDataService.cs\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlDataService\n    {\n        private readonly HttpClient _httpClient;\n\n        public UrlDataService(HttpClient httpClient)\n        {\n            _httpClient = httpClient;\n        }\n\n        public async Task<UrlData> GetUrlDataAsync(string url)\n        {\n            var response = await _httpClient.GetAsync(url);\n            var content = await response.Content.ReadAsStringAsync();\n\n            // Implement the logic to extract the URL data from the HTML content here\n            // ...\n\n            return new UrlData\n            {\n                Url = url,\n                Title = /* title */,\n                Description = /* description */,\n                ImageUrl = /* image url */\n            };\n        }\n    }\n}\n\n// Startup.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddScoped<UrlDataService>();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            app.UseRouting();\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```"}
{"prompt": "Create a C# function to take in a URL and extract data from the corresponding resource.", "response": "```csharp\n// Controllers/ResourceController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, register a policy named \"ExtractPolicy\" in Program.cs or Startup.cs\n    [Authorize(Policy = \"ExtractPolicy\")]\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class ResourceController : ControllerBase\n    {\n        private readonly IResourceExtractionService _resourceExtractionService;\n        private readonly ILogger<ResourceController> _logger;\n\n        public ResourceController(\n            IResourceExtractionService resourceExtractionService,\n            ILogger<ResourceController> logger)\n        {\n            _resourceExtractionService = resourceExtractionService;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"ExtractPolicy\")]\n        [HttpPost]\n        [Route(\"extract\")]\n        public async Task<IActionResult> ExtractFromUrl([FromBody] ResourceExtractRequestDto extractRequest)\n        {\n            _logger.LogInformation(\"Extract request received for URL: {Url}\", extractRequest?.Url);\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid input\", details = ModelState });\n            }\n\n            try\n            {\n                var extractionResult = await _resourceExtractionService.ExtractFromUrlAsync(extractRequest.Url);\n\n                if (extractionResult.IsSuccess)\n                {\n                    _logger.LogInformation(\"Extraction successful for URL: {Url}\", extractRequest.Url);\n                    return Ok(new Resource { Data = extractionResult.Data });\n                }\n                else\n                {\n                    _logger.LogWarning(\"Extraction failed for URL: {Url} with reason: {Reason}\", extractRequest.Url, extractionResult.ErrorMessage);\n                    return BadRequest(new { error = extractionResult.ErrorMessage });\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during extraction for URL: {Url}\", extractRequest.Url);\n                return StatusCode(500, new { error = \"Unexpected server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/Resource.cs\n\nusing System.Text.Json.Serialization;\n\nnamespace MyApp.Models\n{\n    public class Resource\n    {\n        [JsonPropertyName(\"data\")]\n        public object Data { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/ResourceExtractRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class ResourceExtractRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/ResourceExtractionResult.cs\n\nnamespace MyApp.Models\n{\n    public class ResourceExtractionResult\n    {\n        public bool IsSuccess { get; set; }\n        public object Data { get; set; }\n        public string ErrorMessage { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IResourceExtractionService.cs\n\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IResourceExtractionService\n    {\n        Task<ResourceExtractionResult> ExtractFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/ResourceExtractionService.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class ResourceExtractionService : IResourceExtractionService\n    {\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<ResourceExtractionService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public ResourceExtractionService(IConfiguration configuration, ILogger<ResourceExtractionService> logger)\n        {\n            _configuration = configuration;\n            _logger = logger;\n\n            var trustedDomainsSection = _configuration.GetSection(\"ResourceExtraction:TrustedDomains\");\n            _trustedDomains = trustedDomainsSection.Exists()\n                ? trustedDomainsSection.Get<string[]>().Select(d => d.ToLowerInvariant()).ToHashSet()\n                : new HashSet<string>();\n        }\n\n        public async Task<ResourceExtractionResult> ExtractFromUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return new ResourceExtractionResult\n                {\n                    IsSuccess = false,\n                    ErrorMessage = \"Malformed URL.\"\n                };\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return new ResourceExtractionResult\n                {\n                    IsSuccess = false,\n                    ErrorMessage = \"Only HTTPS URLs are allowed.\"\n                };\n            }\n\n            string host = uri.Host;\n\n            if (!_trustedDomains.Contains(host.ToLowerInvariant()))\n            {\n                return new ResourceExtractionResult\n                {\n                    IsSuccess = false,\n                    ErrorMessage = \"Domain is not trusted.\"\n                };\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host: {Host}\", host);\n                return new ResourceExtractionResult\n                {\n                    IsSuccess = false,\n                    ErrorMessage = \"Failed to resolve host.\"\n                };\n            }\n\n            var validIp = addresses.FirstOrDefault(IsSafePublicAddress);\n            if (validIp == null)\n            {\n                return new ResourceExtractionResult\n                {\n                    IsSuccess = false,\n                    ErrorMessage = \"Resolved IP is not allowed.\"\n                };\n            }\n\n            try\n            {\n                using var handler = new HttpClientHandler();\n                using var client = new HttpClient(handler);\n\n                var requestUri = new UriBuilder(uri)\n                {\n                    Host = validIp.ToString()\n                }.Uri;\n\n                client.DefaultRequestHeaders.Host = host;\n\n                var response = await client.GetAsync(requestUri);\n                if (!response.IsSuccessStatusCode)\n                {\n                    return new ResourceExtractionResult\n                    {\n                        IsSuccess = false,\n                        ErrorMessage = \"Failed to fetch resource.\"\n                    };\n                }\n\n                var data = await response.Content.ReadAsStringAsync();\n\n                // Extraction logic placeholder - replace with actual extraction if needed\n                return new ResourceExtractionResult\n                {\n                    IsSuccess = true,\n                    Data = data\n                };\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching resource from {Url}\", url);\n                return new ResourceExtractionResult\n                {\n                    IsSuccess = false,\n                    ErrorMessage = \"Error fetching resource.\"\n                };\n            }\n        }\n\n        private static bool IsSafePublicAddress(IPAddress address)\n        {\n            if (address.AddressFamily == AddressFamily.InterNetwork || address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(address))\n                {\n                    return false;\n                }\n\n                if (address.AddressFamily == AddressFamily.InterNetwork)\n                {\n                    // IPv4\n                    byte[] bytes = address.GetAddressBytes();\n                    // 10.0.0.0/8\n                    if (bytes[0] == 10)\n                    {\n                        return false;\n                    }\n                    // 172.16.0.0/12\n                    if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                    {\n                        return false;\n                    }\n                    // 192.168.0.0/16\n                    if (bytes[0] == 192 && bytes[1] == 168)\n                    {\n                        return false;\n                    }\n                    // 169.254.0.0/16 (link-local)\n                    if (bytes[0] == 169 && bytes[1] == 254)\n                    {\n                        return false;\n                    }\n                }\n                else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n                {\n                    // IPv6\n                    if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast)\n                    {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/ResourceController.cs\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class ResourceController : ControllerBase\n    {\n        [HttpPost]\n        [Route(\"extract\")]\n        public IActionResult ExtractFromUrl(string url)\n        {\n            // Extract data from the resource at the given URL\n            // using a library or framework specific to your project\n\n            // Return the extracted data as a JSON object\n            return Ok(new { data = extractedData });\n        }\n    }\n}\n\n// Models/Resource.cs\n\nusing System.Text.Json.Serialization;\n\nnamespace MyApp.Models\n{\n    public class Resource\n    {\n        [JsonPropertyName(\"data\")]\n        public object Data { get; set; }\n    }\n}\n```"}
{"prompt": "Design a C# function which accepts a URL and extracts the data available at that address.", "response": "```csharp\n// Controllers/DataExtractionController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System;\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Net;\nusing System.Threading.Tasks;\nusing DataExtraction.Models;\nusing DataExtraction.Services;\n\nnamespace DataExtraction.Controllers\n{\n    // Set up policy in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => { options.AddPolicy(\"ExtractDataPolicy\", ...); });\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"ExtractDataPolicy\")]\n    public class DataExtractionController : ControllerBase\n    {\n        private readonly IDataFetcherService _dataFetcherService;\n        private readonly ILogger<DataExtractionController> _logger;\n\n        public DataExtractionController(IDataFetcherService dataFetcherService, ILogger<DataExtractionController> logger)\n        {\n            _dataFetcherService = dataFetcherService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"ExtractDataPolicy\")]\n        public async Task<IActionResult> GetData([FromQuery] DataExtractionRequestDto request)\n        {\n            _logger.LogInformation(\"Received data extraction request for URL: {Url}\", request.Url);\n\n            try\n            {\n                var result = await _dataFetcherService.FetchDataAsync(request.Url);\n\n                if (result == null)\n                {\n                    _logger.LogWarning(\"Resource not found or forbidden for URL: {Url}\", request.Url);\n                    return NotFound(new { error = \"Resource not found or forbidden.\" });\n                }\n\n                return Ok(new DataExtractionModel { Data = result });\n            }\n            catch (ArgumentException ex)\n            {\n                _logger.LogWarning(ex, \"Bad request for URL: {Url}\", request.Url);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(ex, \"Failed to fetch data from URL: {Url}\", request.Url);\n                return BadRequest(new { error = \"Failed to fetch data from remote resource.\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during data extraction for URL: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/DataExtractionModel.cs\nusing System.Text.Json.Serialization;\n\nnamespace DataExtraction.Models\n{\n    public class DataExtractionModel\n    {\n        [JsonPropertyName(\"data\")]\n        public byte[] Data { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/DataExtractionRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace DataExtraction.Models\n{\n    public class DataExtractionRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IDataFetcherService.cs\nusing System.Threading.Tasks;\n\nnamespace DataExtraction.Services\n{\n    public interface IDataFetcherService\n    {\n        Task<byte[]?> FetchDataAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/DataFetcherService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing System.Linq;\nusing System.Net.Sockets;\n\nnamespace DataExtraction.Services\n{\n    public class DataFetcherService : IDataFetcherService\n    {\n        private readonly HashSet<string> _trustedDomains;\n        private readonly ILogger<DataFetcherService> _logger;\n        private readonly IHttpClientFactory _httpClientFactory;\n\n        public DataFetcherService(IConfiguration configuration, ILogger<DataFetcherService> logger, IHttpClientFactory httpClientFactory)\n        {\n            _logger = logger;\n            _httpClientFactory = httpClientFactory;\n\n            var trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<List<string>>() ?? new List<string> { \"example.com\" };\n            _trustedDomains = new HashSet<string>(trustedDomains.Select(d => d.ToLowerInvariant()));\n        }\n\n        public async Task<byte[]?> FetchDataAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new ArgumentException(\"Invalid URL format.\");\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new ArgumentException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            string host = uri.Host;\n\n            if (!_trustedDomains.Contains(host.ToLowerInvariant()))\n            {\n                throw new ArgumentException(\"Untrusted domain.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host: {Host}\", host);\n                throw new ArgumentException(\"Failed to resolve host.\");\n            }\n\n            var validIp = addresses.FirstOrDefault(ip => IsPublicIp(ip));\n            if (validIp == null)\n            {\n                throw new ArgumentException(\"No valid public IP found for host.\");\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = validIp.ToString()\n            };\n\n            var httpClient = _httpClientFactory.CreateClient();\n            httpClient.DefaultRequestHeaders.Host = host;\n\n            using var response = await httpClient.GetAsync(builder.Uri);\n            if (!response.IsSuccessStatusCode)\n            {\n                return null;\n            }\n\n            return await response.Content.ReadAsByteArrayAsync();\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return false;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip) || ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing DataExtraction.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IDataFetcherService, DataFetcherService>();\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"ExtractDataPolicy\", policy => policy.RequireAuthenticatedUser());\n});\nbuilder.Services.AddLogging();\n\nbuilder.Configuration.AddJsonFile(\"appsettings.json\", optional: true);\n\nvar app = builder.Build();\n\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\"\n  ]\n}\n```", "orig": "```csharp\n// Controllers/DataExtractionController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing System.Net;\nusing System.IO;\n\nnamespace DataExtraction\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class DataExtractionController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public IActionResult GetData(string url)\n        {\n            // Validate the URL\n            if (!Uri.IsWellFormedUriString(url, UriKind.Absolute))\n                return BadRequest(\"Invalid URL\");\n\n            // Create a WebClient instance\n            var client = new WebClient();\n\n            // Download the data from the URL\n            var data = client.DownloadData(url);\n\n            // Return the data as a JSON response\n            return Ok(data);\n        }\n    }\n}\n\n// Models/DataExtractionModel.cs\nusing System.Text.Json.Serialization;\n\nnamespace DataExtraction\n{\n    public class DataExtractionModel\n    {\n        [JsonPropertyName(\"data\")]\n        public byte[] Data { get; set; }\n    }\n}\n```"}
{"prompt": "Write a C# method to take in a URL provided by the user and extract its data.", "response": "```csharp\n// File: Controllers/UrlDataController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing UrlDataExtractorApi.Models;\nusing UrlDataExtractorApi.Services;\n\nnamespace UrlDataExtractorApi.Controllers\n{\n    // To set up the policy, add in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => options.AddPolicy(\"ExtractUrlDataPolicy\", policy => policy.RequireAuthenticatedUser()));\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"ExtractUrlDataPolicy\")]\n    public class UrlDataController : ControllerBase\n    {\n        private readonly IUrlDataExtractorService _urlDataExtractorService;\n        private readonly ILogger<UrlDataController> _logger;\n\n        public UrlDataController(\n            IUrlDataExtractorService urlDataExtractorService,\n            ILogger<UrlDataController> logger)\n        {\n            _urlDataExtractorService = urlDataExtractorService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"extract\")]\n        [Authorize(Policy = \"ExtractUrlDataPolicy\")]\n        public async Task<IActionResult> ExtractUrlData([FromBody] UrlExtractionRequestDto request)\n        {\n            _logger.LogInformation(\"ExtractUrlData called for URL: {Url}\", request.Url);\n\n            try\n            {\n                var result = await _urlDataExtractorService.ExtractDataAsync(request.Url);\n                _logger.LogInformation(\"Extraction successful for URL: {Url}\", request.Url);\n                return Ok(result);\n            }\n            catch (UrlExtractionException ex)\n            {\n                _logger.LogWarning(\"Extraction failed for URL: {Url}, Reason: {Reason}\", request.Url, ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error in ExtractUrlData for URL: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// File: Models/UrlExtractionRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace UrlDataExtractorApi.Models\n{\n    public class UrlExtractionRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// File: Models/UrlExtractionResponseDto.cs\n\nnamespace UrlDataExtractorApi.Models\n{\n    public class UrlExtractionResponseDto\n    {\n        public string Protocol { get; set; }\n        public string Host { get; set; }\n        public string Path { get; set; }\n        public string QueryString { get; set; }\n        public string Fragment { get; set; }\n    }\n}\n```\n\n```csharp\n// File: Services/IUrlDataExtractorService.cs\n\nusing System.Threading.Tasks;\nusing UrlDataExtractorApi.Models;\n\nnamespace UrlDataExtractorApi.Services\n{\n    public interface IUrlDataExtractorService\n    {\n        Task<UrlExtractionResponseDto> ExtractDataAsync(string url);\n    }\n}\n```\n\n```csharp\n// File: Services/UrlDataExtractorService.cs\n\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing UrlDataExtractorApi.Models;\n\nnamespace UrlDataExtractorApi.Services\n{\n    public class UrlDataExtractorService : IUrlDataExtractorService\n    {\n        private readonly string[] _trustedDomains;\n        private readonly ILogger<UrlDataExtractorService> _logger;\n\n        public UrlDataExtractorService(IConfiguration configuration, ILogger<UrlDataExtractorService> logger)\n        {\n            _trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _logger = logger;\n        }\n\n        public async Task<UrlExtractionResponseDto> ExtractDataAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlExtractionException(\"The provided URL is not valid.\");\n            }\n\n            if (!string.Equals(uri.Scheme, \"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlExtractionException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (uri.HostNameType == UriHostNameType.Dns)\n            {\n                if (!_trustedDomains.Any(d => string.Equals(d, uri.Host, StringComparison.OrdinalIgnoreCase)))\n                {\n                    throw new UrlExtractionException(\"The provided domain is not trusted.\");\n                }\n\n                var hostAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n                if (!hostAddresses.Any())\n                {\n                    throw new UrlExtractionException(\"Unable to resolve host.\");\n                }\n\n                foreach (var ip in hostAddresses)\n                {\n                    if (!IsPublicIp(ip))\n                    {\n                        throw new UrlExtractionException(\"The resolved IP address is not public.\");\n                    }\n                }\n            }\n            else if (uri.HostNameType == UriHostNameType.IPv4 || uri.HostNameType == UriHostNameType.IPv6)\n            {\n                var ip = IPAddress.Parse(uri.Host);\n                if (!IsPublicIp(ip))\n                {\n                    throw new UrlExtractionException(\"The provided IP address is not public.\");\n                }\n            }\n            else\n            {\n                throw new UrlExtractionException(\"Unsupported host name type.\");\n            }\n\n            return new UrlExtractionResponseDto\n            {\n                Protocol = uri.Scheme,\n                Host = uri.Host,\n                Path = uri.AbsolutePath,\n                QueryString = uri.Query.Length > 1 ? uri.Query.Substring(1) : null,\n                Fragment = string.IsNullOrEmpty(uri.Fragment) ? null : uri.Fragment.Substring(1)\n            };\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var octets = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (octets[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (octets[0] == 172 && octets[1] >= 16 && octets[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (octets[0] == 192 && octets[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8 (loopback)\n                if (octets[0] == 127)\n                {\n                    return false;\n                }\n                // APIPA 169.254.0.0/16\n                if (octets[0] == 169 && octets[1] == 254)\n                {\n                    return false;\n                }\n                return true;\n            }\n            if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip))\n                {\n                    return false;\n                }\n                var bytes = ip.GetAddressBytes();\n                // Link-local: fe80::/10\n                if (bytes[0] == 0xfe && (bytes[1] & 0xc0) == 0x80)\n                {\n                    return false;\n                }\n                // Unique local: fc00::/7\n                if ((bytes[0] & 0xfe) == 0xfc)\n                {\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// File: Services/UrlExtractionException.cs\n\nusing System;\n\nnamespace UrlDataExtractorApi.Services\n{\n    public class UrlExtractionException : Exception\n    {\n        public UrlExtractionException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n", "orig": "```csharp\n// File: UrlDataExtractor.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace UrlDataExtractor\n{\n    public class UrlDataExtractor\n    {\n        public static Dictionary<string, string> ExtractData(string url)\n        {\n            var data = new Dictionary<string, string>();\n\n            // Extract the protocol\n            var protocol = Regex.Match(url, @\"^(?<protocol>[^:]+):\");\n            if (protocol.Success)\n            {\n                data.Add(\"Protocol\", protocol.Groups[\"protocol\"].Value);\n            }\n\n            // Extract the host\n            var host = Regex.Match(url, @\"^(?<protocol>[^:]+):\\/\\/(?<host>[^/]+)\");\n            if (host.Success)\n            {\n                data.Add(\"Host\", host.Groups[\"host\"].Value);\n            }\n\n            // Extract the path\n            var path = Regex.Match(url, @\"^(?<protocol>[^:]+):\\/\\/(?<host>[^/]+)(?<path>/[^?]+)\");\n            if (path.Success)\n            {\n                data.Add(\"Path\", path.Groups[\"path\"].Value);\n            }\n\n            // Extract the query string\n            var queryString = Regex.Match(url, @\"^(?<protocol>[^:]+):\\/\\/(?<host>[^/]+)(?<path>/[^?]+)\\?(?<queryString>[^#]+)\");\n            if (queryString.Success)\n            {\n                data.Add(\"QueryString\", queryString.Groups[\"queryString\"].Value);\n            }\n\n            // Extract the fragment\n            var fragment = Regex.Match(url, @\"^(?<protocol>[^:]+):\\/\\/(?<host>[^/]+)(?<path>/[^?]+)\\?(?<queryString>[^#]+)#(?<fragment>[^#]+)\");\n            if (fragment.Success)\n            {\n                data.Add(\"Fragment\", fragment.Groups[\"fragment\"].Value);\n            }\n\n            return data;\n        }\n    }\n}\n\n// File: Program.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing UrlDataExtractor;\n\nnamespace UrlDataExtractor\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var url = \"http://www.example.com/path/to/resource?query=string#fragment\";\n            var data = UrlDataExtractor.ExtractData(url);\n\n            Console.WriteLine(\"Protocol: {0}\", data[\"Protocol\"]);\n            Console.WriteLine(\"Host: {0}\", data[\"Host\"]);\n            Console.WriteLine(\"Path: {0}\", data[\"Path\"]);\n            Console.WriteLine(\"Query String: {0}\", data[\"QueryString\"]);\n            Console.WriteLine(\"Fragment: {0}\", data[\"Fragment\"]);\n        }\n    }\n}\n```"}
{"prompt": "Compose a C# method to accept a URL parameter and download the associated data.", "response": "```csharp\n// Controllers/DataController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing MyApp.Models;\n\nnamespace MyApp.Controllers\n{\n    // To set up the policy, add in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => options.AddPolicy(\"DataFetchPolicy\", policy => policy.RequireAuthenticatedUser()));\n\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"DataFetchPolicy\")]\n    public class DataController : ControllerBase\n    {\n        private readonly IFetchExternalDataService _fetchService;\n        private readonly ILogger<DataController> _logger;\n\n        public DataController(IFetchExternalDataService fetchService, ILogger<DataController> logger)\n        {\n            _fetchService = fetchService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"DataFetchPolicy\")]\n        public async Task<IActionResult> GetData([FromQuery] FetchDataRequestDto request)\n        {\n            _logger.LogInformation(\"GetData called with Url: {Url}\", request.Url);\n\n            if (!ModelState.IsValid)\n            {\n                _logger.LogWarning(\"Model validation failed for {Url}: {Errors}\", request.Url, ModelState);\n                return BadRequest(new { error = \"Invalid input\", details = ModelState });\n            }\n\n            try\n            {\n                var result = await _fetchService.FetchExternalDataAsync(request.Url);\n\n                if (!result.Success)\n                {\n                    _logger.LogWarning(\"Failed to fetch data for {Url}: {Reason}\", request.Url, result.ErrorMessage);\n                    return BadRequest(new { error = \"Could not fetch data\", details = result.ErrorMessage });\n                }\n\n                _logger.LogInformation(\"Data successfully fetched for {Url}\", request.Url);\n                return File(result.Data, result.ContentType ?? \"application/octet-stream\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error occurred while fetching data for {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/FetchDataRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class FetchDataRequestDto\n    {\n        [Required]\n        [Url]\n        [StringLength(2048, MinimumLength = 10)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/FetchExternalDataResult.cs\nnamespace MyApp.Models\n{\n    public class FetchExternalDataResult\n    {\n        public bool Success { get; set; }\n        public byte[] Data { get; set; }\n        public string ContentType { get; set; }\n        public string ErrorMessage { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IFetchExternalDataService.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IFetchExternalDataService\n    {\n        Task<FetchExternalDataResult> FetchExternalDataAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/FetchExternalDataService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class FetchExternalDataService : IFetchExternalDataService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<FetchExternalDataService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n        private readonly IConfiguration _configuration;\n\n        public FetchExternalDataService(\n            IHttpClientFactory httpClientFactory,\n            ILogger<FetchExternalDataService> logger,\n            IConfiguration configuration)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _configuration = configuration;\n\n            _trustedDomains = _configuration\n                .GetSection(\"TrustedExternalDomains\")\n                .Get<string[]>()?\n                .Select(d => d.ToLowerInvariant())\n                .ToHashSet() ?? new HashSet<string>();\n        }\n\n        public async Task<FetchExternalDataResult> FetchExternalDataAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return new FetchExternalDataResult\n                {\n                    Success = false,\n                    ErrorMessage = \"Invalid URL format.\"\n                };\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return new FetchExternalDataResult\n                {\n                    Success = false,\n                    ErrorMessage = \"Only HTTPS scheme is allowed.\"\n                };\n            }\n\n            if (uri.HostNameType == UriHostNameType.Dns)\n            {\n                if (!_trustedDomains.Contains(uri.Host.ToLowerInvariant()))\n                {\n                    return new FetchExternalDataResult\n                    {\n                        Success = false,\n                        ErrorMessage = \"Domain is not trusted.\"\n                    };\n                }\n\n                IPAddress[] addresses;\n                try\n                {\n                    addresses = await Dns.GetHostAddressesAsync(uri.Host);\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogWarning(ex, \"DNS resolution failed for {Host}\", uri.Host);\n                    return new FetchExternalDataResult\n                    {\n                        Success = false,\n                        ErrorMessage = \"DNS resolution failed.\"\n                    };\n                }\n\n                foreach (var ip in addresses)\n                {\n                    if (IsPrivateOrLoopback(ip))\n                    {\n                        return new FetchExternalDataResult\n                        {\n                            Success = false,\n                            ErrorMessage = \"Resolved IP is not allowed.\"\n                        };\n                    }\n                }\n\n                // Use the first valid IP to prevent DNS rebinding\n                var selectedIp = addresses.FirstOrDefault(ip => !IsPrivateOrLoopback(ip));\n                if (selectedIp == null)\n                {\n                    return new FetchExternalDataResult\n                    {\n                        Success = false,\n                        ErrorMessage = \"No valid public IP address found.\"\n                    };\n                }\n\n                var builder = new UriBuilder(uri)\n                {\n                    Host = selectedIp.ToString()\n                };\n                var finalUrl = builder.Uri.ToString();\n\n                var httpClient = _httpClientFactory.CreateClient();\n                httpClient.DefaultRequestHeaders.Host = uri.Host;\n\n                try\n                {\n                    var response = await httpClient.GetAsync(finalUrl);\n                    if (!response.IsSuccessStatusCode)\n                    {\n                        return new FetchExternalDataResult\n                        {\n                            Success = false,\n                            ErrorMessage = $\"HTTP error: {response.StatusCode}\"\n                        };\n                    }\n\n                    var data = await response.Content.ReadAsByteArrayAsync();\n                    var contentType = GetContentType(uri);\n\n                    return new FetchExternalDataResult\n                    {\n                        Success = true,\n                        Data = data,\n                        ContentType = contentType\n                    };\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogWarning(ex, \"Failed to fetch data from {FinalUrl}\", finalUrl);\n                    return new FetchExternalDataResult\n                    {\n                        Success = false,\n                        ErrorMessage = \"Failed to fetch data.\"\n                    };\n                }\n            }\n            else if (uri.HostNameType == UriHostNameType.IPv4 || uri.HostNameType == UriHostNameType.IPv6)\n            {\n                if (IsPrivateOrLoopback(IPAddress.Parse(uri.Host)))\n                {\n                    return new FetchExternalDataResult\n                    {\n                        Success = false,\n                        ErrorMessage = \"IP address is not allowed.\"\n                    };\n                }\n\n                var httpClient = _httpClientFactory.CreateClient();\n                try\n                {\n                    var response = await httpClient.GetAsync(uri);\n                    if (!response.IsSuccessStatusCode)\n                    {\n                        return new FetchExternalDataResult\n                        {\n                            Success = false,\n                            ErrorMessage = $\"HTTP error: {response.StatusCode}\"\n                        };\n                    }\n\n                    var data = await response.Content.ReadAsByteArrayAsync();\n                    var contentType = GetContentType(uri);\n\n                    return new FetchExternalDataResult\n                    {\n                        Success = true,\n                        Data = data,\n                        ContentType = contentType\n                    };\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogWarning(ex, \"Failed to fetch data from {Uri}\", uri);\n                    return new FetchExternalDataResult\n                    {\n                        Success = false,\n                        ErrorMessage = \"Failed to fetch data.\"\n                    };\n                }\n            }\n            else\n            {\n                return new FetchExternalDataResult\n                {\n                    Success = false,\n                    ErrorMessage = \"Unsupported host type.\"\n                };\n            }\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast)\n                {\n                    return true;\n                }\n                // IPv6 loopback ::1\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private static string GetContentType(Uri uri)\n        {\n            var extension = Path.GetExtension(uri.AbsolutePath);\n            switch (extension.ToLowerInvariant())\n            {\n                case \".txt\":\n                    return \"text/plain\";\n                case \".pdf\":\n                    return \"application/pdf\";\n                case \".docx\":\n                    return \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\";\n                case \".xlsx\":\n                    return \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n                case \".pptx\":\n                    return \"application/vnd.openxmlformats-officedocument.presentationml.presentation\";\n                default:\n                    return \"application/octet-stream\";\n            }\n        }\n    }\n}\n```\n", "orig": "```csharp\n[Controllers/DataController.cs]\nusing System.IO;\nusing System.Net;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class DataController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public IActionResult GetData(string url)\n        {\n            // Validate the URL\n            if (!Uri.TryCreate(url, UriKind.Absolute, out Uri uri))\n                return BadRequest();\n\n            // Download the data\n            using (WebClient client = new WebClient())\n            {\n                byte[] data = client.DownloadData(uri);\n                return File(data, GetContentType(uri));\n            }\n        }\n\n        private string GetContentType(Uri uri)\n        {\n            string extension = Path.GetExtension(uri.ToString());\n            switch (extension)\n            {\n                case \".txt\":\n                    return \"text/plain\";\n                case \".pdf\":\n                    return \"application/pdf\";\n                case \".docx\":\n                    return \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\";\n                case \".xlsx\":\n                    return \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n                case \".pptx\":\n                    return \"application/vnd.openxmlformats-officedocument.presentationml.presentation\";\n                default:\n                    return \"application/octet-stream\";\n            }\n        }\n    }\n}\n```"}
{"prompt": "Design a C# function that takes a URL parameter from the user and extracts the data.", "response": "```csharp\n// Controllers/ExtractDataController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\n// SETUP: Register an authorization policy named \"ExtractDataPolicy\" in Program.cs or Startup.cs\n\nnamespace ExampleApi.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"ExtractDataPolicy\")]\n    public class ExtractDataController : ControllerBase\n    {\n        private readonly IExtractDataService _extractDataService;\n        private readonly ILogger<ExtractDataController> _logger;\n\n        public ExtractDataController(\n            IExtractDataService extractDataService,\n            ILogger<ExtractDataController> logger)\n        {\n            _extractDataService = extractDataService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Route(\"extract\")]\n        [Authorize(Policy = \"ExtractDataPolicy\")]\n        public async Task<IActionResult> ExtractData([FromQuery] ExtractDataRequestDto request)\n        {\n            _logger.LogInformation(\"ExtractData called with url: {Url}\", request.Url);\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var result = await _extractDataService.ExtractDataFromUrlAsync(request.Url);\n                if (result.IsSuccess)\n                {\n                    _logger.LogInformation(\"Data extraction succeeded for url: {Url}\", request.Url);\n                    return Ok(new ExtractDataResponseDto { Data = result.Data });\n                }\n                else\n                {\n                    _logger.LogWarning(\"Data extraction failed for url: {Url} - {Reason}\", request.Url, result.ErrorMessage);\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unhandled exception in ExtractData for url: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/ExtractDataRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace ExampleApi.Dtos\n{\n    public class ExtractDataRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Dtos/ExtractDataResponseDto.cs\nnamespace ExampleApi.Dtos\n{\n    public class ExtractDataResponseDto\n    {\n        public string Data { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IExtractDataService.cs\nusing System.Threading.Tasks;\n\nnamespace ExampleApi.Services\n{\n    public interface IExtractDataService\n    {\n        Task<ExtractDataResult> ExtractDataFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/ExtractDataService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace ExampleApi.Services\n{\n    public class ExtractDataService : IExtractDataService\n    {\n        private readonly HashSet<string> _trustedDomains;\n        private readonly ILogger<ExtractDataService> _logger;\n\n        public ExtractDataService(IConfiguration configuration, ILogger<ExtractDataService> logger)\n        {\n            _logger = logger;\n            _trustedDomains = configuration\n                .GetSection(\"TrustedDomains\")\n                .Get<string[]>()?\n                .Select(d => d.Trim().ToLowerInvariant())\n                .ToHashSet() ?? new HashSet<string>();\n        }\n\n        public async Task<ExtractDataResult> ExtractDataFromUrlAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return ExtractDataResult.Failure(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return ExtractDataResult.Failure(\"Malformed URL.\");\n            }\n\n            if (!string.Equals(uri.Scheme, \"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                return ExtractDataResult.Failure(\"Only HTTPS URLs are allowed.\");\n            }\n\n            string host = uri.Host.ToLowerInvariant();\n            if (!_trustedDomains.Contains(host))\n            {\n                return ExtractDataResult.Failure(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host: {Host}\", host);\n                return ExtractDataResult.Failure(\"Failed to resolve host.\");\n            }\n\n            if (addresses.Length == 0)\n            {\n                return ExtractDataResult.Failure(\"No IP addresses found for host.\");\n            }\n\n            foreach (var ip in addresses)\n            {\n                if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                {\n                    return ExtractDataResult.Failure(\"IP address is private or not allowed.\");\n                }\n            }\n\n            var ipToUse = addresses.First();\n\n            string data;\n            try\n            {\n                data = await FetchUrlUsingIpAsync(uri, ipToUse);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Failed to fetch data from URL: {Url} using IP: {Ip}\", url, ipToUse);\n                return ExtractDataResult.Failure(\"Failed to fetch data from URL.\");\n            }\n\n            string pattern = @\"https?:\\/\\/[^\\/]+\";\n            var match = Regex.Match(url, pattern, RegexOptions.IgnoreCase);\n            if (match.Success)\n            {\n                return ExtractDataResult.Success(match.Value);\n            }\n            else\n            {\n                return ExtractDataResult.Failure(\"Pattern not found in URL.\");\n            }\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            switch (ip.AddressFamily)\n            {\n                case AddressFamily.InterNetwork:\n                    byte[] bytes = ip.GetAddressBytes();\n                    // 10.0.0.0/8\n                    if (bytes[0] == 10)\n                    {\n                        return true;\n                    }\n                    // 172.16.0.0/12\n                    if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                    {\n                        return true;\n                    }\n                    // 192.168.0.0/16\n                    if (bytes[0] == 192 && bytes[1] == 168)\n                    {\n                        return true;\n                    }\n                    // 169.254.0.0/16 (link-local)\n                    if (bytes[0] == 169 && bytes[1] == 254)\n                    {\n                        return true;\n                    }\n                    break;\n                case AddressFamily.InterNetworkV6:\n                    if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal)\n                    {\n                        return true;\n                    }\n                    break;\n            }\n            return false;\n        }\n\n        private async Task<string> FetchUrlUsingIpAsync(Uri originalUri, IPAddress ip)\n        {\n            var handler = new HttpClientHandler\n            {\n                ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator\n            };\n\n            using (var httpClient = new HttpClient(handler))\n            {\n                var builder = new UriBuilder(originalUri)\n                {\n                    Host = ip.ToString()\n                };\n\n                var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n                request.Headers.Host = originalUri.Host;\n\n                using (var response = await httpClient.SendAsync(request))\n                {\n                    response.EnsureSuccessStatusCode();\n                    return await response.Content.ReadAsStringAsync();\n                }\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/ExtractDataResult.cs\nnamespace ExampleApi.Services\n{\n    public class ExtractDataResult\n    {\n        public bool IsSuccess { get; }\n        public string Data { get; }\n        public string ErrorMessage { get; }\n\n        private ExtractDataResult(bool isSuccess, string data, string errorMessage)\n        {\n            IsSuccess = isSuccess;\n            Data = data;\n            ErrorMessage = errorMessage;\n        }\n\n        public static ExtractDataResult Success(string data)\n        {\n            return new ExtractDataResult(true, data, null);\n        }\n\n        public static ExtractDataResult Failure(string error)\n        {\n            return new ExtractDataResult(false, null, error);\n        }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [ \"example.com\", \"api.example.com\" ]\n}\n```", "orig": "```csharp\n[HttpGet]\n[Route(\"api/[controller]/[action]\")]\npublic IActionResult ExtractData(string url)\n{\n    // Validate the URL\n    if (string.IsNullOrEmpty(url))\n    {\n        return BadRequest(\"Invalid URL\");\n    }\n\n    // Extract the data from the URL\n    string data = ExtractDataFromUrl(url);\n\n    // Return the data\n    return Ok(data);\n}\n\nprivate string ExtractDataFromUrl(string url)\n{\n    // Extract the data from the URL using a regular expression\n    string pattern = @\"https?:\\/\\/[^\\/]+\";\n    Match match = Regex.Match(url, pattern);\n    if (match.Success)\n    {\n        return match.Value;\n    }\n    else\n    {\n        return null;\n    }\n}\n```"}
{"prompt": "Compose a C# function to accept a URL input and download the resource content.", "response": "```csharp\n// Controllers/ResourceDownloadController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Controllers\n{\n    // To use this, set up a policy in your Program.cs or Startup.cs like:\n    // options.AddPolicy(\"DownloadResourcePolicy\", policy => policy.RequireAuthenticatedUser());\n\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"DownloadResourcePolicy\")]\n    public class ResourceDownloadController : ControllerBase\n    {\n        private readonly IResourceDownloader _resourceDownloader;\n        private readonly ILogger<ResourceDownloadController> _logger;\n\n        public ResourceDownloadController(\n            IResourceDownloader resourceDownloader,\n            ILogger<ResourceDownloadController> logger)\n        {\n            _resourceDownloader = resourceDownloader;\n            _logger = logger;\n        }\n\n        [HttpPost(\"download\")]\n        [Authorize(Policy = \"DownloadResourcePolicy\")]\n        public async Task<IActionResult> DownloadResource([FromBody] DownloadResourceRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid request data.\" });\n            }\n\n            try\n            {\n                var content = await _resourceDownloader.DownloadResourceContentAsync(request.Url);\n\n                return File(\n                    content,\n                    \"text/plain\",\n                    \"output.txt\"\n                );\n            }\n            catch (ResourceDownloadException ex)\n            {\n                _logger.LogWarning(\"Resource download failed: {Message} Url: {Url}\", ex.Message, request.Url);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during resource download. Url: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/DownloadResourceRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class DownloadResourceRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IResourceDownloader.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IResourceDownloader\n    {\n        Task<byte[]> DownloadResourceContentAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/ResourceDownloader.cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Services\n{\n    public class ResourceDownloader : IResourceDownloader\n    {\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<ResourceDownloader> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public ResourceDownloader(IConfiguration configuration, ILogger<ResourceDownloader> logger)\n        {\n            _configuration = configuration;\n            _logger = logger;\n            _trustedDomains = LoadTrustedDomains();\n        }\n\n        public async Task<byte[]> DownloadResourceContentAsync(string url)\n        {\n            var uri = ValidateUrl(url);\n            var host = uri.Host;\n\n            if (!_trustedDomains.Contains(host, StringComparer.OrdinalIgnoreCase))\n            {\n                throw new ResourceDownloadException(\"Domain is not trusted.\");\n            }\n\n            var ipAddresses = await Dns.GetHostAddressesAsync(host);\n\n            if (!ipAddresses.Any())\n            {\n                throw new ResourceDownloadException(\"Unable to resolve host.\");\n            }\n\n            var publicIp = ipAddresses.FirstOrDefault(ip => IsPublicIp(ip));\n            if (publicIp == null)\n            {\n                throw new ResourceDownloadException(\"Host does not resolve to a public IP address.\");\n            }\n\n            var resourceContent = await DownloadUsingIp(uri, publicIp);\n            return resourceContent;\n        }\n\n        private Uri ValidateUrl(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new ResourceDownloadException(\"Malformed URL.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new ResourceDownloadException(\"Only HTTPS scheme is allowed.\");\n            }\n\n            return uri;\n        }\n\n        private HashSet<string> LoadTrustedDomains()\n        {\n            var trustedDomains = _configuration\n                .GetSection(\"TrustedDomains\")\n                .Get<string[]>() ?? Array.Empty<string>();\n\n            return new HashSet<string>(trustedDomains, StringComparer.OrdinalIgnoreCase);\n        }\n\n        private bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip))\n                {\n                    return false;\n                }\n\n                var octets = ip.GetAddressBytes();\n\n                // IPv4 private ranges\n                if (ip.AddressFamily == AddressFamily.InterNetwork)\n                {\n                    // 10.0.0.0/8\n                    if (octets[0] == 10)\n                    {\n                        return false;\n                    }\n                    // 172.16.0.0/12\n                    if (octets[0] == 172 && octets[1] >= 16 && octets[1] <= 31)\n                    {\n                        return false;\n                    }\n                    // 192.168.0.0/16\n                    if (octets[0] == 192 && octets[1] == 168)\n                    {\n                        return false;\n                    }\n                    // 169.254.0.0/16 (link-local)\n                    if (octets[0] == 169 && octets[1] == 254)\n                    {\n                        return false;\n                    }\n                }\n                // IPv6 private and link-local\n                if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n                {\n                    if (octets[0] == 0xfe && (octets[1] & 0xc0) == 0x80)\n                    {\n                        return false; // link-local\n                    }\n                    if ((octets[0] & 0xfe) == 0xfc)\n                    {\n                        return false; // unique local address\n                    }\n                }\n\n                return true;\n            }\n            return false;\n        }\n\n        private async Task<byte[]> DownloadUsingIp(Uri uri, IPAddress ip)\n        {\n            var handler = new SocketsHttpHandler\n            {\n                ConnectCallback = async (context, token) =>\n                {\n                    var socket = new Socket(ip.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                    try\n                    {\n                        await socket.ConnectAsync(ip, uri.Port, token);\n                        return new NetworkStream(socket, ownsSocket: true);\n                    }\n                    catch\n                    {\n                        socket.Dispose();\n                        throw;\n                    }\n                }\n            };\n\n            using var client = new HttpClient(handler, disposeHandler: true);\n            client.DefaultRequestHeaders.Host = uri.Host;\n            client.Timeout = TimeSpan.FromSeconds(15);\n\n            var response = await client.GetAsync(uri, HttpCompletionOption.ResponseContentRead);\n            response.EnsureSuccessStatusCode();\n            var content = await response.Content.ReadAsByteArrayAsync();\n            return content;\n        }\n    }\n}\n```\n\n```csharp\n// Exceptions/ResourceDownloadException.cs\nusing System;\n\nnamespace MyApp\n{\n    public class ResourceDownloadException : Exception\n    {\n        public ResourceDownloadException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n", "orig": "```csharp\nusing System;\nusing System.Net;\nusing System.IO;\n\npublic class DownloadResource\n{\n    public static void Download(string url)\n    {\n        // Create a new WebClient instance\n        using (var client = new WebClient())\n        {\n            // Download the resource content\n            var content = client.DownloadString(url);\n\n            // Write the content to a file\n            using (var writer = new StreamWriter(\"output.txt\"))\n            {\n                writer.Write(content);\n            }\n        }\n    }\n}\n```"}
{"prompt": "Develop a C# function which accepts a user-input URL and retrieves the associated data.", "response": "```csharp\n// Controllers/UrlController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApi.Models;\nusing MyApi.Services;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Controllers\n{\n    // Policy setup: In Program.cs or Startup.cs, define \"UrlAccessPolicy\" with required requirements.\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"UrlAccessPolicy\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlRepository _urlRepository;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IUrlRepository urlRepository, ILogger<UrlController> logger)\n        {\n            _urlRepository = urlRepository;\n            _logger = logger;\n        }\n\n        // GET api/url\n        [HttpGet]\n        [Authorize(Policy = \"UrlAccessPolicy\")]\n        public async Task<ActionResult<IEnumerable<UrlResponseDto>>> GetUrls()\n        {\n            try\n            {\n                _logger.LogInformation(\"Fetching all URLs\");\n                var urls = await _urlRepository.GetAllUrlsAsync();\n                return Ok(urls);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to fetch URLs\");\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n\n        // GET api/url/{id}\n        [HttpGet(\"{id}\")]\n        [Authorize(Policy = \"UrlAccessPolicy\")]\n        public async Task<ActionResult<UrlResponseDto>> GetUrl(string id)\n        {\n            try\n            {\n                _logger.LogInformation(\"Fetching URL by id: {Id}\", id);\n                var url = await _urlRepository.GetUrlByIdAsync(id);\n                if (url == null)\n                {\n                    return NotFound(new { error = \"Resource not found\" });\n                }\n                return Ok(url);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to fetch URL by id: {Id}\", id);\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n\n        // POST api/url\n        [HttpPost]\n        [Authorize(Policy = \"UrlAccessPolicy\")]\n        public async Task<ActionResult<UrlResponseDto>> PostUrl([FromBody] UrlCreateDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid input\", details = ModelState });\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Creating new URL\");\n                var created = await _urlRepository.CreateUrlAsync(request);\n                return Ok(created);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to create URL\");\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n\n        // PUT api/url/{id}\n        [HttpPut(\"{id}\")]\n        [Authorize(Policy = \"UrlAccessPolicy\")]\n        public async Task<ActionResult<UrlResponseDto>> PutUrl(string id, [FromBody] UrlUpdateDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid input\", details = ModelState });\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Updating URL with id: {Id}\", id);\n                var updated = await _urlRepository.UpdateUrlAsync(id, request);\n                if (updated == null)\n                {\n                    return NotFound(new { error = \"Resource not found\" });\n                }\n                return Ok(updated);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to update URL with id: {Id}\", id);\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n\n        // DELETE api/url/{id}\n        [HttpDelete(\"{id}\")]\n        [Authorize(Policy = \"UrlAccessPolicy\")]\n        public async Task<ActionResult> DeleteUrl(string id)\n        {\n            try\n            {\n                _logger.LogInformation(\"Deleting URL with id: {Id}\", id);\n                var deleted = await _urlRepository.DeleteUrlAsync(id);\n                if (!deleted)\n                {\n                    return NotFound(new { error = \"Resource not found\" });\n                }\n                return Ok();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to delete URL with id: {Id}\", id);\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n\n        // GET api/url/fetch-raw?url={url}\n        [HttpGet(\"fetch-raw\")]\n        [Authorize(Policy = \"UrlAccessPolicy\")]\n        public async Task<IActionResult> FetchRawUrl([FromQuery] string url)\n        {\n            try\n            {\n                _logger.LogInformation(\"Fetching raw data from URL: {Url}\", url);\n\n                var trustedDomains = _urlRepository.GetTrustedDomains();\n                var fetcher = new UrlRawFetcher(trustedDomains, _logger);\n\n                var result = await fetcher.FetchRawBytesFromUserUrlAsync(url);\n                if (result == null)\n                {\n                    return BadRequest(new { error = \"Invalid or untrusted URL\" });\n                }\n\n                return File(result, \"application/octet-stream\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to fetch raw bytes from user-supplied URL\");\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/Url.cs\n\nnamespace MyApi.Models\n{\n    public class Url\n    {\n        public string Id { get; set; }\n        public string UrlValue { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlCreateDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApi.Models\n{\n    public class UrlCreateDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string UrlValue { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlUpdateDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApi.Models\n{\n    public class UrlUpdateDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string UrlValue { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlResponseDto.cs\n\nnamespace MyApi.Models\n{\n    public class UrlResponseDto\n    {\n        public string Id { get; set; }\n        public string UrlValue { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlRepository.cs\n\nusing MyApi.Models;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public interface IUrlRepository\n    {\n        Task<IReadOnlyList<UrlResponseDto>> GetAllUrlsAsync();\n        Task<UrlResponseDto> GetUrlByIdAsync(string id);\n        Task<UrlResponseDto> CreateUrlAsync(UrlCreateDto dto);\n        Task<UrlResponseDto> UpdateUrlAsync(string id, UrlUpdateDto dto);\n        Task<bool> DeleteUrlAsync(string id);\n\n        IReadOnlyList<string> GetTrustedDomains();\n    }\n}\n```\n\n```csharp\n// Services/UrlRepository.cs\n\nusing Microsoft.Extensions.Configuration;\nusing MyApi.Models;\nusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public class UrlRepository : IUrlRepository\n    {\n        private readonly ConcurrentDictionary<string, Url> _urls = new();\n        private readonly IReadOnlyList<string> _trustedDomains;\n\n        public UrlRepository(IConfiguration configuration)\n        {\n            _trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<List<string>>() ?? new List<string> { \"example.com\" };\n        }\n\n        public Task<IReadOnlyList<UrlResponseDto>> GetAllUrlsAsync()\n        {\n            var result = _urls.Values.Select(u => new UrlResponseDto { Id = u.Id, UrlValue = u.UrlValue }).ToList();\n            return Task.FromResult((IReadOnlyList<UrlResponseDto>)result);\n        }\n\n        public Task<UrlResponseDto> GetUrlByIdAsync(string id)\n        {\n            if (_urls.TryGetValue(id, out var url))\n            {\n                return Task.FromResult(new UrlResponseDto { Id = url.Id, UrlValue = url.UrlValue });\n            }\n            return Task.FromResult<UrlResponseDto>(null);\n        }\n\n        public Task<UrlResponseDto> CreateUrlAsync(UrlCreateDto dto)\n        {\n            var id = Guid.NewGuid().ToString(\"N\");\n            var url = new Url { Id = id, UrlValue = dto.UrlValue };\n            _urls[id] = url;\n            return Task.FromResult(new UrlResponseDto { Id = url.Id, UrlValue = url.UrlValue });\n        }\n\n        public Task<UrlResponseDto> UpdateUrlAsync(string id, UrlUpdateDto dto)\n        {\n            if (_urls.TryGetValue(id, out var url))\n            {\n                url.UrlValue = dto.UrlValue;\n                return Task.FromResult(new UrlResponseDto { Id = url.Id, UrlValue = url.UrlValue });\n            }\n            return Task.FromResult<UrlResponseDto>(null);\n        }\n\n        public Task<bool> DeleteUrlAsync(string id)\n        {\n            return Task.FromResult(_urls.TryRemove(id, out _));\n        }\n\n        public IReadOnlyList<string> GetTrustedDomains()\n        {\n            return _trustedDomains;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlRawFetcher.cs\n\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public class UrlRawFetcher\n    {\n        private readonly IReadOnlyList<string> _trustedDomains;\n        private readonly ILogger _logger;\n\n        public UrlRawFetcher(IReadOnlyList<string> trustedDomains, ILogger logger)\n        {\n            _trustedDomains = trustedDomains;\n            _logger = logger;\n        }\n\n        public async Task<byte[]> FetchRawBytesFromUserUrlAsync(string userInputUrl)\n        {\n            if (!Uri.TryCreate(userInputUrl, UriKind.Absolute, out var uri))\n            {\n                _logger.LogWarning(\"User input is not a valid URI: {Url}\", userInputUrl);\n                return null;\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                _logger.LogWarning(\"URL does not use HTTPS: {Url}\", userInputUrl);\n                return null;\n            }\n\n            string host = uri.Host;\n            if (!_trustedDomains.Any(domain => string.Equals(domain, host, StringComparison.OrdinalIgnoreCase)))\n            {\n                _logger.LogWarning(\"Host {Host} is not in trusted domains list\", host);\n                return null;\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host: {Host}\", host);\n                return null;\n            }\n\n            var validAddress = addresses.FirstOrDefault(ip =>\n                !IPAddress.IsLoopback(ip) &&\n                !IsPrivate(ip) &&\n                !ip.IsIPv6LinkLocal);\n\n            if (validAddress == null)\n            {\n                _logger.LogWarning(\"No valid public IP address found for host: {Host}\", host);\n                return null;\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = validAddress.ToString()\n            };\n\n            using var handler = new HttpClientHandler\n            {\n                ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => true\n            };\n\n            using var client = new HttpClient(handler);\n            client.DefaultRequestHeaders.Host = host;\n\n            try\n            {\n                var response = await client.GetAsync(builder.Uri);\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to fetch resource. Status: {StatusCode}\", response.StatusCode);\n                    return null;\n                }\n\n                return await response.Content.ReadAsByteArrayAsync();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Exception during HTTP fetch for {Url}\", userInputUrl);\n                return null;\n            }\n        }\n\n        private static bool IsPrivate(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                switch (bytes[0])\n                {\n                    case 10:\n                    case 127:\n                        return true;\n                    case 172:\n                        return bytes[1] >= 16 && bytes[1] <= 31;\n                    case 192:\n                        return bytes[1] == 168;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```", "orig": "```csharp\n// Controllers/UrlController.cs\n\nusing Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace MyApi.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        // GET api/url\n        [HttpGet]\n        public async Task<ActionResult<IEnumerable<Url>>> GetUrls()\n        {\n            // TODO: Implement logic to retrieve URLs from a database or other data source\n            return Ok(new List<Url>());\n        }\n\n        // GET api/url/{id}\n        [HttpGet(\"{id}\")]\n        public async Task<ActionResult<Url>> GetUrl(string id)\n        {\n            // TODO: Implement logic to retrieve a specific URL from a database or other data source\n            return Ok(new Url());\n        }\n\n        // POST api/url\n        [HttpPost]\n        public async Task<ActionResult<Url>> PostUrl(Url url)\n        {\n            // TODO: Implement logic to add a new URL to a database or other data source\n            return Ok(url);\n        }\n\n        // PUT api/url/{id}\n        [HttpPut(\"{id}\")]\n        public async Task<ActionResult<Url>> PutUrl(string id, Url url)\n        {\n            // TODO: Implement logic to update a specific URL in a database or other data source\n            return Ok(url);\n        }\n\n        // DELETE api/url/{id}\n        [HttpDelete(\"{id}\")]\n        public async Task<ActionResult<Url>> DeleteUrl(string id)\n        {\n            // TODO: Implement logic to delete a specific URL from a database or other data source\n            return Ok();\n        }\n    }\n\n    // Models/Url.cs\n\n    using System;\n\n    namespace MyApi.Models\n    {\n        public class Url\n        {\n            public string Id { get; set; }\n            public string Url { get; set; }\n        }\n    }\n```"}
{"prompt": "Develop a C# function which receives a user-provided URL and downloads the associated content.", "response": "```csharp\n// Controllers/DownloadController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApi.Controllers\n{\n    // Policy setup: In Program.cs or Startup.cs, add a policy named \"DownloadContentPolicy\"\n    [Authorize(Policy = \"DownloadContentPolicy\")]\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly ILogger<DownloadController> _logger;\n        private readonly IDownloadContentService _downloadContentService;\n\n        public DownloadController(\n            ILogger<DownloadController> logger,\n            IDownloadContentService downloadContentService)\n        {\n            _logger = logger;\n            _downloadContentService = downloadContentService;\n        }\n\n        [Authorize(Policy = \"DownloadContentPolicy\")]\n        [HttpPost(\"download\")]\n        public async Task<IActionResult> DownloadFileAsync([FromBody] DownloadRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid input\", details = ModelState });\n            }\n\n            try\n            {\n                var result = await _downloadContentService.DownloadContentToFileAsync(request.Url);\n                if (!result.Success)\n                {\n                    _logger.LogWarning(\"Download failed for URL: {Url}, Reason: {Reason}\", request.Url, result.ErrorMessage);\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n\n                _logger.LogInformation(\"Successfully downloaded file from {Url} to {Path}\", request.Url, result.FilePath);\n                return Ok(new { path = result.FilePath });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error downloading content from {Url}\", request.Url);\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/DownloadRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApi.Dtos\n{\n    public class DownloadRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IDownloadContentService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApi.Services\n{\n    public interface IDownloadContentService\n    {\n        Task<DownloadContentResult> DownloadContentToFileAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/DownloadContentService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApi.Services\n{\n    public class DownloadContentService : IDownloadContentService\n    {\n        private readonly ILogger<DownloadContentService> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly HashSet<string> _trustedDomains;\n\n        public DownloadContentService(\n            ILogger<DownloadContentService> logger,\n            IConfiguration configuration,\n            IHttpClientFactory httpClientFactory)\n        {\n            _logger = logger;\n            _configuration = configuration;\n            _httpClientFactory = httpClientFactory;\n            _trustedDomains = new HashSet<string>(\n                _configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>(),\n                StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<DownloadContentResult> DownloadContentToFileAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return DownloadContentResult.Failure(\"URL is not well-formed.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return DownloadContentResult.Failure(\"URL must use HTTPS scheme.\");\n            }\n\n            string host = uri.Host;\n            if (!_trustedDomains.Contains(host))\n            {\n                return DownloadContentResult.Failure(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                return DownloadContentResult.Failure(\"Failed to resolve domain.\");\n            }\n\n            IPAddress selectedAddress = null;\n            foreach (var addr in addresses)\n            {\n                if (!IsPrivateOrLoopbackOrLinkLocal(addr))\n                {\n                    selectedAddress = addr;\n                    break;\n                }\n            }\n\n            if (selectedAddress == null)\n            {\n                return DownloadContentResult.Failure(\"No valid public IP address found for host.\");\n            }\n\n            var httpClient = _httpClientFactory.CreateClient();\n            httpClient.BaseAddress = new Uri($\"{uri.Scheme}://{host}\");\n\n            var requestUri = uri.PathAndQuery;\n            HttpResponseMessage response;\n            try\n            {\n                response = await httpClient.GetAsync(requestUri);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"HTTP GET failed for {Url}\", url);\n                return DownloadContentResult.Failure(\"Failed to fetch resource.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                return DownloadContentResult.Failure(\"Failed to fetch resource.\");\n            }\n\n            var content = await response.Content.ReadAsByteArrayAsync();\n            string fileName = Path.GetFileName(uri.LocalPath);\n            if (string.IsNullOrWhiteSpace(fileName))\n            {\n                fileName = Guid.NewGuid().ToString(\"N\");\n            }\n\n            string storagePath = _configuration.GetValue<string>(\"DownloadStoragePath\", Path.GetTempPath());\n            Directory.CreateDirectory(storagePath);\n\n            string filePath = Path.Combine(storagePath, fileName);\n\n            await File.WriteAllBytesAsync(filePath, content);\n\n            return DownloadContentResult.Success(filePath);\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                byte[] bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && (bytes[1] >= 16 && bytes[1] <= 31))\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast)\n                {\n                    return true;\n                }\n                if (address.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/DownloadContentResult.cs\nnamespace MyApi.Services\n{\n    public class DownloadContentResult\n    {\n        public bool Success { get; }\n        public string FilePath { get; }\n        public string ErrorMessage { get; }\n\n        private DownloadContentResult(bool success, string filePath, string errorMessage)\n        {\n            Success = success;\n            FilePath = filePath;\n            ErrorMessage = errorMessage;\n        }\n\n        public static DownloadContentResult Success(string filePath)\n        {\n            return new DownloadContentResult(true, filePath, null);\n        }\n\n        public static DownloadContentResult Failure(string errorMessage)\n        {\n            return new DownloadContentResult(false, null, errorMessage);\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApi.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<IDownloadContentService, DownloadContentService>();\n\n// Policy setup example:\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadContentPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        // Add additional requirements as needed\n    });\n});\n\nbuilder.Configuration.AddJsonFile(\"appsettings.json\", optional: true);\n\nvar app = builder.Build();\n\napp.UseSwagger();\napp.UseSwaggerUI();\n\napp.UseHttpsRedirection();\napp.UseAuthentication();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"another-trusted-domain.com\"\n  ],\n  \"DownloadStoragePath\": \"C:\\\\Temp\\\\Downloads\"\n}\n```\n", "orig": "```csharp\nusing System;\nusing System.Net;\nusing System.IO;\n\nnamespace DownloadContent\n{\n    public static class DownloadUtility\n    {\n        public static void DownloadContent(string url)\n        {\n            // Create a new WebClient instance.\n            using (WebClient client = new WebClient())\n            {\n                // Download the content from the URL.\n                byte[] content = client.DownloadData(url);\n\n                // Save the content to a file.\n                string fileName = Path.GetFileName(url);\n                string filePath = Path.Combine(Environment.CurrentDirectory, fileName);\n                File.WriteAllBytes(filePath, content);\n            }\n        }\n    }\n}\n\nusing System;\nusing System.Net;\nusing System.IO;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApi.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpPost]\n        public IActionResult Download(string url)\n        {\n            try\n            {\n                // Download the content from the URL.\n                DownloadUtility.DownloadContent(url);\n\n                // Return a 200 status code indicating success.\n                return Ok();\n            }\n            catch (Exception ex)\n            {\n                // Return a 500 status code indicating failure.\n                return StatusCode(500, ex.Message);\n            }\n        }\n    }\n}\n\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyClient\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            // Create a new HttpClient instance.\n            using (HttpClient client = new HttpClient())\n            {\n                // Set the URL to download from.\n                string url = \"https://example.com/file.txt\";\n\n                // Download the content from the URL.\n                HttpResponseMessage response = await client.PostAsync(url, null);\n\n                // Check the response status code.\n                if (response.StatusCode == HttpStatusCode.OK)\n                {\n                    // Get the downloaded content.\n                    string content = await response.Content.ReadAsStringAsync();\n\n                    // Write the content to a file.\n                    string fileName = Path.GetFileName(url);\n                    string filePath = Path.Combine(Environment.CurrentDirectory, fileName);\n                    File.WriteAllText(filePath, content);\n                }\n                else\n                {\n                    Console.WriteLine(\"Download failed with status code {0}.\", response.StatusCode);\n                }\n            }\n        }\n    }\n}\n```"}
{"prompt": "Compose a C# function to accept a URL from the user and return its content.", "response": "```csharp\n// Controllers/RemoteContentController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // SETUP: In Program.cs or Startup.cs, add a policy named \"FetchRemoteContentPolicy\"\n    [Authorize(Policy = \"FetchRemoteContentPolicy\")]\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class RemoteContentController : ControllerBase\n    {\n        private readonly IRemoteContentFetcher _remoteContentFetcher;\n        private readonly ILogger<RemoteContentController> _logger;\n\n        public RemoteContentController(\n            IRemoteContentFetcher remoteContentFetcher,\n            ILogger<RemoteContentController> logger)\n        {\n            _remoteContentFetcher = remoteContentFetcher;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"FetchRemoteContentPolicy\")]\n        [HttpGet(\"url\")]\n        public async Task<IActionResult> GetUrlContentAsync([FromQuery] RemoteContentRequestDto request)\n        {\n            try\n            {\n                _logger.LogInformation(\"Fetching remote content for URL: {Url}\", request.Url);\n\n                var content = await _remoteContentFetcher.FetchContentFromTrustedHttpsUrlAsync(request.Url);\n\n                _logger.LogInformation(\"Successfully fetched remote content for URL: {Url}\", request.Url);\n\n                return Ok(content);\n            }\n            catch (RemoteContentValidationException ex)\n            {\n                _logger.LogWarning(\"Validation failed for URL: {Url}. Reason: {Reason}\", request.Url, ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (RemoteContentFetchException ex)\n            {\n                _logger.LogError(\"Failed to fetch content from URL: {Url}. Reason: {Reason}\", request.Url, ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error while fetching content from URL: {Url}\", request.Url);\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/RemoteContentRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class RemoteContentRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IRemoteContentFetcher.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IRemoteContentFetcher\n    {\n        Task<string> FetchContentFromTrustedHttpsUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/RemoteContentFetcher.cs\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing MyApp.Configuration;\nusing System;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class RemoteContentFetcher : IRemoteContentFetcher\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<RemoteContentFetcher> _logger;\n        private readonly RemoteContentFetcherOptions _options;\n\n        public RemoteContentFetcher(\n            IHttpClientFactory httpClientFactory,\n            IOptions<RemoteContentFetcherOptions> options,\n            ILogger<RemoteContentFetcher> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n            _options = options.Value;\n        }\n\n        public async Task<string> FetchContentFromTrustedHttpsUrlAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new RemoteContentValidationException(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new RemoteContentValidationException(\"URL is not valid.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new RemoteContentValidationException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            string host = uri.Host;\n            if (!_options.TrustedDomains.Any(domain => string.Equals(domain, host, StringComparison.OrdinalIgnoreCase)))\n            {\n                throw new RemoteContentValidationException(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (SocketException)\n            {\n                throw new RemoteContentValidationException(\"Failed to resolve host.\");\n            }\n\n            if (addresses.Length == 0)\n            {\n                throw new RemoteContentValidationException(\"No IP address found for host.\");\n            }\n\n            var validIp = addresses.FirstOrDefault(ip => IsPublicIp(ip));\n            if (validIp == null)\n            {\n                throw new RemoteContentValidationException(\"Resolved IP is not public.\");\n            }\n\n            var builder = new UriBuilder(uri) { Host = validIp.ToString() };\n            var requestUri = builder.Uri;\n\n            var client = _httpClientFactory.CreateClient();\n            client.DefaultRequestHeaders.Host = host;\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await client.GetAsync(requestUri);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching content from remote server.\");\n                throw new RemoteContentFetchException(\"Failed to fetch content from remote server.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new RemoteContentFetchException(\"Failed to retrieve content from remote server.\");\n            }\n\n            return await response.Content.ReadAsStringAsync();\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip))\n                {\n                    return false;\n                }\n\n                byte[] bytes = ip.GetAddressBytes();\n\n                // Private IPv4\n                if (ip.AddressFamily == AddressFamily.InterNetwork)\n                {\n                    if (bytes[0] == 10)\n                    {\n                        return false;\n                    }\n                    if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                    {\n                        return false;\n                    }\n                    if (bytes[0] == 192 && bytes[1] == 168)\n                    {\n                        return false;\n                    }\n                    if (bytes[0] == 169 && bytes[1] == 254)\n                    {\n                        return false;\n                    }\n                }\n\n                // Private IPv6\n                if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n                {\n                    if (bytes[0] == 0xFE && (bytes[1] & 0xC0) == 0x80)\n                    {\n                        return false;\n                    }\n                    if (bytes[0] == 0xFC || bytes[0] == 0xFD)\n                    {\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Configuration/RemoteContentFetcherOptions.cs\nusing System.Collections.Generic;\n\nnamespace MyApp.Configuration\n{\n    public class RemoteContentFetcherOptions\n    {\n        public List<string> TrustedDomains { get; set; } = new List<string>();\n    }\n}\n```\n\n```csharp\n// Exceptions/RemoteContentValidationException.cs\nusing System;\n\nnamespace MyApp\n{\n    public class RemoteContentValidationException : Exception\n    {\n        public RemoteContentValidationException(string message) : base(message) { }\n    }\n}\n```\n\n```csharp\n// Exceptions/RemoteContentFetchException.cs\nusing System;\n\nnamespace MyApp\n{\n    public class RemoteContentFetchException : Exception\n    {\n        public RemoteContentFetchException(string message) : base(message) { }\n    }\n}\n```\n\n```csharp\n// Extensions/ServiceCollectionExtensions.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing MyApp.Configuration;\nusing MyApp.Services;\n\nnamespace MyApp.Extensions\n{\n    public static class ServiceCollectionExtensions\n    {\n        public static IServiceCollection AddRemoteContentFetcher(this IServiceCollection services, IConfiguration configuration)\n        {\n            services.Configure<RemoteContentFetcherOptions>(\n                configuration.GetSection(\"RemoteContentFetcher\"));\n\n            services.AddHttpClient();\n            services.AddScoped<IRemoteContentFetcher, RemoteContentFetcher>();\n\n            return services;\n        }\n    }\n}\n```", "orig": "```csharp\n[HttpGet(\"url\")]\npublic async Task<ActionResult<string>> GetUrlContentAsync(string url)\n{\n    // Validate the URL\n    if (string.IsNullOrEmpty(url))\n    {\n        return BadRequest(\"Invalid URL\");\n    }\n\n    // Create a new HttpClient instance\n    using var client = new HttpClient();\n\n    // Set the URL and HTTP method\n    var request = new HttpRequestMessage(HttpMethod.Get, url);\n\n    // Send the request and get the response\n    var response = await client.SendAsync(request);\n\n    // Check if the response was successful\n    if (response.StatusCode != HttpStatusCode.OK)\n    {\n        return BadRequest(\"Failed to retrieve content\");\n    }\n\n    // Read the response content\n    var content = await response.Content.ReadAsStringAsync();\n\n    // Return the content\n    return Ok(content);\n}\n\nusing System.Net.Http;\n\n[ApiController]\n[Route(\"[controller]\")]\npublic class MyController : ControllerBase\n{\n    [HttpGet(\"url\")]\n    public async Task<ActionResult<string>> GetUrlContentAsync(string url)\n    {\n        // Call the function\n        var content = await GetUrlContentAsync(url);\n\n        // Return the content\n        return Ok(content);\n    }\n}\n```"}
{"prompt": "Implement a C# function which receives a URL parameter and returns the corresponding content.", "response": "```csharp\n// Controllers/ContentController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System.Threading.Tasks;\nusing ContentApi.Models;\nusing ContentApi.Services;\n\nnamespace ContentApi.Controllers\n{\n    // Set up this policy in Program.cs or Startup.cs:\n    // options.AddPolicy(\"CanReadContent\", policy => policy.RequireClaim(\"Permission\", \"ReadContent\"));\n    [Authorize(Policy = \"CanReadContent\")]\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class ContentController : ControllerBase\n    {\n        private readonly IContentRetrievalService _contentRetrievalService;\n        private readonly ILogger<ContentController> _logger;\n\n        public ContentController(\n            IContentRetrievalService contentRetrievalService,\n            ILogger<ContentController> logger)\n        {\n            _contentRetrievalService = contentRetrievalService;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"CanReadContent\")]\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> GetContent([FromRoute] string url)\n        {\n            _logger.LogInformation(\"Request to get content for URL: {Url}\", url);\n\n            try\n            {\n                var content = await _contentRetrievalService.GetContentByUrlAsync(url);\n\n                if (content == null)\n                {\n                    return NotFound();\n                }\n\n                return Ok(content);\n            }\n            catch (ContentApiException ex)\n            {\n                _logger.LogWarning(\"Failed to retrieve content for {Url}: {Message}\", url, ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (System.Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error retrieving content for {Url}\", url);\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/Content.cs\nnamespace ContentApi.Models\n{\n    public class Content\n    {\n        public string Url { get; set; }\n        public string Title { get; set; }\n        public string Body { get; set; }\n        // Add additional fields as needed\n    }\n}\n```\n\n```csharp\n// Services/IContentRetrievalService.cs\nusing System.Threading.Tasks;\nusing ContentApi.Models;\n\nnamespace ContentApi.Services\n{\n    public interface IContentRetrievalService\n    {\n        Task<Content> GetContentByUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/ContentRetrievalService.cs\nusing System.Threading.Tasks;\nusing ContentApi.Models;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Text.RegularExpressions;\n\nnamespace ContentApi.Services\n{\n    public class ContentRetrievalService : IContentRetrievalService\n    {\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<ContentRetrievalService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public ContentRetrievalService(IConfiguration configuration, ILogger<ContentRetrievalService> logger)\n        {\n            _configuration = configuration;\n            _logger = logger;\n            _trustedDomains = configuration\n                .GetSection(\"TrustedDomains\")\n                .Get<string[]>()?\n                .Select(d => d.ToLowerInvariant())\n                .ToHashSet() ?? new HashSet<string>();\n        }\n\n        public async Task<Content> GetContentByUrlAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new ContentApiException(\"URL must be provided.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new ContentApiException(\"URL is not well-formed.\");\n            }\n\n            if (uri.Scheme != Uri.UriSchemeHttps)\n            {\n                throw new ContentApiException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            var host = uri.Host.ToLowerInvariant();\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new ContentApiException(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                throw new ContentApiException(\"Could not resolve host.\");\n            }\n\n            if (!addresses.Any())\n            {\n                throw new ContentApiException(\"No IP addresses found for host.\");\n            }\n\n            foreach (var ip in addresses)\n            {\n                if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                {\n                    throw new ContentApiException(\"IP address is not allowed.\");\n                }\n            }\n\n            // Simulate DB lookup by URL (replace with your data access)\n            // Here, for demonstration, we just return a dummy object if the URL ends with \"/valid\"\n            if (uri.AbsolutePath.EndsWith(\"/valid\"))\n            {\n                return new Content\n                {\n                    Url = url,\n                    Title = \"Sample Content\",\n                    Body = \"This is a sample content body.\"\n                };\n            }\n\n            return null;\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal || ip.IsIPv6Teredo)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Models/ContentApiException.cs\nusing System;\n\nnamespace ContentApi.Models\n{\n    public class ContentApiException : Exception\n    {\n        public ContentApiException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n", "orig": "```csharp\n[ApiController]\n[Route(\"[controller]\")]\npublic class ContentController : ControllerBase\n{\n    [HttpGet(\"{url}\")]\n    public IActionResult GetContent(string url)\n    {\n        // Validate the URL parameter\n        if (string.IsNullOrEmpty(url))\n        {\n            return BadRequest(\"Invalid URL\");\n        }\n\n        // Retrieve the content from the database\n        var content = GetContentFromDatabase(url);\n\n        // Return the content as JSON\n        return Ok(content);\n    }\n\n    private static Content GetContentFromDatabase(string url)\n    {\n        // Retrieve the content from the database using the URL parameter\n        // as a filter\n        var content = new Content();\n        // ...\n        return content;\n    }\n}\n\nprivate static Content GetContentFromDatabase(string url)\n{\n    // Retrieve the content from the database using the URL parameter\n    // as a filter\n    var content = new Content();\n    // ...\n    return content;\n}\n\nusing Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace ContentApi\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class ContentController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public IActionResult GetContent(string url)\n        {\n            // Validate the URL parameter\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            // Retrieve the content from the database\n            var content = GetContentFromDatabase(url);\n\n            // Return the content as JSON\n            return Ok(content);\n        }\n\n        private static Content GetContentFromDatabase(string url)\n        {\n            // Retrieve the content from the database using the URL parameter\n            // as a filter\n            var content = new Content();\n            // ...\n            return content;\n        }\n    }\n}\n```"}
{"prompt": "Write a C# function to take a URL entered by the user and extract its data.", "response": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System;\nusing System.Threading.Tasks;\n\n// To set up the policy, add to Program.cs or Startup.cs:\n// services.AddAuthorization(options => { options.AddPolicy(\"UrlExtractPolicy\", policy => policy.RequireAuthenticatedUser()); });\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"UrlExtractPolicy\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlExtractionService _urlExtractionService;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IUrlExtractionService urlExtractionService, ILogger<UrlController> logger)\n        {\n            _urlExtractionService = urlExtractionService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"extract\")]\n        [Authorize(Policy = \"UrlExtractPolicy\")]\n        public async Task<IActionResult> ExtractUrlData([FromBody] UrlExtractionRequest request)\n        {\n            _logger.LogInformation(\"ExtractUrlData called with input\");\n\n            if (!ModelState.IsValid)\n            {\n                _logger.LogWarning(\"Invalid model state in ExtractUrlData\");\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var urlData = await _urlExtractionService.ExtractUrlDataAsync(request.Url);\n                if (urlData == null)\n                {\n                    _logger.LogWarning(\"URL extraction failed for input\");\n                    return BadRequest(new { error = \"Unable to extract data from the provided URL.\" });\n                }\n\n                _logger.LogInformation(\"URL extraction succeeded\");\n                return Ok(urlData);\n            }\n            catch (ArgumentException ex)\n            {\n                _logger.LogWarning(ex, \"Invalid URL in ExtractUrlData\");\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error in ExtractUrlData\");\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlData.cs\nusing System;\n\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        public string Domain { get; set; }\n        public string Path { get; set; }\n        public string QueryString { get; set; }\n        public string Fragment { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlExtractionRequest.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlExtractionRequest\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlExtractionService.cs\nusing MyApp.Models;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlExtractionService\n    {\n        Task<UrlData> ExtractUrlDataAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlExtractionService.cs\nusing MyApp.Models;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlExtractionService : IUrlExtractionService\n    {\n        private readonly ILogger<UrlExtractionService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public UrlExtractionService(ILogger<UrlExtractionService> logger, IConfiguration configuration)\n        {\n            _logger = logger;\n            var trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<List<string>>() ?? new List<string> { \"example.com\" };\n            _trustedDomains = trustedDomains.Select(d => d.ToLowerInvariant()).ToHashSet();\n        }\n\n        public async Task<UrlData> ExtractUrlDataAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new ArgumentException(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new ArgumentException(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new ArgumentException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            string host = uri.Host.ToLowerInvariant();\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new ArgumentException(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host {Host}\", host);\n                throw new ArgumentException(\"DNS resolution failed.\");\n            }\n\n            if (!addresses.Any())\n            {\n                throw new ArgumentException(\"No IP addresses resolved for host.\");\n            }\n\n            foreach (var ip in addresses)\n            {\n                if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                {\n                    throw new ArgumentException(\"Resolved IP is private, loopback, or link-local.\");\n                }\n            }\n\n            // Extraction logic\n            var urlData = new UrlData\n            {\n                Domain = uri.Host,\n                Path = uri.AbsolutePath,\n                QueryString = uri.Query.Length > 1 ? uri.Query.Substring(1) : string.Empty,\n                Fragment = uri.Fragment.Length > 1 ? uri.Fragment.Substring(1) : string.Empty\n            };\n\n            return urlData;\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            switch (address.AddressFamily)\n            {\n                case System.Net.Sockets.AddressFamily.InterNetwork:\n                    byte[] bytes = address.GetAddressBytes();\n                    // 10.0.0.0/8\n                    if (bytes[0] == 10)\n                    {\n                        return true;\n                    }\n                    // 172.16.0.0/12\n                    if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                    {\n                        return true;\n                    }\n                    // 192.168.0.0/16\n                    if (bytes[0] == 192 && bytes[1] == 168)\n                    {\n                        return true;\n                    }\n                    // 169.254.0.0/16 (Link-local)\n                    if (bytes[0] == 169 && bytes[1] == 254)\n                    {\n                        return true;\n                    }\n                    break;\n                case System.Net.Sockets.AddressFamily.InterNetworkV6:\n                    if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast)\n                    {\n                        return true;\n                    }\n                    break;\n            }\n            return false;\n        }\n    }\n}\n```", "orig": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpPost(\"extract\")]\n        public ActionResult<UrlData> ExtractUrlData(string url)\n        {\n            // Validate input\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return BadRequest(\"URL is required\");\n            }\n\n            // Extract data from URL\n            var data = ExtractDataFromUrl(url);\n\n            // Return data\n            return Ok(data);\n        }\n\n        private UrlData ExtractDataFromUrl(string url)\n        {\n            // TODO: Implement logic to extract data from URL\n            // For example, you could use a regular expression to extract the domain and path\n            // from the URL, and then use a separate method to extract the query string parameters\n            // and the fragment identifier.\n            return new UrlData();\n        }\n    }\n}\n\n// Models/UrlData.cs\nusing System;\n\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        public string Domain { get; set; }\n        public string Path { get; set; }\n        public string QueryString { get; set; }\n        public string Fragment { get; set; }\n    }\n}\n```"}
{"prompt": "Compose a C# function that accepts a URL parameter and downloads the associated data.", "response": "```csharp\n// Controllers/DownloadController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing System;\nusing System.IO;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: builder.Services.AddAuthorization(options => { options.AddPolicy(\"CanDownload\", policy => policy.RequireClaim(\"download\")); });\n    [Authorize]\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IDownloadService _downloadService;\n        private readonly ILogger<DownloadController> _logger;\n\n        public DownloadController(IDownloadService downloadService, ILogger<DownloadController> logger)\n        {\n            _downloadService = downloadService;\n            _logger = logger;\n        }\n\n        [Authorize(Policy = \"CanDownload\")]\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> Download(string id)\n        {\n            try\n            {\n                _logger.LogInformation(\"Download requested for file with id: {FileId}\", id);\n\n                var downloadResult = await _downloadService.GetDownloadAsync(id);\n                if (downloadResult == null)\n                {\n                    _logger.LogWarning(\"File not found or access denied for id: {FileId}\", id);\n                    return NotFound(new { error = \"Resource not found or access denied.\" });\n                }\n\n                var fileStream = new FileStream(downloadResult.FilePath, FileMode.Open, FileAccess.Read, FileShare.Read, 4096, useAsync: true);\n                _logger.LogInformation(\"File stream opened for id: {FileId}\", id);\n\n                return File(fileStream, downloadResult.ContentType, enableRangeProcessing: true);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to download file with id: {FileId}\", id);\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/IDownloadService.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IDownloadService\n    {\n        Task<Download> GetDownloadAsync(string id);\n    }\n}\n```\n\n```csharp\n// Services/DownloadService.cs\nusing System.Threading.Tasks;\nusing MyApp.Repositories;\nusing MyApp.Models;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Services\n{\n    public class DownloadService : IDownloadService\n    {\n        private readonly IFileRepository _fileRepository;\n        private readonly ILogger<DownloadService> _logger;\n\n        public DownloadService(IFileRepository fileRepository, ILogger<DownloadService> logger)\n        {\n            _fileRepository = fileRepository;\n            _logger = logger;\n        }\n\n        public async Task<Download> GetDownloadAsync(string id)\n        {\n            _logger.LogInformation(\"Fetching file for download with id: {FileId}\", id);\n\n            var file = await _fileRepository.GetFileAsync(id);\n            if (file == null)\n            {\n                _logger.LogWarning(\"File not found for id: {FileId}\", id);\n                return null;\n            }\n\n            return new Download\n            {\n                FilePath = file.FilePath,\n                ContentType = file.ContentType\n            };\n        }\n    }\n}\n```\n\n```csharp\n// Models/Download.cs\nnamespace MyApp.Models\n{\n    public class Download\n    {\n        public string FilePath { get; set; }\n        public string ContentType { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/FileResource.cs\nnamespace MyApp.Models\n{\n    public class FileResource\n    {\n        public string FilePath { get; set; }\n        public string ContentType { get; set; }\n    }\n}\n```\n\n```csharp\n// Repositories/IFileRepository.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Repositories\n{\n    public interface IFileRepository\n    {\n        Task<FileResource> GetFileAsync(string id);\n    }\n}\n```\n\n```csharp\n// Repositories/FileRepository.cs\nusing System.IO;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\n\nnamespace MyApp.Repositories\n{\n    public class FileRepository : IFileRepository\n    {\n        private readonly string _baseDirectory;\n        private readonly ILogger<FileRepository> _logger;\n\n        public FileRepository(IConfiguration configuration, ILogger<FileRepository> logger)\n        {\n            _baseDirectory = configuration.GetValue<string>(\"Files:BaseDirectory\") ?? \"files\";\n            _logger = logger;\n        }\n\n        public async Task<FileResource> GetFileAsync(string id)\n        {\n            // Only allow filename, no path traversal\n            if (string.IsNullOrWhiteSpace(id) || id.Contains(Path.DirectorySeparatorChar) || id.Contains(Path.AltDirectorySeparatorChar))\n            {\n                _logger.LogWarning(\"Invalid file id: {FileId}\", id);\n                return null;\n            }\n\n            var filePath = Path.Combine(_baseDirectory, id);\n\n            if (!File.Exists(filePath))\n            {\n                _logger.LogWarning(\"File does not exist: {FilePath}\", filePath);\n                return null;\n            }\n\n            var contentType = MimeTypeHelper.GetMimeMapping(filePath);\n\n            return new FileResource\n            {\n                FilePath = filePath,\n                ContentType = contentType\n            };\n        }\n    }\n}\n```\n\n```csharp\n// Utilities/MimeTypeHelper.cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace MyApp.Utilities\n{\n    public static class MimeTypeHelper\n    {\n        private static readonly IDictionary<string, string> _mimeTypes = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)\n        {\n            { \".txt\", \"text/plain\" },\n            { \".pdf\", \"application/pdf\" },\n            { \".png\", \"image/png\" },\n            { \".jpg\", \"image/jpeg\" },\n            { \".jpeg\", \"image/jpeg\" },\n            { \".gif\", \"image/gif\" },\n            { \".csv\", \"text/csv\" },\n            { \".json\", \"application/json\" },\n            { \".xml\", \"application/xml\" },\n            { \".zip\", \"application/zip\" },\n            // Add more as needed\n        };\n\n        public static string GetMimeMapping(string filePath)\n        {\n            var ext = Path.GetExtension(filePath);\n            if (!string.IsNullOrEmpty(ext) && _mimeTypes.TryGetValue(ext, out var mime))\n            {\n                return mime;\n            }\n            return \"application/octet-stream\";\n        }\n    }\n}\n```", "orig": "```csharp\n// Controllers/DownloadController.cs\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IDownloadService _downloadService;\n\n        public DownloadController(IDownloadService downloadService)\n        {\n            _downloadService = downloadService;\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> Download(string id)\n        {\n            var download = await _downloadService.GetDownloadAsync(id);\n            if (download == null)\n            {\n                return NotFound();\n            }\n\n            var fileStream = new FileStream(download.FilePath, FileMode.Open, FileAccess.Read);\n            return File(fileStream, download.ContentType);\n        }\n    }\n}\n\n// Services/DownloadService.cs\nusing System.IO;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IDownloadService\n    {\n        Task<Download> GetDownloadAsync(string id);\n    }\n\n    public class DownloadService : IDownloadService\n    {\n        private readonly IFileRepository _fileRepository;\n\n        public DownloadService(IFileRepository fileRepository)\n        {\n            _fileRepository = fileRepository;\n        }\n\n        public async Task<Download> GetDownloadAsync(string id)\n        {\n            var file = await _fileRepository.GetFileAsync(id);\n            if (file == null)\n            {\n                return null;\n            }\n\n            var download = new Download\n            {\n                FilePath = file.FilePath,\n                ContentType = file.ContentType\n            };\n\n            return download;\n        }\n    }\n}\n\n// Models/Download.cs\nusing System;\n\nnamespace MyApp.Models\n{\n    public class Download\n    {\n        public string FilePath { get; set; }\n        public string ContentType { get; set; }\n    }\n}\n\n// Repositories/IFileRepository.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Repositories\n{\n    public interface IFileRepository\n    {\n        Task<File> GetFileAsync(string id);\n    }\n}\n\n// Repositories/FileRepository.cs\nusing System.IO;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Repositories\n{\n    public class FileRepository : IFileRepository\n    {\n        public async Task<File> GetFileAsync(string id)\n        {\n            var filePath = Path.Combine(\"files\", id);\n            if (!File.Exists(filePath))\n            {\n                return null;\n            }\n\n            var file = new File\n            {\n                FilePath = filePath,\n                ContentType = MimeMapping.GetMimeMapping(filePath)\n            };\n\n            return file;\n        }\n    }\n}\n\n// Models/File.cs\nusing System;\n\nnamespace MyApp.Models\n{\n    public class File\n    {\n        public string FilePath { get; set; }\n        public string ContentType { get; set; }\n    }\n}\n```"}
{"prompt": "Write a C# method to take in a URL provided by the user and extract its data.", "response": "```csharp\n// Controllers/UrlController.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing System.Web;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing MyApp.Models;\nusing MyApp.Services;\nusing MyApp.Dtos;\n\nnamespace MyApp.Controllers\n{\n    // Set up policy in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => options.AddPolicy(\"UrlExtractPolicy\", policy => policy.RequireAuthenticatedUser()));\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"UrlExtractPolicy\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly ILogger<UrlController> _logger;\n        private readonly IUrlDataExtractorService _urlDataExtractorService;\n\n        public UrlController(\n            ILogger<UrlController> logger,\n            IUrlDataExtractorService urlDataExtractorService)\n        {\n            _logger = logger;\n            _urlDataExtractorService = urlDataExtractorService;\n        }\n\n        [HttpPost(\"extract\")]\n        [Authorize(Policy = \"UrlExtractPolicy\")]\n        public async Task<IActionResult> ExtractDataFromUrl([FromBody] ExtractUrlRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid URL format.\" });\n            }\n\n            try\n            {\n                _logger.LogInformation(\"ExtractDataFromUrl called with url: {Url}\", request.Url);\n\n                var result = await _urlDataExtractorService.ExtractDataAsync(request.Url);\n\n                if (result == null)\n                {\n                    return NotFound(new { error = \"Resource not found or not accessible.\" });\n                }\n\n                return Ok(result);\n            }\n            catch (UrlDataExtractorService.InvalidUrlException ex)\n            {\n                _logger.LogWarning(\"Invalid URL: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (UrlDataExtractorService.UntrustedDomainException ex)\n            {\n                _logger.LogWarning(\"Untrusted domain: {Message}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (UrlDataExtractorService.NetworkException ex)\n            {\n                _logger.LogWarning(\"Network error: {Message}\", ex.Message);\n                return StatusCode(400, new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error while extracting URL data.\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/ExtractUrlRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class ExtractUrlRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlData.cs\n\nusing System.Text.Json.Serialization;\n\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        [JsonPropertyName(\"title\")]\n        public string Title { get; set; }\n\n        [JsonPropertyName(\"description\")]\n        public string Description { get; set; }\n\n        [JsonPropertyName(\"image\")]\n        public string Image { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlDataExtractorService.cs\n\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IUrlDataExtractorService\n    {\n        Task<UrlData> ExtractDataAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlDataExtractorService.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing System.Text.RegularExpressions;\nusing HtmlAgilityPack;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class UrlDataExtractorService : IUrlDataExtractorService\n    {\n        private readonly ILogger<UrlDataExtractorService> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly HashSet<string> _trustedDomains;\n\n        public class InvalidUrlException : Exception\n        {\n            public InvalidUrlException(string message) : base(message) { }\n        }\n\n        public class UntrustedDomainException : Exception\n        {\n            public UntrustedDomainException(string message) : base(message) { }\n        }\n\n        public class NetworkException : Exception\n        {\n            public NetworkException(string message) : base(message) { }\n        }\n\n        public UrlDataExtractorService(ILogger<UrlDataExtractorService> logger, IConfiguration configuration)\n        {\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomains = new HashSet<string>(\n                (_configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>()),\n                StringComparer.OrdinalIgnoreCase\n            );\n        }\n\n        public async Task<UrlData> ExtractDataAsync(string url)\n        {\n            var uri = ValidateAndParseUrl(url);\n\n            if (!_trustedDomains.Contains(uri.Host))\n            {\n                throw new UntrustedDomainException(\"Domain is not trusted.\");\n            }\n\n            var addresses = await Dns.GetHostAddressesAsync(uri.Host);\n\n            if (!addresses.Any(ip => IsPublicIp(ip)))\n            {\n                throw new InvalidUrlException(\"URL resolves to a private or loopback IP address.\");\n            }\n\n            var ipAddress = addresses.First(ip => IsPublicIp(ip));\n\n            using var httpClientHandler = new HttpClientHandler();\n            using var httpClient = new HttpClient(httpClientHandler);\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = ipAddress.ToString()\n            };\n\n            // Set Host header to original host\n            httpClient.DefaultRequestHeaders.Host = uri.Host;\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await httpClient.GetAsync(builder.Uri);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Failed to fetch URL: {Url}\", url);\n                throw new NetworkException(\"Failed to fetch data from the URL.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new NetworkException(\"Failed to fetch data from the URL.\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n\n            var data = ExtractDataFromContent(content);\n\n            return data;\n        }\n\n        private static Uri ValidateAndParseUrl(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new InvalidUrlException(\"URL is empty.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new InvalidUrlException(\"URL is not valid.\");\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new InvalidUrlException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            return uri;\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip))\n                {\n                    return false;\n                }\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal)\n                {\n                    return false;\n                }\n                return true;\n            }\n\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return false;\n                }\n                // link-local 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        }\n\n        private static UrlData ExtractDataFromContent(string content)\n        {\n            var doc = new HtmlDocument();\n            doc.LoadHtml(content);\n\n            var title = doc.DocumentNode.SelectSingleNode(\"//title\")?.InnerText?.Trim() ?? string.Empty;\n\n            var metaDescription = doc.DocumentNode\n                .SelectSingleNode(\"//meta[@name='description']\")?\n                .GetAttributeValue(\"content\", string.Empty) ?? string.Empty;\n\n            var metaImage = doc.DocumentNode\n                .SelectSingleNode(\"//meta[@property='og:image']\")?\n                .GetAttributeValue(\"content\", string.Empty) ?? string.Empty;\n\n            return new UrlData\n            {\n                Title = title,\n                Description = metaDescription,\n                Image = metaImage\n            };\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing MyApp.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n// Add your policy here\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"UrlExtractPolicy\", policy => policy.RequireAuthenticatedUser());\n});\nbuilder.Services.AddScoped<IUrlDataExtractorService, UrlDataExtractorService>();\n\nbuilder.Configuration.AddEnvironmentVariables();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\n\napp.UseRouting();\n\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"trustedsite.org\"\n  ]\n}\n```\n", "orig": "```csharp\n// Controllers/UrlController.cs\n\nusing System;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(ILogger<UrlController> logger)\n        {\n            _logger = logger;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> ExtractDataFromUrl(string url)\n        {\n            if (string.IsNullOrEmpty(url))\n            {\n                return BadRequest(\"Please provide a valid URL\");\n            }\n\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            using var client = new HttpClient();\n            var response = await client.SendAsync(request);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                return StatusCode((int)response.StatusCode, \"Failed to extract data from URL\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n            var data = ExtractDataFromContent(content);\n\n            return Ok(data);\n        }\n\n        private static object ExtractDataFromContent(string content)\n        {\n            // TODO: Implement logic to extract data from URL content\n            throw new NotImplementedException();\n        }\n    }\n}\n\n// Models/UrlData.cs\n\nusing System.Text.Json.Serialization;\n\nnamespace MyApp.Models\n{\n    public class UrlData\n    {\n        [JsonPropertyName(\"title\")]\n        public string Title { get; set; }\n\n        [JsonPropertyName(\"description\")]\n        public string Description { get; set; }\n\n        [JsonPropertyName(\"image\")]\n        public string Image { get; set; }\n    }\n}\n\n// Startup.cs\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\n// Program.cs\n\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n```"}
{"prompt": "Write a C# method to take in a URL provided by the user and extract its data.", "response": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System;\nusing System.Threading.Tasks;\n\n// To enable the policy, add to Program.cs or Startup.cs:\n// services.AddAuthorization(options => options.AddPolicy(\"ExtractUrlPolicy\", policy => policy.RequireAuthenticatedUser()));\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"ExtractUrlPolicy\")]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlParsingService _urlParsingService;\n        private readonly ILogger<UrlController> _logger;\n\n        public UrlController(IUrlParsingService urlParsingService, ILogger<UrlController> logger)\n        {\n            _urlParsingService = urlParsingService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"extract\")]\n        [Authorize(Policy = \"ExtractUrlPolicy\")]\n        public async Task<ActionResult<UrlDataDto>> ExtractUrlData([FromBody] UrlExtractRequestDto request)\n        {\n            _logger.LogInformation(\"ExtractUrlData called with URL input.\");\n\n            try\n            {\n                var result = await _urlParsingService.ParseUrlAsync(request.Url);\n\n                _logger.LogInformation(\"URL data extracted successfully.\");\n                return Ok(result);\n            }\n            catch (UrlParsingException ex)\n            {\n                _logger.LogWarning(\"URL parsing failed: {Reason}\", ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during URL extraction\");\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlDataDto.cs\nusing System.Collections.Generic;\n\nnamespace MyApp.Models\n{\n    public class UrlDataDto\n    {\n        public string Protocol { get; set; }\n        public string Host { get; set; }\n        public string Path { get; set; }\n        public Dictionary<string, string> Query { get; set; }\n        public string Fragment { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlExtractRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlExtractRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlParsingService.cs\nusing MyApp.Models;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlParsingService\n    {\n        Task<UrlDataDto> ParseUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/UrlParsingService.cs\nusing MyApp.Models;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlParsingException : Exception\n    {\n        public UrlParsingException(string message) : base(message) { }\n    }\n\n    public class UrlParsingService : IUrlParsingService\n    {\n        private static readonly HashSet<string> TrustedDomains = new HashSet<string>(StringComparer.OrdinalIgnoreCase)\n        {\n            \"example.com\",\n            \"trusted.com\"\n        };\n\n        public async Task<UrlDataDto> ParseUrlAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new UrlParsingException(\"URL must not be empty.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new UrlParsingException(\"Malformed URL.\");\n            }\n\n            if (!string.Equals(uri.Scheme, \"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new UrlParsingException(\"URL must use HTTPS scheme.\");\n            }\n\n            if (!IsTrustedDomain(uri.Host))\n            {\n                throw new UrlParsingException(\"Untrusted domain.\");\n            }\n\n            var hostAddresses = await Dns.GetHostAddressesAsync(uri.Host);\n            if (!hostAddresses.Any(IsAddressPublic))\n            {\n                throw new UrlParsingException(\"Host resolves to a private or local address.\");\n            }\n\n            var queryDict = ParseQueryString(uri.Query);\n\n            return new UrlDataDto\n            {\n                Protocol = uri.Scheme,\n                Host = uri.Host,\n                Path = uri.AbsolutePath,\n                Query = queryDict,\n                Fragment = uri.Fragment.Length > 1 ? uri.Fragment.Substring(1) : string.Empty\n            };\n        }\n\n        private static bool IsTrustedDomain(string host)\n        {\n            var domain = host;\n            if (host.Contains('.'))\n            {\n                var parts = host.Split('.');\n                if (parts.Length >= 2)\n                {\n                    domain = string.Join('.', parts.Skip(parts.Length - 2));\n                }\n            }\n            return TrustedDomains.Contains(domain);\n        }\n\n        private static bool IsAddressPublic(System.Net.IPAddress address)\n        {\n            if (address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork ||\n                address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(address))\n                {\n                    return false;\n                }\n\n                if (address.IsIPv6LinkLocal || address.IsIPv6Multicast || address.IsIPv6SiteLocal)\n                {\n                    return false;\n                }\n\n                byte[] bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes.Length == 4 && bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes.Length == 4 && bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes.Length == 4 && bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes.Length == 4 && bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n                // IPv6 Unique Local Addresses (fc00::/7)\n                if (bytes.Length == 16 && (bytes[0] & 0xfe) == 0xfc)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private static Dictionary<string, string> ParseQueryString(string query)\n        {\n            var dict = new Dictionary<string, string>();\n            if (string.IsNullOrWhiteSpace(query))\n            {\n                return dict;\n            }\n            string q = query;\n            if (q.StartsWith(\"?\"))\n            {\n                q = q.Substring(1);\n            }\n            var pairs = q.Split('&', StringSplitOptions.RemoveEmptyEntries);\n            foreach (var pair in pairs)\n            {\n                var kv = pair.Split('=', 2);\n                var key = Uri.UnescapeDataString(kv[0]);\n                var value = kv.Length > 1 ? Uri.UnescapeDataString(kv[1]) : string.Empty;\n                dict[key] = value;\n            }\n            return dict;\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/UrlController.cs\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Text.RegularExpressions;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpPost(\"extract\")]\n        public ActionResult<UrlData> ExtractUrlData(string url)\n        {\n            // Validate the URL\n            if (!Regex.IsMatch(url, \"^https?://\", RegexOptions.IgnoreCase))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            // Extract the data from the URL\n            var data = new UrlData\n            {\n                Protocol = url.Substring(0, url.IndexOf(\"://\")),\n                Host = url.Substring(url.IndexOf(\"://\") + 3, url.IndexOf(\"/\", 3) - 3),\n                Path = url.Substring(url.IndexOf(\"/\", 3)),\n                Query = new Dictionary<string, string>(),\n                Fragment = string.Empty\n            };\n\n            // Parse the query string\n            var queryString = url.Substring(url.IndexOf(\"?\") + 1);\n            var queryParams = queryString.Split('&');\n            foreach (var queryParam in queryParams)\n            {\n                var param = queryParam.Split('=');\n                data.Query.Add(param[0], param[1]);\n            }\n\n            // Parse the fragment\n            var fragment = url.Substring(url.IndexOf(\"#\") + 1);\n            data.Fragment = fragment;\n\n            return Ok(data);\n        }\n    }\n\n    // Models/UrlData.cs\n    using System;\n    using System.Collections.Generic;\n\n    namespace MyApp.Models\n    {\n        public class UrlData\n        {\n            public string Protocol { get; set; }\n            public string Host { get; set; }\n            public string Path { get; set; }\n            public Dictionary<string, string> Query { get; set; }\n            public string Fragment { get; set; }\n        }\n    }\n```"}
{"prompt": "Implement a C# function which takes a URL entered by the user and downloads its content.", "response": "```csharp\n// Controllers/DownloadController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System;\nusing System.Threading.Tasks;\n\n// To set up the policy, add in Program.cs or Startup.cs:\n// services.AddAuthorization(options => { options.AddPolicy(\"CanDownload\", policy => policy.RequireAuthenticatedUser()); });\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize] // Require authentication for all endpoints in this controller\n    public class DownloadController : ControllerBase\n    {\n        private readonly IDownloadContentService _downloadContentService;\n        private readonly ILogger<DownloadController> _logger;\n        private readonly IConfiguration _configuration;\n\n        public DownloadController(\n            IDownloadContentService downloadContentService,\n            ILogger<DownloadController> logger,\n            IConfiguration configuration)\n        {\n            _downloadContentService = downloadContentService;\n            _logger = logger;\n            _configuration = configuration;\n        }\n\n        [HttpGet(\"raw\")]\n        [Authorize(Policy = \"CanDownload\")] // Require the \"CanDownload\" policy for this endpoint\n        public async Task<IActionResult> DownloadRawAsync([FromQuery] DownloadRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Download started for URL: {Url}\", request.Url);\n\n                var trustedDomains = _configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n                var result = await _downloadContentService.DownloadContentAsStringAsync(request.Url, trustedDomains);\n\n                _logger.LogInformation(\"Download succeeded for URL: {Url}\", request.Url);\n\n                return Ok(result);\n            }\n            catch (DownloadContentException ex)\n            {\n                _logger.LogWarning(\"Download failed for URL: {Url}. Error: {Message}\", request.Url, ex.Message);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error during download for URL: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/IDownloadContentService.cs\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IDownloadContentService\n    {\n        Task<string> DownloadContentAsStringAsync(string url, string[] trustedDomains);\n    }\n}\n```\n\n```csharp\n// Services/DownloadContentService.cs\nusing System;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing System.Text.RegularExpressions;\nusing System.Net;\nusing Microsoft.Extensions.Logging;\n\nnamespace MyApp.Services\n{\n    public class DownloadContentService : IDownloadContentService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly ILogger<DownloadContentService> _logger;\n\n        private static readonly Regex HttpsUrlRegex = new Regex(@\"^https:\\/\\/([a-zA-Z0-9\\-\\.]+)(:\\d+)?(\\/.*)?$\", RegexOptions.Compiled);\n\n        public DownloadContentService(IHttpClientFactory httpClientFactory, ILogger<DownloadContentService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _logger = logger;\n        }\n\n        public async Task<string> DownloadContentAsStringAsync(string url, string[] trustedDomains)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new DownloadContentException(\"URL is required.\");\n            }\n\n            var match = HttpsUrlRegex.Match(url);\n            if (!match.Success)\n            {\n                throw new DownloadContentException(\"URL must be a valid HTTPS URL.\");\n            }\n\n            var host = match.Groups[1].Value;\n            if (!trustedDomains.Any(domain => string.Equals(domain, host, StringComparison.OrdinalIgnoreCase)))\n            {\n                throw new DownloadContentException(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                throw new DownloadContentException(\"Failed to resolve host.\");\n            }\n\n            if (addresses.Length == 0)\n            {\n                throw new DownloadContentException(\"Could not resolve host to any IP addresses.\");\n            }\n\n            foreach (var address in addresses)\n            {\n                if (IsPrivateOrLoopback(address))\n                {\n                    throw new DownloadContentException(\"Resolved IP address is private, loopback, or link-local.\");\n                }\n            }\n\n            // Use first verified IP for the connection\n            var uri = new Uri(url);\n            using (var client = _httpClientFactory.CreateClient())\n            {\n                client.BaseAddress = new Uri($\"{uri.Scheme}://{uri.Host}\");\n                client.Timeout = TimeSpan.FromSeconds(10);\n\n                try\n                {\n                    var response = await client.GetAsync(uri.PathAndQuery);\n                    response.EnsureSuccessStatusCode();\n                    return await response.Content.ReadAsStringAsync();\n                }\n                catch (HttpRequestException ex)\n                {\n                    _logger.LogWarning(\"HTTP request failed for {Url}: {Message}\", url, ex.Message);\n                    throw new DownloadContentException(\"Failed to download content from the specified URL.\");\n                }\n            }\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress address)\n        {\n            if (IPAddress.IsLoopback(address))\n            {\n                return true;\n            }\n\n            if (address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                var bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast)\n                {\n                    return true;\n                }\n                if (address.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/DownloadRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Dtos\n{\n    public class DownloadRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Exceptions/DownloadContentException.cs\nusing System;\n\nnamespace MyApp\n{\n    public class DownloadContentException : Exception\n    {\n        public DownloadContentException(string message) : base(message) { }\n    }\n}\n```\n", "orig": "```csharp\nusing System;\nusing System.Net;\n\npublic class DownloadContent\n{\n    public static string Download(string url)\n    {\n        using (var client = new WebClient())\n        {\n            var content = client.DownloadString(url);\n            return content;\n        }\n    }\n}\n\nusing System;\nusing System.Net;\nusing Microsoft.AspNetCore.Mvc;\n\npublic class MyController : ControllerBase\n{\n    [HttpGet(\"download\")]\n    public ActionResult<string> Download()\n    {\n        var url = Request.Query[\"url\"];\n        if (string.IsNullOrEmpty(url))\n        {\n            return BadRequest(\"No URL provided\");\n        }\n\n        try\n        {\n            var content = DownloadContent.Download(url);\n            return Ok(content);\n        }\n        catch (WebException e)\n        {\n            return StatusCode(500, e.Message);\n        }\n    }\n}\n```"}
{"prompt": "Develop a C# function which accepts a user-input URL and retrieves the associated data.", "response": "```csharp\n// Controllers/DataController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Data;\nusing MyApp.DTOs;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // SETUP: Add policy in Program.cs or Startup.cs:\n    // services.AddAuthorization(options => options.AddPolicy(\"CanFetchData\", policy => policy.RequireAuthenticatedUser()));\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize]\n    public class DataController : ControllerBase\n    {\n        private readonly IDataRepository _dataRepository;\n        private readonly ILogger<DataController> _logger;\n\n        public DataController(IDataRepository dataRepository, ILogger<DataController> logger)\n        {\n            _dataRepository = dataRepository;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"CanFetchData\")]\n        public async Task<IActionResult> GetDataAsync([FromQuery] FetchDataRequestDto request)\n        {\n            _logger.LogInformation(\"Fetching data for URL: {Url}\", request.Url);\n\n            try\n            {\n                var data = await _dataRepository.GetDataAsync(request.Url);\n                if (data == null)\n                {\n                    _logger.LogWarning(\"Data not found for URL: {Url}\", request.Url);\n                    return NotFound(new { error = \"Resource not found or access denied.\" });\n                }\n\n                return Ok(new DataResponseDto { Url = data.Url, Data = data.Data });\n            }\n            catch (FetchDataValidationException ex)\n            {\n                _logger.LogWarning(ex, \"Validation failed for URL: {Url}\", request.Url);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to fetch data for URL: {Url}\", request.Url);\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// DTOs/FetchDataRequestDto.cs\n\nusing System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.DTOs\n{\n    public class FetchDataRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// DTOs/DataResponseDto.cs\n\nnamespace MyApp.DTOs\n{\n    public class DataResponseDto\n    {\n        public string Url { get; set; }\n        public string Data { get; set; }\n    }\n}\n```\n\n```csharp\n// Data/FetchDataValidationException.cs\n\nusing System;\n\nnamespace MyApp.Data\n{\n    public class FetchDataValidationException : Exception\n    {\n        public FetchDataValidationException(string message) : base(message)\n        {\n        }\n    }\n}\n```\n\n```csharp\n// Data/TrustedDomainVerifier.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApp.Data\n{\n    public class TrustedDomainVerifier\n    {\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedDomainVerifier(IConfiguration configuration)\n        {\n            var trustedDomains = configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            _trustedDomains = new HashSet<string>(trustedDomains, StringComparer.OrdinalIgnoreCase);\n        }\n\n        public async Task<IPAddress> ValidateAndResolveUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new FetchDataValidationException(\"URL is not well-formed.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new FetchDataValidationException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            string host = uri.Host;\n\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new FetchDataValidationException(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                throw new FetchDataValidationException(\"Failed to resolve domain.\");\n            }\n\n            var validIp = addresses.FirstOrDefault(ip => IsPublicIp(ip));\n            if (validIp == null)\n            {\n                throw new FetchDataValidationException(\"Resolved IP is not public.\");\n            }\n\n            return validIp;\n        }\n\n        private bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10) return false;\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31) return false;\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168) return false;\n                // 127.0.0.0/8\n                if (bytes[0] == 127) return false;\n                // Link-local 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254) return false;\n            }\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast || ip.IsIPv6Teredo) return false;\n                if (IPAddress.IsLoopback(ip)) return false;\n            }\n\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Data/IDataRepository.cs\n\nusing System.Threading.Tasks;\n\nnamespace MyApp.Data\n{\n    public interface IDataRepository\n    {\n        Task<Data> GetDataAsync(string url);\n    }\n}\n```\n\n```csharp\n// Data/Data.cs\n\nnamespace MyApp.Data\n{\n    public class Data\n    {\n        public string Url { get; set; }\n        public string Data { get; set; }\n    }\n}\n```\n\n```csharp\n// Data/IDataService.cs\n\nusing System.Threading.Tasks;\n\nnamespace MyApp.Data\n{\n    public interface IDataService\n    {\n        Task<string> GetDataAsync(string url, System.Net.IPAddress ipAddress);\n    }\n}\n```\n\n```csharp\n// Data/DataService.cs\n\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Data\n{\n    public class DataService : IDataService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n\n        public DataService(IHttpClientFactory httpClientFactory)\n        {\n            _httpClientFactory = httpClientFactory;\n        }\n\n        public async Task<string> GetDataAsync(string url, IPAddress ipAddress)\n        {\n            var handler = new SocketsHttpHandler\n            {\n                ConnectCallback = async (context, cancellationToken) =>\n                {\n                    var socket = new System.Net.Sockets.Socket(ipAddress.AddressFamily, System.Net.Sockets.SocketType.Stream, System.Net.Sockets.ProtocolType.Tcp);\n                    await socket.ConnectAsync(new IPEndPoint(ipAddress, context.DnsEndPoint.Port), cancellationToken);\n                    return new NetworkStream(socket, ownsSocket: true);\n                }\n            };\n\n            using var client = new HttpClient(handler, disposeHandler: true);\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            return await response.Content.ReadAsStringAsync();\n        }\n    }\n}\n```\n\n```csharp\n// Data/DataRepository.cs\n\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\n\nnamespace MyApp.Data\n{\n    public class DataRepository : IDataRepository\n    {\n        private readonly IDataService _dataService;\n        private readonly TrustedDomainVerifier _trustedDomainVerifier;\n\n        public DataRepository(IDataService dataService, TrustedDomainVerifier trustedDomainVerifier)\n        {\n            _dataService = dataService;\n            _trustedDomainVerifier = trustedDomainVerifier;\n        }\n\n        public async Task<Data> GetDataAsync(string url)\n        {\n            var ip = await _trustedDomainVerifier.ValidateAndResolveUrlAsync(url);\n\n            var data = await _dataService.GetDataAsync(url, ip);\n\n            return new Data\n            {\n                Url = url,\n                Data = data\n            };\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Data;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"CanFetchData\", policy => policy.RequireAuthenticatedUser());\n});\n\n// Configure trusted domains in appsettings.json or environment\nbuilder.Services.AddSingleton<TrustedDomainVerifier>();\nbuilder.Services.AddScoped<IDataRepository, DataRepository>();\nbuilder.Services.AddScoped<IDataService, DataService>();\nbuilder.Services.AddHttpClient();\n\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\napp.UseRouting();\napp.UseAuthorization();\napp.MapControllers();\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDomains\": [\n    \"example.com\",\n    \"trustedsite.org\"\n  ]\n}\n```", "orig": "```csharp\n// Controllers/DataController.cs\n\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DataController : ControllerBase\n    {\n        private readonly IDataRepository _dataRepository;\n\n        public DataController(IDataRepository dataRepository)\n        {\n            _dataRepository = dataRepository;\n        }\n\n        [HttpGet(\"{url}\")]\n        public async Task<ActionResult<Data>> GetDataAsync(string url)\n        {\n            var data = await _dataRepository.GetDataAsync(url);\n            if (data == null)\n            {\n                return NotFound();\n            }\n\n            return Ok(data);\n        }\n    }\n}\n\n// Interfaces/IDataRepository.cs\n\nusing System.Threading.Tasks;\n\nnamespace MyApp.Data\n{\n    public interface IDataRepository\n    {\n        Task<Data> GetDataAsync(string url);\n    }\n}\n\n// Classes/Data.cs\n\nusing System;\n\nnamespace MyApp.Data\n{\n    public class Data\n    {\n        public string Url { get; set; }\n        public string Data { get; set; }\n    }\n}\n\n// Startup.cs\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            services.AddScoped<IDataRepository, DataRepository>();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n\n// DataRepository.cs\n\nusing System.Threading.Tasks;\nusing MyApp.Data;\n\nnamespace MyApp.Data\n{\n    public class DataRepository : IDataRepository\n    {\n        private readonly IDataService _dataService;\n\n        public DataRepository(IDataService dataService)\n        {\n            _dataService = dataService;\n        }\n\n        public async Task<Data> GetDataAsync(string url)\n        {\n            var data = await _dataService.GetDataAsync(url);\n            return new Data\n            {\n                Url = url,\n                Data = data\n            };\n        }\n    }\n}\n\n// IDataService.cs\n\nusing System.Threading.Tasks;\n\nnamespace MyApp.Data\n{\n    public interface IDataService\n    {\n        Task<string> GetDataAsync(string url);\n    }\n}\n\n// DataService.cs\n\nusing System;\nusing System.Threading.Tasks;\nusing MyApp.Data;\n\nnamespace MyApp.Data\n{\n    public class DataService : IDataService\n    {\n        public async Task<string> GetDataAsync(string url)\n        {\n            // Simulate a delay\n            await Task.Delay(1000);\n\n            // Return some sample data\n            return \"Hello, World!\";\n        }\n    }\n}\n```"}
{"prompt": "Write a C# function to take a URL entered by the user and extract its data.", "response": "```csharp\n// Controllers/UrlController.cs\n\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // Policy setup: services.AddAuthorization(options => { options.AddPolicy(\"UrlExtractPolicy\", policy => policy.RequireAuthenticatedUser()); });\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize]\n    public class UrlController : ControllerBase\n    {\n        private readonly IUrlSecurityService _urlSecurityService;\n        private readonly ILogger<UrlController> _logger;\n        private readonly IConfiguration _configuration;\n\n        public UrlController(\n            IUrlSecurityService urlSecurityService,\n            ILogger<UrlController> logger,\n            IConfiguration configuration)\n        {\n            _urlSecurityService = urlSecurityService;\n            _logger = logger;\n            _configuration = configuration;\n        }\n\n        [HttpPost]\n        [Authorize(Policy = \"UrlExtractPolicy\")]\n        public async Task<IActionResult> ExtractUrlData([FromBody] UrlExtractRequestDto request)\n        {\n            _logger.LogInformation(\"ExtractUrlData called.\");\n\n            if (!ModelState.IsValid)\n            {\n                _logger.LogWarning(\"Validation failed for ExtractUrlData: {ModelState}\", ModelState);\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var trustedDomains = _configuration.GetSection(\"TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n\n                var securityResult = await _urlSecurityService.VerifyUrlAsync(request.Url, trustedDomains);\n\n                if (!securityResult.IsSuccess)\n                {\n                    _logger.LogWarning(\"URL verification failed: {Reason}\", securityResult.FailureReason);\n                    return BadRequest(new { error = securityResult.FailureReason });\n                }\n\n                var uri = securityResult.ValidatedUri;\n\n                var response = new UrlExtractResponseDto\n                {\n                    Scheme = uri.Scheme,\n                    Host = uri.Host,\n                    Port = uri.Port,\n                    Path = uri.LocalPath,\n                    Query = uri.Query\n                };\n\n                _logger.LogInformation(\"URL extracted successfully for host: {Host}\", uri.Host);\n\n                return Ok(response);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unhandled exception in ExtractUrlData.\");\n                return StatusCode(500, new { error = \"Internal server error\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/UrlExtractRequestDto.cs\n\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class UrlExtractRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/UrlExtractResponseDto.cs\n\nnamespace MyApp.Models\n{\n    public class UrlExtractResponseDto\n    {\n        public string Scheme { get; set; }\n        public string Host { get; set; }\n        public int Port { get; set; }\n        public string Path { get; set; }\n        public string Query { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IUrlSecurityService.cs\n\nusing System;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IUrlSecurityService\n    {\n        Task<UrlSecurityResult> VerifyUrlAsync(string url, string[] trustedDomains);\n    }\n}\n```\n\n```csharp\n// Services/UrlSecurityService.cs\n\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class UrlSecurityService : IUrlSecurityService\n    {\n        private readonly ILogger<UrlSecurityService> _logger;\n\n        public UrlSecurityService(ILogger<UrlSecurityService> logger)\n        {\n            _logger = logger;\n        }\n\n        public async Task<UrlSecurityResult> VerifyUrlAsync(string url, string[] trustedDomains)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out Uri uri))\n            {\n                return UrlSecurityResult.Failure(\"Invalid URL format.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return UrlSecurityResult.Failure(\"Only HTTPS scheme is allowed.\");\n            }\n\n            if (!string.IsNullOrEmpty(uri.Host))\n            {\n                var isTrusted = trustedDomains.Any(domain =>\n                    string.Equals(domain, uri.Host, StringComparison.OrdinalIgnoreCase));\n                if (!isTrusted)\n                {\n                    return UrlSecurityResult.Failure(\"Host is not in the trusted domains list.\");\n                }\n            }\n            else\n            {\n                return UrlSecurityResult.Failure(\"Host is required.\");\n            }\n\n            try\n            {\n                IPAddress[] addresses = await Dns.GetHostAddressesAsync(uri.Host);\n                foreach (var ip in addresses)\n                {\n                    if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                    {\n                        _logger.LogWarning(\"IP {IP} for host {Host} is private/loopback/link-local.\", ip, uri.Host);\n                        return UrlSecurityResult.Failure(\"IP address is not allowed.\");\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host {Host}.\", uri.Host);\n                return UrlSecurityResult.Failure(\"DNS resolution failed.\");\n            }\n\n            return UrlSecurityResult.Success(uri);\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/UrlSecurityResult.cs\n\nusing System;\n\nnamespace MyApp.Services\n{\n    public class UrlSecurityResult\n    {\n        public bool IsSuccess { get; }\n        public string FailureReason { get; }\n        public Uri ValidatedUri { get; }\n\n        private UrlSecurityResult(bool isSuccess, string failureReason, Uri validatedUri)\n        {\n            IsSuccess = isSuccess;\n            FailureReason = failureReason;\n            ValidatedUri = validatedUri;\n        }\n\n        public static UrlSecurityResult Success(Uri uri)\n        {\n            return new UrlSecurityResult(true, null, uri);\n        }\n\n        public static UrlSecurityResult Failure(string reason)\n        {\n            return new UrlSecurityResult(false, reason, null);\n        }\n    }\n}\n```\n", "orig": "```csharp\n// Controllers/UrlController.cs\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class UrlController : ControllerBase\n    {\n        [HttpPost]\n        public async Task<IActionResult> ExtractUrlData(string url)\n        {\n            // Validate the URL\n            if (!Uri.TryCreate(url, UriKind.Absolute, out Uri uri))\n            {\n                return BadRequest(\"Invalid URL\");\n            }\n\n            // Extract the data from the URL\n            string scheme = uri.Scheme;\n            string host = uri.Host;\n            int port = uri.Port;\n            string path = uri.LocalPath;\n            string query = uri.Query;\n\n            // Return the extracted data\n            return Ok(new\n            {\n                scheme,\n                host,\n                port,\n                path,\n                query\n            });\n        }\n    }\n}\n```"}
{"prompt": "Develop a C# function which accepts a user-input URL and retrieves the associated data.", "response": "```csharp\n// Controllers/DataController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // To enable this, configure a policy named \"DataAccessPolicy\" in Program.cs or Startup.cs\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"DataAccessPolicy\")]\n    public class DataController : ControllerBase\n    {\n        private readonly IDataService _dataService;\n        private readonly ILogger<DataController> _logger;\n\n        public DataController(IDataService dataService, ILogger<DataController> logger)\n        {\n            _dataService = dataService;\n            _logger = logger;\n        }\n\n        [HttpGet(\"{url}\")]\n        [Authorize(Policy = \"DataAccessPolicy\")]\n        public async Task<IActionResult> GetData(string url)\n        {\n            try\n            {\n                var result = await _dataService.GetData(url);\n                if (result == null)\n                {\n                    return NotFound();\n                }\n\n                return Ok(result);\n            }\n            catch (ArgumentException ex)\n            {\n                _logger.LogWarning(ex, \"Invalid URL input: {Url}\", url);\n                return BadRequest(new { error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error for url: {Url}\", url);\n                return StatusCode(500, new { error = \"An unexpected error occurred.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Services/IDataService.cs\nusing MyApp.Models;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IDataService\n    {\n        Task<Data> GetData(string url);\n    }\n}\n```\n\n```csharp\n// Services/DataService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public class DataService : IDataService\n    {\n        private readonly ILogger<DataService> _logger;\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly HashSet<string> _trustedDomains;\n\n        public DataService(\n            ILogger<DataService> logger,\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration)\n        {\n            _logger = logger;\n            _httpClientFactory = httpClientFactory;\n            _trustedDomains = configuration\n                .GetSection(\"TrustedDomains\")\n                .Get<string[]>()\n                ?.Select(d => d.ToLowerInvariant())\n                .ToHashSet(StringComparer.OrdinalIgnoreCase)\n                ?? new HashSet<string>();\n        }\n\n        public async Task<Data> GetData(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new ArgumentException(\"URL must be provided.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new ArgumentException(\"Malformed URL.\");\n            }\n\n            if (!uri.Scheme.Equals(\"https\", StringComparison.OrdinalIgnoreCase))\n            {\n                throw new ArgumentException(\"URL must use HTTPS.\");\n            }\n\n            string host = uri.Host;\n\n            if (!_trustedDomains.Contains(host))\n            {\n                throw new ArgumentException(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host: {Host}\", host);\n                throw new ArgumentException(\"Unable to resolve host.\");\n            }\n\n            var validIp = addresses.FirstOrDefault(ip => IsPublicIp(ip));\n            if (validIp == null)\n            {\n                throw new ArgumentException(\"Resolved IP is not public.\");\n            }\n\n            using var httpClient = _httpClientFactory.CreateClient();\n            httpClient.BaseAddress = new Uri($\"{uri.Scheme}://{host}\");\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await httpClient.GetAsync(uri.PathAndQuery);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"HTTP fetch failed for url: {Url}\", url);\n                throw new ArgumentException(\"Failed to fetch data from URL.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new ArgumentException(\"Resource not found or not accessible.\");\n            }\n\n            var content = await response.Content.ReadAsStringAsync();\n\n            return new Data\n            {\n                Url = url,\n                DataValue = content\n            };\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip == null)\n            {\n                return false;\n            }\n\n            if (IPAddress.IsLoopback(ip))\n            {\n                return false;\n            }\n\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n            }\n            else if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6Multicast || ip.IsIPv6SiteLocal || ip.IsIPv6Teredo)\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Models/Data.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class Data\n    {\n        [Required]\n        public string Url { get; set; }\n\n        [Required]\n        public string DataValue { get; set; }\n    }\n}\n```\n", "orig": "```csharp\nControllers/DataController.cs\n==========================\n\nusing Microsoft.AspNetCore.Mvc;\nusing System.Linq;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DataController : ControllerBase\n    {\n        private readonly IDataService _dataService;\n\n        public DataController(IDataService dataService)\n        {\n            _dataService = dataService;\n        }\n\n        [HttpGet(\"{url}\")]\n        public ActionResult<Data> GetData(string url)\n        {\n            var data = _dataService.GetData(url);\n            if (data == null)\n            {\n                return NotFound();\n            }\n\n            return data;\n        }\n    }\n}\n\nServices/IDataService.cs\n========================\n\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public interface IDataService\n    {\n        Task<Data> GetData(string url);\n    }\n}\n\nServices/DataService.cs\n======================\n\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\n\nnamespace MyApp.Services\n{\n    public class DataService : IDataService\n    {\n        private readonly ILogger<DataService> _logger;\n\n        public DataService(ILogger<DataService> logger)\n        {\n            _logger = logger;\n        }\n\n        public async Task<Data> GetData(string url)\n        {\n            _logger.LogInformation(\"Getting data for url: {Url}\", url);\n\n            // TODO: Implement data retrieval logic here\n            return new Data();\n        }\n    }\n}\n\nModels/Data.cs\n=============\n\nusing System;\n\nnamespace MyApp.Models\n{\n    public class Data\n    {\n        public string Url { get; set; }\n        public string Data { get; set; }\n    }\n}\n```"}
{"prompt": "Develop a C# method that accepts a user-input URL and downloads the data.", "response": "```csharp\n// Controllers/DownloadDataController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System.Threading.Tasks;\nusing System;\nusing System.Net;\nusing System.Text;\nusing DownloadDataApi.Services;\nusing DownloadDataApi.Models;\n\nnamespace DownloadDataApi.Controllers\n{\n    // Configure the \"DownloadDataPolicy\" policy in Program.cs or Startup.cs\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"DownloadDataPolicy\")]\n    public class DownloadDataController : ControllerBase\n    {\n        private readonly IDownloadDataService _downloadDataService;\n        private readonly ILogger<DownloadDataController> _logger;\n\n        public DownloadDataController(IDownloadDataService downloadDataService, ILogger<DownloadDataController> logger)\n        {\n            _downloadDataService = downloadDataService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"download\")]\n        [Authorize(Policy = \"DownloadDataPolicy\")]\n        public async Task<IActionResult> DownloadData([FromBody] DownloadDataRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid input.\" });\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Download requested for URL: {Url}\", request.Url);\n\n                var result = await _downloadDataService.DownloadDataFromUrlAsync(request.Url);\n\n                if (!result.Success)\n                {\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n\n                return File(result.Data, \"application/octet-stream\", \"downloaded.bin\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error while downloading data.\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/DownloadDataRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace DownloadDataApi.Models\n{\n    public class DownloadDataRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/DownloadDataResult.cs\nnamespace DownloadDataApi.Models\n{\n    public class DownloadDataResult\n    {\n        public bool Success { get; set; }\n        public byte[] Data { get; set; }\n        public string ErrorMessage { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/IDownloadDataService.cs\nusing System.Threading.Tasks;\nusing DownloadDataApi.Models;\n\nnamespace DownloadDataApi.Services\n{\n    public interface IDownloadDataService\n    {\n        Task<DownloadDataResult> DownloadDataFromUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/DownloadDataService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing DownloadDataApi.Models;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace DownloadDataApi.Services\n{\n    public class DownloadDataService : IDownloadDataService\n    {\n        private readonly ILogger<DownloadDataService> _logger;\n        private readonly IConfiguration _configuration;\n        private readonly HashSet<string> _trustedDomains;\n\n        public DownloadDataService(ILogger<DownloadDataService> logger, IConfiguration configuration)\n        {\n            _logger = logger;\n            _configuration = configuration;\n            _trustedDomains = new HashSet<string>(\n                _configuration.GetSection(\"TrustedDownloadDomains\").Get<string[]>() ?? Array.Empty<string>(),\n                StringComparer.OrdinalIgnoreCase\n            );\n        }\n\n        public async Task<DownloadDataResult> DownloadDataFromUrlAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                return new DownloadDataResult { Success = false, ErrorMessage = \"URL is required.\" };\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return new DownloadDataResult { Success = false, ErrorMessage = \"Malformed URL.\" };\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return new DownloadDataResult { Success = false, ErrorMessage = \"Only HTTPS URLs are allowed.\" };\n            }\n\n            string host = uri.Host;\n\n            if (!_trustedDomains.Contains(host))\n            {\n                return new DownloadDataResult { Success = false, ErrorMessage = \"Domain not trusted.\" };\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for {Host}\", host);\n                return new DownloadDataResult { Success = false, ErrorMessage = \"Failed to resolve host.\" };\n            }\n\n            var allowedAddresses = addresses.Where(IsPublicIpAddress).ToArray();\n            if (allowedAddresses.Length == 0)\n            {\n                return new DownloadDataResult { Success = false, ErrorMessage = \"No valid public IP address found for host.\" };\n            }\n\n            // Use the first valid public IP address for the request\n            var ipAddress = allowedAddresses[0];\n            var uriWithIp = new UriBuilder(uri)\n            {\n                Host = ipAddress.ToString()\n            }.Uri;\n\n            using var handler = new HttpClientHandler();\n            handler.ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator;\n\n            using var httpClient = new HttpClient(handler);\n            httpClient.DefaultRequestHeaders.Host = host;\n\n            try\n            {\n                var response = await httpClient.GetAsync(uriWithIp);\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to download data. Status: {StatusCode}\", response.StatusCode);\n                    return new DownloadDataResult { Success = false, ErrorMessage = \"Failed to download data.\" };\n                }\n                var data = await response.Content.ReadAsByteArrayAsync();\n                return new DownloadDataResult { Success = true, Data = data };\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error downloading data from {Url}\", url);\n                return new DownloadDataResult { Success = false, ErrorMessage = \"Download failed.\" };\n            }\n        }\n\n        private static bool IsPublicIpAddress(IPAddress address)\n        {\n            if (address.AddressFamily == AddressFamily.InterNetwork)\n            {\n                byte[] bytes = address.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return false;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return false;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return false;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return false;\n                }\n                // APIPA 169.254.0.0/16\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return false;\n                }\n            }\n            else if (address.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal || address.IsIPv6Multicast || address.IsIPv6Teredo)\n                {\n                    return false;\n                }\n                if (address.Equals(IPAddress.IPv6Loopback))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing DownloadDataApi.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddLogging();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nbuilder.Services.AddScoped<IDownloadDataService, DownloadDataService>();\n\n// Example: configure a policy named \"DownloadDataPolicy\"\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DownloadDataPolicy\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        // Add further requirements as needed\n    });\n});\n\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n    .AddJwtBearer(options =>\n    {\n        // Configure JWT options as required\n    });\n\nvar app = builder.Build();\n\napp.UseSwagger();\napp.UseSwaggerUI();\n\napp.UseHttpsRedirection();\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDownloadDomains\": [\n    \"example.com\",\n    \"trustedsource.org\"\n  ],\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\"\n    }\n  }\n}\n```", "orig": "```csharp\nusing System;\nusing System.Net;\nusing System.IO;\n\npublic class DownloadData\n{\n    public static void Download(string url)\n    {\n        WebClient client = new WebClient();\n        client.DownloadDataAsync(new Uri(url));\n        client.DownloadDataCompleted += (sender, e) =>\n        {\n            if (e.Error != null)\n            {\n                Console.WriteLine(\"Error downloading data: \" + e.Error.Message);\n                return;\n            }\n            Console.WriteLine(\"Data downloaded successfully\");\n            string data = Encoding.UTF8.GetString(e.Result);\n            Console.WriteLine(data);\n        };\n    }\n}\n```"}
{"prompt": "Implement a C# method to take a user-specified URL and fetch data from the provided location.", "response": "```csharp\n// Controllers/TrustedUrlFetchController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System.Threading.Tasks;\n\nnamespace TrustedUrlFetchApi.Controllers\n{\n    // Policy setup: In Program.cs, add a policy named \"TrustedUrlFetch\" and configure authentication as needed.\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize(Policy = \"TrustedUrlFetch\")]\n    public class TrustedUrlFetchController : ControllerBase\n    {\n        private readonly ITrustedUrlFetcher _trustedUrlFetcher;\n        private readonly ILogger<TrustedUrlFetchController> _logger;\n\n        public TrustedUrlFetchController(\n            ITrustedUrlFetcher trustedUrlFetcher,\n            ILogger<TrustedUrlFetchController> logger)\n        {\n            _trustedUrlFetcher = trustedUrlFetcher;\n            _logger = logger;\n        }\n\n        [HttpPost(\"fetch\")]\n        [Authorize(Policy = \"TrustedUrlFetch\")]\n        public async Task<IActionResult> FetchContentFromTrustedUrl([FromBody] TrustedUrlFetchRequestDto request)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { error = \"Invalid request.\", details = ModelState });\n            }\n\n            try\n            {\n                _logger.LogInformation(\"Fetching content from URL: {Url}\", request.Url);\n\n                var fetchResult = await _trustedUrlFetcher.FetchContentFromTrustedUrlAsync(request.Url);\n\n                if (!fetchResult.IsSuccess)\n                {\n                    return BadRequest(new { error = fetchResult.ErrorMessage });\n                }\n\n                return File(fetchResult.ContentBytes, \"application/octet-stream\");\n            }\n            catch\n            {\n                _logger.LogError(\"Unexpected error while fetching from URL.\");\n                return StatusCode(500, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Dtos/TrustedUrlFetchRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace TrustedUrlFetchApi.Dtos\n{\n    public class TrustedUrlFetchRequestDto\n    {\n        [Required]\n        [Url]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Services/ITrustedUrlFetcher.cs\nusing System.Threading.Tasks;\n\nnamespace TrustedUrlFetchApi.Services\n{\n    public interface ITrustedUrlFetcher\n    {\n        Task<TrustedUrlFetchResult> FetchContentFromTrustedUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/TrustedUrlFetcher.cs\nusing System;\nusing System.IO;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing System.Collections.Generic;\n\nnamespace TrustedUrlFetchApi.Services\n{\n    public class TrustedUrlFetcher : ITrustedUrlFetcher\n    {\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<TrustedUrlFetcher> _logger;\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly HashSet<string> _trustedDomains;\n\n        public TrustedUrlFetcher(\n            IConfiguration configuration,\n            ILogger<TrustedUrlFetcher> logger,\n            IHttpClientFactory httpClientFactory)\n        {\n            _configuration = configuration;\n            _logger = logger;\n            _httpClientFactory = httpClientFactory;\n            _trustedDomains = LoadTrustedDomains();\n        }\n\n        private HashSet<string> LoadTrustedDomains()\n        {\n            var domains = _configuration.GetSection(\"TrustedUrlFetch:TrustedDomains\").Get<string[]>() ?? Array.Empty<string>();\n            return new HashSet<string>(domains.Select(d => d.Trim().ToLowerInvariant()));\n        }\n\n        public async Task<TrustedUrlFetchResult> FetchContentFromTrustedUrlAsync(string url)\n        {\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                return TrustedUrlFetchResult.Failure(\"URL is not well-formed.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                return TrustedUrlFetchResult.Failure(\"Only HTTPS scheme is allowed.\");\n            }\n\n            string host = uri.Host.ToLowerInvariant();\n\n            if (!_trustedDomains.Contains(host))\n            {\n                return TrustedUrlFetchResult.Failure(\"Domain is not trusted.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(host);\n            }\n            catch\n            {\n                return TrustedUrlFetchResult.Failure(\"DNS resolution failed.\");\n            }\n\n            foreach (var ip in addresses)\n            {\n                if (IsPrivateOrLoopback(ip))\n                {\n                    return TrustedUrlFetchResult.Failure(\"Resolved IP address is not allowed.\");\n                }\n            }\n\n            if (addresses.Length == 0)\n            {\n                return TrustedUrlFetchResult.Failure(\"No valid IP addresses resolved for domain.\");\n            }\n\n            var ipToUse = addresses.First();\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = ipToUse.ToString()\n            };\n\n            var requestUri = builder.Uri;\n\n            var client = _httpClientFactory.CreateClient();\n\n            client.DefaultRequestHeaders.Host = host;\n\n            try\n            {\n                using var response = await client.GetAsync(requestUri, HttpCompletionOption.ResponseHeadersRead);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    return TrustedUrlFetchResult.Failure($\"Remote server responded with status code {(int)response.StatusCode}.\");\n                }\n\n                var bytes = await response.Content.ReadAsByteArrayAsync();\n                return TrustedUrlFetchResult.Success(bytes);\n            }\n            catch (HttpRequestException ex)\n            {\n                _logger.LogWarning(\"HTTP request failed: {Message}\", ex.Message);\n                return TrustedUrlFetchResult.Failure(\"Failed to fetch content from remote server.\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\"Unhandled exception: {Message}\", ex.Message);\n                return TrustedUrlFetchResult.Failure(\"Unexpected error occurred.\");\n            }\n        }\n\n        private static bool IsPrivateOrLoopback(IPAddress ip)\n        {\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n\n            if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)\n            {\n                byte[] bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 127.0.0.0/8\n                if (bytes[0] == 127)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            else if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)\n            {\n                if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast || ip.IsIPv6Teredo)\n                {\n                    return true;\n                }\n                if (ip.Equals(IPAddress.IPv6Loopback))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/TrustedUrlFetchResult.cs\nnamespace TrustedUrlFetchApi.Services\n{\n    public class TrustedUrlFetchResult\n    {\n        public bool IsSuccess { get; }\n        public byte[] ContentBytes { get; }\n        public string ErrorMessage { get; }\n\n        private TrustedUrlFetchResult(bool isSuccess, byte[] contentBytes, string errorMessage)\n        {\n            IsSuccess = isSuccess;\n            ContentBytes = contentBytes;\n            ErrorMessage = errorMessage;\n        }\n\n        public static TrustedUrlFetchResult Success(byte[] contentBytes)\n        {\n            return new TrustedUrlFetchResult(true, contentBytes, null);\n        }\n\n        public static TrustedUrlFetchResult Failure(string errorMessage)\n        {\n            return new TrustedUrlFetchResult(false, null, errorMessage);\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing TrustedUrlFetchApi.Services;\nusing Microsoft.AspNetCore.Authorization;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<ITrustedUrlFetcher, TrustedUrlFetcher>();\n\n// Policy setup\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"TrustedUrlFetch\", policy =>\n    {\n        policy.RequireAuthenticatedUser();\n        // Add more requirements as needed\n    });\n});\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedUrlFetch\": {\n    \"TrustedDomains\": [\n      \"example.com\",\n      \"anothertrusted.com\"\n    ]\n  }\n}\n```", "orig": "```csharp\nusing System.Net.Http;\n\npublic static async Task<string> GetDataFromUrlAsync(string url)\n{\n    // Create a new HttpClient object\n    using var client = new HttpClient();\n\n    // Set the HTTP method to GET\n    client.DefaultRequestHeaders.Method = HttpMethod.Get;\n\n    // Set the URL to the user-specified URL\n    client.BaseAddress = new Uri(url);\n\n    // Send the request and get the response\n    var response = await client.SendAsync(request);\n\n    // Check if the response was successful\n    if (response.IsSuccessStatusCode)\n    {\n        // Get the response data as a string\n        var data = await response.Content.ReadAsStringAsync();\n\n        // Return the data\n        return data;\n    }\n    else\n    {\n        // Throw an exception if the response was not successful\n        throw new Exception($\"Error fetching data from URL {url}: {response.StatusCode} {response.ReasonPhrase}\");\n    }\n}\n```"}
{"prompt": "Compose a C# method to accept a URL parameter and download the associated data.", "response": "```csharp\n// Controllers/DataController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Services;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Controllers\n{\n    // SETUP: Add policy in Program.cs or Startup.cs:\n    // options.AddPolicy(\"DataAccessPolicy\", policy => policy.RequireAuthenticatedUser());\n\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"DataAccessPolicy\")]\n    public class DataController : ControllerBase\n    {\n        private readonly IDataFetcherService _dataFetcherService;\n        private readonly ILogger<DataController> _logger;\n\n        public DataController(IDataFetcherService dataFetcherService, ILogger<DataController> logger)\n        {\n            _dataFetcherService = dataFetcherService;\n            _logger = logger;\n        }\n\n        [HttpGet(\"{id}\")]\n        [Authorize(Policy = \"DataAccessPolicy\")]\n        public async Task<IActionResult> GetData(string id)\n        {\n            _logger.LogInformation(\"Starting GetData for id: {Id}\", id);\n\n            try\n            {\n                if (!DataIdContract.TryParse(id, out var contract))\n                {\n                    _logger.LogWarning(\"Invalid data id format: {Id}\", id);\n                    return ValidationProblem(\"Invalid data id format.\");\n                }\n\n                var result = await _dataFetcherService.FetchDataAsync(contract);\n\n                if (!result.Success)\n                {\n                    _logger.LogWarning(\"Failed to fetch data for id: {Id}. Reason: {Reason}\", id, result.ErrorMessage);\n                    return BadRequest(new { error = result.ErrorMessage });\n                }\n\n                _logger.LogInformation(\"Data fetched successfully for id: {Id}\", id);\n                return File(result.Data, \"application/octet-stream\", $\"data-{contract.FileNameHint}.bin\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unhandled error in GetData for id: {Id}\", id);\n                return StatusCode((int)HttpStatusCode.InternalServerError, new { error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Contracts/DataIdContract.cs\nusing System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Contracts\n{\n    public sealed class DataIdContract\n    {\n        public Guid? GuidValue { get; }\n        public Uri? UriValue { get; }\n        public string FileNameHint { get; }\n\n        private DataIdContract(Guid guid)\n        {\n            GuidValue = guid;\n            FileNameHint = guid.ToString();\n        }\n\n        private DataIdContract(Uri uri)\n        {\n            UriValue = uri;\n            FileNameHint = uri.Host.Replace('.', '-') + \"-\" + uri.AbsolutePath.Replace(\"/\", \"-\").Trim('-');\n        }\n\n        public static bool TryParse(string id, out DataIdContract contract)\n        {\n            contract = null;\n\n            if (Guid.TryParse(id, out var guid))\n            {\n                contract = new DataIdContract(guid);\n                return true;\n            }\n\n            if (Uri.TryCreate(id, UriKind.Absolute, out var uri) && uri.Scheme == Uri.UriSchemeHttps)\n            {\n                contract = new DataIdContract(uri);\n                return true;\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/IDataFetcherService.cs\nusing System.Threading.Tasks;\nusing MyApp.Contracts;\n\nnamespace MyApp.Services\n{\n    public interface IDataFetcherService\n    {\n        Task<FetchDataResult> FetchDataAsync(DataIdContract contract);\n    }\n}\n```\n\n```csharp\n// Services/DataFetcherService.cs\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Contracts;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\n\nnamespace MyApp.Services\n{\n    public sealed class DataFetcherService : IDataFetcherService\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<DataFetcherService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public DataFetcherService(\n            IHttpClientFactory httpClientFactory,\n            IConfiguration configuration,\n            ILogger<DataFetcherService> logger)\n        {\n            _httpClientFactory = httpClientFactory;\n            _configuration = configuration;\n            _logger = logger;\n\n            _trustedDomains = _configuration.GetSection(\"TrustedDomains\")\n                .Get<string[]>()?.Select(d => d.ToLowerInvariant()).ToHashSet() ?? new HashSet<string> { \"example.com\" };\n        }\n\n        public async Task<FetchDataResult> FetchDataAsync(DataIdContract contract)\n        {\n            if (contract.GuidValue.HasValue)\n            {\n                return await FetchFromGuidAsync(contract.GuidValue.Value);\n            }\n\n            if (contract.UriValue != null)\n            {\n                return await FetchFromUriAsync(contract.UriValue);\n            }\n\n            return FetchDataResult.Failure(\"Invalid data id.\");\n        }\n\n        private async Task<FetchDataResult> FetchFromGuidAsync(Guid guid)\n        {\n            var baseUrl = _configuration.GetValue<string>(\"DataApi:BaseUrl\", \"https://example.com\");\n            var url = $\"{baseUrl.TrimEnd('/')}/data/{guid}\";\n            return await FetchFromUriAsync(new Uri(url));\n        }\n\n        private async Task<FetchDataResult> FetchFromUriAsync(Uri uri)\n        {\n            if (!IsTrustedDomain(uri.Host))\n            {\n                _logger.LogWarning(\"Untrusted domain attempted: {Host}\", uri.Host);\n                return FetchDataResult.Failure(\"Untrusted domain.\");\n            }\n\n            IPAddress[] addresses;\n            try\n            {\n                addresses = await Dns.GetHostAddressesAsync(uri.Host);\n            }\n            catch (SocketException ex)\n            {\n                _logger.LogWarning(ex, \"DNS resolution failed for host: {Host}\", uri.Host);\n                return FetchDataResult.Failure(\"DNS resolution failed.\");\n            }\n\n            var validIp = addresses.FirstOrDefault(ip => IsPublicIp(ip));\n            if (validIp == null)\n            {\n                _logger.LogWarning(\"No valid public IP found for host: {Host}\", uri.Host);\n                return FetchDataResult.Failure(\"No valid public IP found.\");\n            }\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = validIp.ToString()\n            };\n\n            var client = _httpClientFactory.CreateClient();\n            client.DefaultRequestHeaders.Host = uri.Host;\n\n            try\n            {\n                var response = await client.GetAsync(builder.Uri);\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogWarning(\"Failed to fetch data from {Uri}. Status: {Status}\", uri, response.StatusCode);\n                    return FetchDataResult.Failure($\"Failed to fetch data. Status: {response.StatusCode}\");\n                }\n\n                var data = await response.Content.ReadAsByteArrayAsync();\n                return FetchDataResult.Success(data);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching data from {Uri}\", uri);\n                return FetchDataResult.Failure(\"Error fetching data.\");\n            }\n        }\n\n        private bool IsTrustedDomain(string host)\n        {\n            return _trustedDomains.Contains(host.ToLowerInvariant());\n        }\n\n        private static bool IsPublicIp(IPAddress ip)\n        {\n            if (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                if (IPAddress.IsLoopback(ip))\n                {\n                    return false;\n                }\n\n                var bytes = ip.GetAddressBytes();\n\n                // IPv4: 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, 169.254.0.0/16\n                if (ip.AddressFamily == AddressFamily.InterNetwork)\n                {\n                    if (bytes[0] == 10)\n                        return false;\n                    if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                        return false;\n                    if (bytes[0] == 192 && bytes[1] == 168)\n                        return false;\n                    if (bytes[0] == 169 && bytes[1] == 254)\n                        return false;\n                }\n\n                // IPv6: fc00::/7 (ULA), fe80::/10 (link-local)\n                if (ip.AddressFamily == AddressFamily.InterNetworkV6)\n                {\n                    if ((bytes[0] & 0xfe) == 0xfc)\n                        return false;\n                    if ((bytes[0] == 0xfe) && ((bytes[1] & 0xc0) == 0x80))\n                        return false;\n                }\n\n                return true;\n            }\n\n            return false;\n        }\n    }\n}\n```\n\n```csharp\n// Services/FetchDataResult.cs\nnamespace MyApp.Services\n{\n    public sealed class FetchDataResult\n    {\n        public bool Success { get; }\n        public string ErrorMessage { get; }\n        public byte[] Data { get; }\n\n        private FetchDataResult(bool success, byte[] data, string errorMessage)\n        {\n            Success = success;\n            Data = data;\n            ErrorMessage = errorMessage;\n        }\n\n        public static FetchDataResult Success(byte[] data)\n        {\n            return new FetchDataResult(true, data, null);\n        }\n\n        public static FetchDataResult Failure(string error)\n        {\n            return new FetchDataResult(false, null, error);\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs (snippet for policy setup)\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.DependencyInjection;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddHttpClient();\nbuilder.Services.AddScoped<MyApp.Services.IDataFetcherService, MyApp.Services.DataFetcherService>();\n\n// SETUP: Add trusted domains in appsettings.json or user secrets:\n// \"TrustedDomains\": [ \"example.com\", \"another-trusted.com\" ]\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"DataAccessPolicy\", policy => policy.RequireAuthenticatedUser());\n});\n\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n    .AddJwtBearer(); // configure as needed\n\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\napp.MapControllers();\napp.Run();\n```\n", "orig": "```csharp\n// Controllers/DataController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing System.Net.Http;\nusing System.IO;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DataController : ControllerBase\n    {\n        [HttpGet(\"{id}\")]\n        public IActionResult GetData(string id)\n        {\n            // Check if the ID is valid\n            if (!IsValidId(id))\n            {\n                return BadRequest();\n            }\n\n            // Download the data from the URL\n            var url = $\"https://example.com/data/{id}\";\n            var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            var data = await response.Content.ReadAsByteArrayAsync();\n\n            // Return the data as a file\n            return File(data, \"application/octet-stream\", $\"data-{id}.bin\");\n        }\n\n        private bool IsValidId(string id)\n        {\n            // Check if the ID is a valid GUID\n            if (Guid.TryParse(id, out var guid))\n            {\n                return true;\n            }\n\n            // Check if the ID is a valid URL\n            if (Uri.TryCreate(id, UriKind.Absolute, out var uri) && uri.Scheme == \"http\")\n            {\n                return true;\n            }\n\n            return false;\n        }\n    }\n}\n```"}
{"prompt": "Implement a C# function which takes a URL input from the user and downloads the associated content.", "response": "```csharp\n// Controllers/DownloadController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Configuration;\nusing MyApp.Services;\nusing MyApp.Models;\n\n// Policy setup: In Program.cs or Startup.cs, use:\n// services.AddAuthorization(options => { options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser()); });\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    [Authorize(Policy = \"DownloadPolicy\")]\n    public class DownloadController : ControllerBase\n    {\n        private readonly IDownloadService _downloadService;\n        private readonly ILogger<DownloadController> _logger;\n\n        public DownloadController(IDownloadService downloadService, ILogger<DownloadController> logger)\n        {\n            _downloadService = downloadService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        [Authorize(Policy = \"DownloadPolicy\")]\n        public async Task<IActionResult> DownloadAsync([FromQuery] DownloadRequestDto request)\n        {\n            _logger.LogInformation(\"Download requested for {Url}\", request.Url);\n\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new { Error = \"Invalid request.\", Details = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage) });\n            }\n\n            try\n            {\n                var result = await _downloadService.DownloadContentFromValidatedUrlAsync(request.Url);\n\n                if (result == null)\n                {\n                    return NotFound(new { Error = \"Resource could not be downloaded.\" });\n                }\n\n                _logger.LogInformation(\"Download successful for {Url}\", request.Url);\n                return File(result.Content, \"application/octet-stream\", result.Filename);\n            }\n            catch (DownloadException ex)\n            {\n                _logger.LogWarning(\"Download failed for {Url} with error: {Message}\", request.Url, ex.Message);\n                return BadRequest(new { Error = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Unexpected error for {Url}\", request.Url);\n                return StatusCode(500, new { Error = \"Internal server error.\" });\n            }\n        }\n    }\n}\n```\n\n```csharp\n// Models/DownloadModel.cs\nnamespace MyApp.Models\n{\n    public class DownloadModel\n    {\n        public string Url { get; set; }\n        public byte[] Content { get; set; }\n        public string Filename { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/DownloadRequestDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace MyApp.Models\n{\n    public class DownloadRequestDto\n    {\n        [Required]\n        [Url]\n        [MaxLength(2048)]\n        public string Url { get; set; }\n    }\n}\n```\n\n```csharp\n// Models/DownloadException.cs\nusing System;\n\nnamespace MyApp.Models\n{\n    public class DownloadException : Exception\n    {\n        public DownloadException(string message) : base(message) { }\n    }\n}\n```\n\n```csharp\n// Services/IDownloadService.cs\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public interface IDownloadService\n    {\n        Task<DownloadModel> DownloadContentFromValidatedUrlAsync(string url);\n    }\n}\n```\n\n```csharp\n// Services/DownloadService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Sockets;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class DownloadService : IDownloadService\n    {\n        private readonly HttpClient _httpClient;\n        private readonly IConfiguration _configuration;\n        private readonly ILogger<DownloadService> _logger;\n        private readonly HashSet<string> _trustedDomains;\n\n        public DownloadService(HttpClient httpClient, IConfiguration configuration, ILogger<DownloadService> logger)\n        {\n            _httpClient = httpClient;\n            _configuration = configuration;\n            _logger = logger;\n            _trustedDomains = new HashSet<string>(\n                _configuration.GetSection(\"TrustedDownloadDomains\").Get<string[]>() ?? new[] { \"example.com\" },\n                StringComparer.OrdinalIgnoreCase\n            );\n        }\n\n        public async Task<DownloadModel> DownloadContentFromValidatedUrlAsync(string url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                throw new DownloadException(\"URL is required.\");\n            }\n\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))\n            {\n                throw new DownloadException(\"URL is not well-formed.\");\n            }\n\n            if (!string.Equals(uri.Scheme, Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new DownloadException(\"Only HTTPS URLs are allowed.\");\n            }\n\n            if (uri.HostNameType == UriHostNameType.Dns)\n            {\n                if (!_trustedDomains.Contains(uri.Host))\n                {\n                    throw new DownloadException(\"Domain is not trusted.\");\n                }\n\n                var resolvedIps = await Dns.GetHostAddressesAsync(uri.Host);\n\n                if (resolvedIps.Length == 0)\n                {\n                    throw new DownloadException(\"Domain could not be resolved.\");\n                }\n\n                foreach (var ip in resolvedIps)\n                {\n                    if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                    {\n                        throw new DownloadException(\"Resolved IP address is not allowed.\");\n                    }\n                }\n            }\n            else if (uri.HostNameType == UriHostNameType.IPv4 || uri.HostNameType == UriHostNameType.IPv6)\n            {\n                var ip = IPAddress.Parse(uri.Host);\n                if (IsPrivateOrLoopbackOrLinkLocal(ip))\n                {\n                    throw new DownloadException(\"IP address is not allowed.\");\n                }\n            }\n            else\n            {\n                throw new DownloadException(\"Unsupported hostname type.\");\n            }\n\n            var ipToUse = await GetFirstValidPublicIpAsync(uri);\n\n            var builder = new UriBuilder(uri)\n            {\n                Host = ipToUse.ToString()\n            };\n\n            var request = new HttpRequestMessage(HttpMethod.Get, builder.Uri);\n            request.Headers.Host = uri.Host;\n\n            HttpResponseMessage response;\n            try\n            {\n                response = await _httpClient.SendAsync(request);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Failed to fetch resource from {Uri}\", uri);\n                throw new DownloadException(\"Failed to fetch resource.\");\n            }\n\n            if (!response.IsSuccessStatusCode)\n            {\n                throw new DownloadException($\"Failed to download resource. Status: {response.StatusCode}\");\n            }\n\n            var content = await response.Content.ReadAsByteArrayAsync();\n\n            return new DownloadModel\n            {\n                Url = url,\n                Content = content,\n                Filename = GetFilenameFromUri(uri)\n            };\n        }\n\n        private static string GetFilenameFromUri(Uri uri)\n        {\n            var filename = Path.GetFileName(uri.LocalPath);\n            return string.IsNullOrEmpty(filename) ? \"download.bin\" : filename;\n        }\n\n        private static bool IsPrivateOrLoopbackOrLinkLocal(IPAddress ip)\n        {\n            if (ip.IsIPv6LinkLocal || ip.IsIPv6SiteLocal || ip.IsIPv6Multicast || ip.IsIPv6Teredo)\n            {\n                return true;\n            }\n            if (IPAddress.IsLoopback(ip))\n            {\n                return true;\n            }\n            if (ip.AddressFamily == AddressFamily.InterNetwork)\n            {\n                var bytes = ip.GetAddressBytes();\n                // 10.0.0.0/8\n                if (bytes[0] == 10)\n                {\n                    return true;\n                }\n                // 172.16.0.0/12\n                if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)\n                {\n                    return true;\n                }\n                // 192.168.0.0/16\n                if (bytes[0] == 192 && bytes[1] == 168)\n                {\n                    return true;\n                }\n                // 169.254.0.0/16 (link-local)\n                if (bytes[0] == 169 && bytes[1] == 254)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private async Task<IPAddress> GetFirstValidPublicIpAsync(Uri uri)\n        {\n            var host = uri.Host;\n            var addresses = await Dns.GetHostAddressesAsync(host);\n            foreach (var ip in addresses)\n            {\n                if (!IsPrivateOrLoopbackOrLinkLocal(ip))\n                {\n                    return ip;\n                }\n            }\n            throw new DownloadException(\"No valid public IP found for host.\");\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing MyApp.Services;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var builder = WebApplication.CreateBuilder(args);\n\n            builder.Services.AddControllers();\n            builder.Services.AddHttpClient<IDownloadService, DownloadService>();\n            builder.Services.AddScoped<IDownloadService, DownloadService>();\n            builder.Services.AddAuthorization(options =>\n            {\n                options.AddPolicy(\"DownloadPolicy\", policy => policy.RequireAuthenticatedUser());\n            });\n\n            builder.Configuration.AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true);\n\n            var app = builder.Build();\n\n            app.UseRouting();\n\n            app.UseAuthentication();\n            app.UseAuthorization();\n\n            app.MapControllers();\n\n            app.Run();\n        }\n    }\n}\n```\n\n```csharp\n// appsettings.json\n{\n  \"TrustedDownloadDomains\": [\n    \"example.com\",\n    \"trustedsite.com\"\n  ]\n}\n```", "orig": "```csharp\n// Controllers/DownloadController.cs\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace MyApp.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class DownloadController : ControllerBase\n    {\n        [HttpGet(\"{url}\")]\n        public async Task<IActionResult> DownloadAsync(string url)\n        {\n            // Download the content from the URL\n            var content = await DownloadContentAsync(url);\n\n            // Return the content as a file\n            return File(content, \"application/octet-stream\", \"download.txt\");\n        }\n\n        private async Task<byte[]> DownloadContentAsync(string url)\n        {\n            // Download the content from the URL\n            using var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var content = await response.Content.ReadAsByteArrayAsync();\n            return content;\n        }\n    }\n}\n\n// Models/DownloadModel.cs\nusing System.Collections.Generic;\n\nnamespace MyApp.Models\n{\n    public class DownloadModel\n    {\n        public string Url { get; set; }\n        public byte[] Content { get; set; }\n    }\n}\n\n// Services/DownloadService.cs\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing MyApp.Models;\n\nnamespace MyApp.Services\n{\n    public class DownloadService\n    {\n        private readonly HttpClient _client;\n\n        public DownloadService(HttpClient client)\n        {\n            _client = client;\n        }\n\n        public async Task<DownloadModel> DownloadAsync(string url)\n        {\n            // Download the content from the URL\n            var content = await DownloadContentAsync(url);\n\n            // Return the content as a DownloadModel\n            return new DownloadModel\n            {\n                Url = url,\n                Content = content\n            };\n        }\n\n        private async Task<byte[]> DownloadContentAsync(string url)\n        {\n            // Download the content from the URL\n            using var client = new HttpClient();\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var content = await response.Content.ReadAsByteArrayAsync();\n            return content;\n        }\n    }\n}\n\n// Program.cs\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MyApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureServices((context, services) =>\n                {\n                    services.AddControllers();\n                    services.AddScoped<DownloadService>();\n                });\n    }\n}\n```"}

